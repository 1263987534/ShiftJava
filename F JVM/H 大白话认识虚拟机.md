[TOC]

### 大白话谈虚拟机



#### 概述

##### 1. JVM的基本介绍

JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。通过在实际的计算机上仿真模拟各类计算机功能实现。它直接和操作系统进行交互，与硬件不直接交互，可操作系统可以帮我们完成和硬件进行交互的工作。

<img src="assets/d947f91e44c44c6c80222b49c2dee859-new-image19a36451-d673-486e-9c8e-3c7d8ab66929-1595521393646.png" style="zoom:77%;" />

##### 2. Java文件是如何被运行的

比如现在写了一个 HelloWorld.java，它就是一个文本文件而已。**JVM** 是不认识文本文件的，所以它需要进行**编译** ，让其成为一个它会读二进制文件的 **HelloWorld.class** 

###### (1) 类加载器

如果 **JVM** 想要执行这个 **.class** 文件，需要将其装进一个 **类加载器** 中，它就像一个搬运工一样，会把所有的 **.class** 文件全部搬进 JVM 里面。

<img src="assets/81f1813f371c40ffa1c1f6d78bc49ed9-new-image28314ec8-066f-451e-8373-4517917d6bf7-1595521393646.png" style="zoom:80%;" />

###### (2) 方法区

**方法区** 是用于存放类似于**元数据信息**方面的数据的，比如类信息，常量，静态变量，编译后代码···等。类加载器将 **.class 文件搬过来**就是先丢到这一块上。

###### (3) 堆

**堆** 主要放了一些存储的数据，比如对象实例，数组等，它和方法区都同属于 **线程共享区域** 。也就是说它们都是 **线程不安全** 的。

###### (4) 栈

**栈** 是代码运行空间。编写的每一个方法都会放到 **栈** 里面运行。

###### (5) 程序计数器

主要就是完成一个加载工作，类似于一个指针一样的，指向下一行需要执行的代码。和栈一样，都是 **线程独享** 的，就是说每一个线程都会有自己对应的一块区域而不会存在并发和多线程的问题。

![](assets/897863ee5ecb4d92b9119d065f468262-new-imagef7287f0b-c9f0-4f22-9eb4-6968bbaa5a82-1595521393646.png)

##### 3. 简单的代码例子

一个简单的学生类：

![](assets/29046a721c2548e0a0680ec5baf4ea95-new-imageb0b42e5e-8e25-409e-b7b9-6586a39a0b8d-1595521393646.png)

一个main方法

![](assets/a3d34d33eab74f6f8743ecf62807445c-new-image08506a9e-5101-4f30-b0bc-3abbcb8f1894-1595521393646.png)

执行 main 方法的步骤如下:

1.  编译好 App.java 后得到 App.class 后，执行 App.class，系统会启动一个 JVM 进程，从 **classpath** 路径中找到一个名为 **App.class 的二进制文件**，将 **App 的类信息加载到运行时数据区的方法区内，这个过程叫做 App 类的加载**。
2.  JVM 找到 App 的主程序入口，执行 main 方法。
3.  这个 main 中的第一条语句为 Student student = new Student("tellUrDream") ，就是让 JVM **创建一个 Student 对象**，但是这个时候**方法区**中是没有 Student 类的信息的，所以 JVM 马上**加载 Student 类**，把 Student 类的信息放到方法区中。
4.  加载完 Student 类后，JVM 在**堆中**为一个新的 Student **实例分配内存**，然后调用构造函数初始化 Student 实例，这个 Student 实例持有 **指向方法区中的 Student 类的类型信息** 的引用。
5.  执行 student.sayName(); 时，JVM 根据 **student 的引用找到 student 对象**，然后根据 student 对象**持有的引用定位到方法区中 student 类的类型信息的方法表**，获得 sayName() 的**字节码地址**。
6.  执行 sayName() 方法。

**总结一下就是对象实例初始化时会去方法区中找类信息，完成后再到栈那里去运行方法。找方法就在方法表中找。**

#### 类加载器

它是负责加载 **.class 文件**的，它们在文件开头会有特定的文件标示，将 class 文件字节码内容加载到内存中，并将这些内容**转换成方法区中的运行时数据结构**，并且 ClassLoader 只负责 class 的加载，而是否能够运行则由 Execution Engine 来决定。

##### 1. 类加载的流程

从类被加载到虚拟机内存中开始，到释放内存总共有 7 个步骤：**加载，验证，准备，解析，初始化，使用，卸载**。其中**验证，准备，解析三个部分统称为连接**。

###### (1) 加载

1.  将 class 文件加载到内存。
2.  将静态数据结构转化成方法区中运行时的数据结构。
3.  在堆中生成一个代表这个类的 java.lang.Class 对象作为数据访问的入口。

###### (2) 链接

1.  **验证**：确保加载的**类符合 JVM 规范和安全**，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查。
2.  **准备**：为 **static 变量在方法区中分配内存空间**，设置变量的**初始值**，例如 static int a = 3 （注意：准备阶段只设置类中的静态变量（方法区中），**不包括实例变量**（堆内存中），**实例变量是对象初始化时赋值的**）。
3.  **解析**：虚拟机将常量池内的**符号引用替换为直接引用**的过程（符号引用比如现在 import java.util.ArrayList 这就算**符号引用**，直接引用就是**指针或者对象地址**，注意引用对象一定是在**内存进行**）。

###### (3) 初始化

初始化其实就是一个**赋值的操作**，它会执行一个**类构造器的 \<clinit>() 方法**。由**编译器自动收集类中所有变量的赋值动作**，此时准备阶段时的那个 static int a = 3 的例子，在这个时候就正式赋值为 3。

###### (4) 卸载

GC将无用对象从内存中卸载。

##### 2. 类加载器的加载顺序

加载一个 Class 类的顺序也是有优先级的，类加载器从**最底层开始往上**的顺序是这样的：

1.  **BootStrapClassLoader**：**rt.jar**。
2.  **ExtentionClassLoader**: 加载**扩展的 jar 包**。
3.  **AppClassLoader**：指定的 **classpath 下面的 jar 包**。
4.  **CustomClassLoader**：自定义的类加载器。

##### 3. 双亲委派机制

当一个类收到了**加载请求**时，它是不会先自己去尝试加载的，而是**委派给父类去完成**，比如现在要 new 一个 Person，这个 Person 是自定义的类，如果要加载它，就会先委派 App ClassLoader，只有当父类加载器都反馈自己无法完成这个请求（也就是父类加载器都没有找到加载所需的 Class）时，**子类加载器才会自行尝试加载**。

这样做的好处是，加载位于 rt.jar 包中的类时不管是哪个加载器加载，**最终都会委托到BootStrap ClassLoader进行加载**，这样保证了使用**不同的类加载器得到的都是同一个结果**。

其实这个也是一个**隔离**的作用，避免了自己的代码**影响了 JDK 的代码**，比如自己写一个 java.lang.String 类：

```java
public class String(){
    public static void main(){sout;}
}
```

这种时候代码肯定会报错，因为在加载的时候其实是找到了 rt.jar 中的 **String.class**。

#### 运行时数据区

##### 1. 本地方法栈和程序计数器

比如说现在点开 Thread 类的源码，会看到它的 **start0 方法**带有一个 **native 关键字**修饰，而且不存在方法体，这种用 native 修饰的方法就是**本地方法**，这是使用 C++ 来实现的，然后一般这些方法都会放到一个叫做**本地方法栈**的区域。

**程序计数器**其实就是一个**指针**，它指向了程序中下一句需要执行的指令，它也是内存区域中唯一一个不会出现 OutOfMemoryError 的区域，而且占用内存空间小到基本可以**忽略不计**。这个内存仅代表当前线程所执行的字节码的**行号指示器**，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令。如果执行的是 **native 方法**，那这个**指针就不工作**了。

##### 2. 方法区

**方法区**主要的作用技术存放**类的元数据信息**，常量和静态变量等。当它存储的信息过大时，会在无法满足内存分配时报错。

##### 3. 虚拟机栈和虚拟机堆

一句话便是：**栈管运行，堆管存储**。即**栈负责运行代码，而堆负责存储数据**。

###### (1) 虚拟机栈的概念

它是 Java 方法**执行的内存模型**。里面会对**局部变量，动态链表，方法出口，栈的操作（入栈和出栈）进行存储，且线程独享**。同时如果听到局部变量表，那也是在说虚拟机栈。

```java
public class Person{
    int a = 1;

    public void doSomething(){
        int b = 2;
    }
}
```

###### (2) 虚拟机栈存在的异常

如果线程请求的栈的**深度**大于虚拟机栈的最大深度，就会报 **StackOverflowError** （这种错误经常出现在递归中）。由于一个方法就会对应一个虚拟机栈，所以 Java 虚拟机也可以动态扩展，但随着扩展会不断地**申请内存**，当无法申请足够内存时就会 **OutOfMemoryError**。

###### (3) 虚拟机栈的生命周期

对于**栈**来说，**不存在垃圾回收**。只要程序运行结束，栈的空间**自然就会释放**了。栈的生命周期和所处的线程是一致的。

注意：**8 种基本类型的变量+对象的引用变量+实例方法**都是在**栈里面分配内存**。

###### (4) 虚拟机栈的执行

经常说的**栈帧数据**，说白了在 JVM 中叫**栈帧**，放到 Java 中其实就是**方法**，它也是存放在栈中的。

**栈中的数据都是以栈帧的格式存在**，它是一个关于**方法和运行期数据的数据集**。比如执行一个方法 a，就会对应产生一个栈帧 A1，然后 A1 会被压入栈中。同理方法 b 会有一个 B1，方法 c 会有一个 C1，等到这个线程执行完毕后，栈会先弹出 C1，后 B1, A1。它是一个先进后出，后进先出原则。

###### (5) 局部变量的复用

**局部变量表**用于存放**方法参数和方法内部所定义的局部变量**。它的容量是以 **Slot** 为最小单位，一个 slot 可以存放 32 位以内的数据类型。

虚拟机通过**索引定位的方式使用局部变量表**，范围为 [0, 局部变量表的 slot 的数量]。方法中的参数就会按一定顺序排列在这个局部变量表中，至于怎么排的可以先不关心。而为了节省栈帧空间，这些 slot 是可以**复用**的，当方法执行位置超过了某个变量，那么这个变量的 slot 可以被其它变量复用。当然如果需要复用，那垃圾回收自然就不会去动这些内存。

###### (6) 虚拟机堆的概念

JVM 内存会划分为**堆内存和非堆内存**，堆内存中也会划分为**年轻代**和**老年代**，而非堆内存则为**永久代**。**年轻代**又会分为 **Eden** 和 **Survivor** 区。Survivor 也会分为 **FromPlace** 和 **ToPlace**，toPlace 的 survivor 区域是**空的**。Eden，FromPlace 和 ToPlace 的默认占比为 **8:1:1**。当然这个东西其实也可以通过一个 -XX:+**UsePSAdaptiveSurvivorSizePolicy** 参数来根据生成对象的速率动态调整。

**堆内存中存放的是对象**，垃圾收集就是收集这些对象然后交给 **GC 算法**进行回收。非堆内存其实已经说过了，就是方法区。在 1.8 中已经**移除永久代**，替代品是一个**元空间**(MetaSpace)，最大区别是 metaSpace 是不存在于 JVM 中的，它使用的是**本地内存**。并有两个参数

```java
MetaspaceSize  		// 初始化元空间大小，控制发生GC
MaxMetaspaceSize  	//限制元空间大小上限，防止占用过多物理内存
```

移除的原因可以大致了解一下：**融合 HotSpot JVM 和 JRockit VM 而做出的改变**，因为 **JRockit** 是没有永久代的，不过这也间接性地**解决了永久代的 OOM 问题**。

###### (7) Eden年轻代

当 new 一个对象后，一般会先放到 Eden 划分出来的一块作为存储空间的内存，但是堆内存是线程共享的，所以有可能会出现**两个对象共用一个内存**的情况。这里 JVM 的处理是**每个线程**都会预先**申请好一块连续的内存空间**并规定了对象存放的位置，而如果空间不足会再申请多块内存空间。这个操作被称作 **TLAB**，有兴趣可以了解一下。

当 **Eden 空间满**了之后，会触发一个叫做 **Minor GC**（就是一个发生在年轻代的 GC）的操作，存活下来的**对象移动到 Survivor0 区**。Survivor0 区满后**触发 Minor GC**，就会将存活对象移动到 **Survivor1 区**，此时还会把 from 和 to 两个**指针交换**，这样保证了一段时间内总有一个 survivor 区为空且 to 所指向的 survivor 区为**空**。经过多次的 Minor GC后仍然存活的对象（**这里的存活判断是 15 次，对应到虚拟机参数为 -XX:MaxTenuringThreshold 。为什么是 15，因为 HotSpot 会在对象投中的标记字段里记录年龄，分配到的空间仅有 4位，所以最多只能记录到 15**）会移动到**老年代**。老年代是存储长期存活的对象的，老年代占满时就会触发最常听说的 Full GC，期间会停止所有线程**等待 GC 的完成**。所以对于响应要求高的应用应该尽量去**减少发生 Full GC** 从而避免响应超时的问题。

而且当老年区执行了 full gc 之后仍然无法进行对象保存的操作，就会产生 **OOM**，这时候就是虚拟机中的**堆内存不足**，原因可能会是堆内存设置的大小过小，这个可以通过参数-Xms、-Xms 来调整。也可能是代码中创建的**对象大且多**，而且它们一直在被引用从而长时间垃圾收集无法收集它们。

![](assets/c02ecba3c33f43429a765987b928e423-new-image93b46f3d-33f9-46f9-a825-ec7129b004f6-1595521393646.png)

补充说明：关于 -XX:TargetSurvivorRatio 参数的问题。其实也不一定是要满足 -XX:MaxTenuringThreshold 才移动到老年代。可以举个例子：如对象年龄 5 的占 30%，年龄 6 的占 36%，年龄 7 的占 34%，加入某个年龄段（如例子中的年龄 6）后，总占用超过**Survivor 空间 *TargetSurvivorRatio** 的时候，从该年龄段**开始及大于的年龄对象就要进入老年代**（即例子中的年龄 6 对象，就是年龄 6 和年龄 7 晋升到老年代），这时候无需等到 MaxTenuringThreshold 中要求的 15。

###### (8) 如何判断一个对象需要被回收

![](assets/1c1d85b5fb8b47239af2a5c0436eb2d7-new-image0cd10827-2f96-433c-9b16-93d4fe491d88-1595521393646.png)

图中程序计数器、虚拟机栈、本地方法栈，3 个区域随着**线程的生存而生存**的。内存分配和回收都是**确定**的。随着线程的结束内存自然就被回收了，因此不需要考虑垃圾回收的问题。而**堆和方法区**则不一样，各线程**共享**，内存的分配和回收都是**动态**的。因此垃圾收集器所关注的都是**堆和方法这**部分内存。

在进行回收前就要判断**哪些对象还存活**，哪些已经死去。下面介绍两个基础的方法：

**引用计数器法**：给对象添加一个引用计数器，每次引用这个对象时计数器加一，引用失效时减一，计数器等于 0 时就是不会再次使用的。不过这个方法有一种情况就是出现**对象的循环引用**时 GC 没法回收。

**可达性分析法**：这是一种类似于**二叉树**的实现，将一系列的 **GC ROOTS** 作为起始的存活对象集，从这个节点往下搜索，搜索所走过的路径成为**引用链**，把能被该集合引用到的对象加入到集合中。搜索当一个对象到 GC Roots 没有使用任何引用链时，则说明该对象是**不可用**的。主流的商用程序语言，例如 Java，C# 等都是靠这招去判定对象是否存活的。

能作为 GC Roots 的对象分为以下几种：

1.  虚拟机栈（栈帧中的本地方法表）中引用的对象（局部变量）。
2.  方法区中静态变量所引用的对象（静态变量）。
3.  方法区中常量引用的对象。
4.  本地方法栈（即 native 修饰的方法）中 JNI 引用的对象（JNI 是 Java 虚拟机调用对应的 C 函数的方式，通过 JNI 函数也可以创建新的 Java 对象。且 JNI 对于对象的局部引用或者全局引用都会把它们指向的对象都标记为不可回收）。
5.  已启动的且未终止的 Java 线程。


这种方法的优点是能够解决循环引用的问题，可它的实现需要**耗费大量资源和时间**，也需要GC（它的分析过程引用关系不能发生变化，所以需要停止所有进程）。

###### (9) 如何宣告一个对象的真正死亡

首先必须要提到的是一个名叫 **finalize()** 的方法。

finalize() 是 **Object 类**的一个方法、一个对象的 finalize() 方法只会被系**统自动调用一次**，经过 finalize() 方法逃脱死亡的对象，**第二次不会再调用**。

补充一句：**并不提倡**在程序中调用 finalize() 来进行自救。建议**忘掉**该方法的存在。因为它**执行的时间不确定，甚至是否被执行也不确定**（程序的不正常退出），而且运行代价高昂，无法保证各个对象的调用顺序（甚至有不同线程中调用）。在 Java9 中已经被标记为 **deprecated** ，且 java.lang.ref.Cleaner（也就是强、软、弱、幻象引用的那一套）中已经**逐步替换掉它**，会比 finalize 来的更加的轻量及可靠。

判断一个对象的死亡至少需要两次标记：

1.  如果对象进行可达性分析之后没发现与 GC Roots 相连的引用链，那它将会**第一次标记**并且进行一次筛选。判断的条件是决定这个对象**是否有必要执行 finalize() 方法**。如果对象有必要执行 finalize() 方法，则被放入 F-Queue 队列中。
2.  GC 对 F-Queue 队列中的对象进行**二次标记**。如果对象在 finalize() 方法中**重新与引用链上的任何一个对象建立了关联**，那么二次标记时则会将它**移出**“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。

如果确定对象已经死亡，又该如何回收这些垃圾呢？

##### 4. 垃圾回收算法

常用的有标记清除，复制，标记整理和分代收集算法。

###### (1) 标记清除算法

标记清除算法就是分为“**标记**”和“**清除**”两个阶段。标记出所有需要回收的对象，标记结束后统一回收。这个套路很简单，也存在不足，后续的算法都是根据这个基础来加以改进的。

其实它就是把已死亡的对象标记为空闲内存，然后记录在一个空闲列表中，当需要 new 一个对象时，内存管理模块会从空闲列表中寻找空闲的内存来分给新的对象。

不足的方面就是标记和清除的效率比较低下。且这种做法会让内存中的**碎片非常多**。这个导致了如果我们需要使用到较大的内存块时，无法分配到足够的连续内存。比如下图：

![](assets/01605d96d85f4daab9bfa5e7000f0d31-new-image78e03b85-fbef-4df9-b41e-2b63d78d119f-1595521393646.png)

此时可使用的内存块都是零零散散的，导致了刚刚提到的大内存对象问题。

###### (2) 复制算法

为了解决效率问题，**复制算法**就出现了。它将可用内存按**容量划分成两等分**，每次只使用其中的一块。和 survivor 一样也是用 from 和 to 两个指针这样的玩法。fromPlace 存满了，就把存活的对象 copy 到另一块 toPlace 上，然后**交换指针**的内容。这样就**解决了碎片的问题**。

这个算法的代价就是把**内存缩水**了，这样堆内存的使用效率就会变得十分低下了。

![](assets/fc349fbb9b204495a5321febe27818d4-new-image45920a9a-552c-4656-94d6-e3ca45ff9b76-1595521393646.png)

不过它们分配的时候也**不是按照 1:1** 这样进行分配的，就类似于 Eden 和 Survivor 也不是等价分配是一个道理。

###### (3) 标记整理算法

复制算法在对象存活率高的时候会有一定的效率问题，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的**对象都向一端移动**，然后直接清理掉边界以外的内存。

![](assets/2599e9f722074d34a3f7fd9f0076f121-new-imagec76192ec-b63a-43e3-a6d6-cf01f749953f-1595521393646.png)

###### (4) 分代收集算法

这种算法并没有什么新的思想，只是根据**对象存活周期的不同将内存划分为几块**。一般是把**堆分为新生代和老年代**，这样就可以根据**各个年代的特点采用最适当的收集算法**。在**新生代**中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用**复制算法**，只需要付出少量存活对象的复制成本就可以完成收集。而**老年代中因为对象存活率高**、没有额外空间对它进行分配担保，就必须使用“**标记-清除**”或者“**标记-整理**”算法来进行回收。

##### 5. 垃圾回收器

HotSpot VM 中的垃圾回收器，以及适用场景：

![](assets/11e9dcd0f1ee4f25836e6f1c47104c51-new-image69e1c56a-1d40-493a-9901-6efc647a01f3-1595521393646.png)

jdk8 默认的垃圾收集器是 **Parallel Scavenge 和 Parallel Old**。

从 jdk9 开始，**G1 **收集器成为默认的垃圾收集器。

目前来看，G1 回收器停顿时间最短而且没有明显缺点，非常适合 Web 应用。在 jdk8 中测试Web 应用，堆内存 6G，新生代 4.5G 的情况下，Parallel Scavenge 回收新生代停顿长达 1.5 秒。G1 回收器回收同样大小的新生代只停顿 0.2 秒。

##### 6. JVM的常用参数

JVM 的参数非常之多，这里只列举比较重要的几个，通过各种各样的搜索引擎也可以得知这些信息。

|          参数名称          |                            含义                            |        默认值        |                             说明                             |
| :------------------------: | :--------------------------------------------------------: | :------------------: | :----------------------------------------------------------: |
|            -Xms            |                         初始堆大小                         | 物理内存的1/64(<1GB) | 默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制 |
|            -Xmx            |                         最大堆大小                         | 物理内存的1/4(<1GB)  | 默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制 |
|            -Xmn            |                  年轻代大小(1.4or lator)                   |                      | 注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 老年代大小 + 持久代（永久代）大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8 |
|        -XX:NewSize         |                设置年轻代大小(for 1.3/1.4)                 |                      |                                                              |
|       -XX:MaxNewSize       |                 年轻代最大值(for 1.3/1.4)                  |                      |                                                              |
|        -XX:PermSize        |                 设置持久代(perm gen)初始值                 |    物理内存的1/64    |                                                              |
|      -XX:MaxPermSize       |                      设置持久代最大值                      |    物理内存的1/4     |                                                              |
|            -Xss            |                     每个线程的堆栈大小                     |                      | JDK5 以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用，如果栈不是很深，128k应该是够用的，大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。 |
|        -XX:NewRatio        | 年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代) |                      | -XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。 |
|     -XX:SurvivorRatio      |                Eden区与Survivor区的大小比值                |                      | 设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10 |
|   -XX:+DisableExplicitGC   |                      关闭System.gc()                       |                      |                    这个参数需要严格的测试                    |
| -XX:PretenureSizeThreshold |               对象超过多大是直接在旧生代分配               |          0           | 单位字节 新生代采用Parallel ScavengeGC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象. |
|   -XX:ParallelGCThreads    |                     并行收集器的线程数                     |                      |          此值最好配置与处理器数目相等 同样适用于CMS          |
|    -XX:MaxGCPauseMillis    |         每次年轻代垃圾回收的最长时间(最大暂停时间)         |                      |    如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值.    |

#### JVM调优建议

尝试对 JVM 进行调优，主要就是堆内存那块。

所有**线程共享数据区大小=新生代大小 + 年老代大小**。所以堆中增大年轻代后，将会减小年老代大小（因为老年代的清理是使用 Full GC，所以**老年代**过小的话反而是会增多 Full GC 的）。此值对系统性能影响较大，官方推荐**配置为 Java 堆的 3/8**。

##### 1. 调整最大堆内存和最小堆内存

**-Xmx –Xms**：指定堆最大值（默认值是物理内存的 1/4(<1GB)）和初始堆最小值（默认值是物理内存的 1/64(<1GB))。

默认(MinHeapFreeRatio 参数可以调整)空余堆内存**小于 40 %时**，JVM 就会增大堆直到-Xmx 的最大限制.，默认(MaxHeapFreeRatio 参数可以调整)空余堆内存大于 70% 时，JVM 会减少堆直到 -Xms 的最小限制。简单点来说，如果不停地往堆内存里面丢数据，等它剩余大小小于 40% 了，JVM 就会动态申请内存空间不过会**小于 -Xmx**，如果剩余大小大于 70%，又会**动态缩小不过不会小于 –Xms**。就这么简单。

开发过程中，通常会将 -Xms 与 -Xmx两个参数的**配置相同的值**，其目的是为了能够在垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。

执行下面的代码

```java
System.out.println("Xmx=" + Runtime.getRuntime().maxMemory() / 1024.0 / 1024 + "M");    //系统的最大空间
// 系统的空闲空间
System.out.println("free mem=" + 
                   Runtime.getRuntime().freeMemory() / 1024.0 / 1024 + "M");  
// 当前可用的总空间
System.out.println("total mem=" + Runtime.getRuntime().totalMemory() / 1024.0 / 1024 + "M");  
```

注意：此处设置的是堆大小，也就是**新生代 + 老年代大小**。

![](assets/5e7b352c16d74c789c665af46d3a2509-new-imagedd645dae-307d-4572-b6e2-b5a9925a46cd-1595521393646.png)

设置一个 VM options 的参数：

    -Xmx20m -Xms5m -XX:+PrintGCDetails

![](assets/fe99e355f4754fa4be7427cb65261f3d-new-imagebb5cf485-99f8-43eb-8809-2a89e6a1768e-1595521393646.png)

再次启动 main 方法：

![](assets/300539f6560043dd8a3fe085d28420e6-new-image3c581a2e-196f-4b01-90f1-c27731b4610b-1595521393646.png)

这里 GC 弹出了一个 **Allocation Failure 分配失败**，这个事情发生在 PSYoungGen，也就是年轻代中。

这时候申请到的内存为 18M，空闲内存为 4.214195251464844M。

此时创建一个字节数组看看，执行下面的代码：

```java
byte[] b = new byte[1 * 1024 * 1024];
System.out.println("分配了1M空间给数组");
System.out.println("Xmx=" + Runtime.getRuntime().maxMemory() / 1024.0 / 1024 + "M");  //系统的最大空间
// 系统的空闲空间
System.out.println("free mem=" + Runtime.getRuntime().freeMemory() / 1024.0 / 1024 + "M");  
System.out.println("total mem=" + Runtime.getRuntime().totalMemory() / 1024.0 / 1024 + "M");
```


![](assets/bdd717d0a3394be7a733760052773374-new-image371b5d59-0020-4091-9874-603c0ab0073d-1595521393647.png)

此时 free memory 就又缩水了，不过 total memory 是没有变化的。Java 会尽可能将 total mem 的值维持在最小堆内存大小。


```java
byte[] b = new byte[10 * 1024 * 1024];
System.out.println("分配了10M空间给数组");
System.out.println("Xmx=" + Runtime.getRuntime().maxMemory() / 1024.0 / 1024 + "M");  //系统的最大空间
System.out.println("free mem=" + Runtime.getRuntime().freeMemory() / 1024.0 / 1024 + "M");  //系统的空闲空间
System.out.println("total mem=" + Runtime.getRuntime().totalMemory() / 1024.0 / 1024 + "M");  //当前可用的总空间
```

![](assets/0fd7550ae2144adca8ed2ede12d5fb96-new-image0c31ff20-289d-4088-8c67-a846d0c5d1e0-1595521393647.png)

这时候创建了一个 10M 的字节数据，这时候最小堆内存是**顶不住**的。会发现现在的 total memory 已经变成了 15M，这就是已经**申请了一次内存**的结果。

此时再跑一下这个代码：

```java
System.gc();
// 系统的最大空间
System.out.println("Xmx=" + Runtime.getRuntime().maxMemory() / 1024.0 / 1024 + "M");    
// 系统的空闲空间
System.out.println("free mem=" + Runtime.getRuntime().freeMemory() / 1024.0 / 1024 + "M");  
// 当前可用的总空间
System.out.println("total mem=" + Runtime.getRuntime().totalMemory() / 1024.0 / 1024 + "M");  
```

![](assets/4cc44b5d5d1c40c48640ece6a296b1ac-new-image4b57baf6-085b-4150-9c60-ac51b0f815d7-1595521393647.png)

此时手动执行了一次 fullgc，此时 total memory 的内存空间又变回 5.5M 了，此时又是把申请的内存释放掉的结果。

##### 2. 调整新生代和老年代的比值

**-XX:NewRatio**：配置新生代（eden+2*Survivor）和老年代（不包含永久区）的比值。

例如：-XX:NewRatio=4，表示新生代：老年代 = 1：4，即新生代占整个堆的 1/5。在 Xms=Xmx 并且设置了 Xmn 的情况下，该参数**不需要**进行设置。

##### 3. 调整Survivor区和Eden区的比值

**-XX:SurvivorRatio**： 设置两个 Survivor 区和 eden 的比值。

##### 4. 设置年轻代和老年代的大小

**-XX:NewSize**：设置年轻代大小。

**-XX:MaxNewSize**：设置年轻代最大值。

可以通过设置不同参数来测试不同的情况，反正最优解当然就是官方的 Eden 和 Survivor 的占比为 **8:1:1**，然后在介绍这些参数的时候都已经附带了一些说明，感兴趣的也可以看看。反正最大堆内存和最小堆内存如果数值不同会导致多次的gc，需要注意。

##### 5. 小总结

根据实际情况**调整新生代和幸存代的大小**，官方推荐**新生代占堆的 3/8**，**幸存代占新生代的 1/10**。

在 OOM 时，记得 **Dump 出堆**，确保可以排查现场问题，通过下面命令可以输出一个**.dump文件**，这个文件可以使用 VisualVM 工具查看分析。

```java
-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=要输出的日志路径
```

一般也可以通过编写**脚本**的方式来让 OOM 出现时通过发送邮件或者重启程序等来解决。

##### 6. 永久代的设置

-XX:PermSize：初始空间（默认为物理内存的1/64）
-XX:MaxPermSize：最大空间（默认为物理内存的1/4）

永久区一开始就占用了 PermSize 大小的空间，如果空间还不够，可以继续扩展，但是不能超过 MaxPermSize，否则会OOM。JDK8 之后就废弃了永久代了。

##### 7. JVM的栈参数调优

###### (1) 调整每个线程栈空间的大小

可以通过 **-Xss**：调整每个线程栈空间的大小。

JDK5.0 以后每个线程堆栈大小为 **1M**，以前每个线程堆栈大小为 **256K**。在相同物理内存下，减小这个值能**生成更多的线程**。但是操作系统对一个进程内的**线程数**还是有限制的，不能无限生成，经验值在 3000~5000 左右。

###### (2) 设置线程栈的大小

**-XXThreadStackSize**：设置线程栈的大小(0 means use default stack size)。

##### 8. JVM其他参数介绍

- -XXThreadStackSize：设置内存页的大小，不可设置过大，会影响 Perm 的大小。
- -XX:+UseFastAccessorMethods：设置原始类型的快速优化。
- -XX:+DisableExplicitGC：设置关闭System.gc()(这个参数需要严格的测试)。
- -XX:MaxTenuringThreshold：设置对象最大年龄。
- -XX:+AggressiveOpts：加快编译速度。
- -XX:+UseBiasedLocking：改善锁机制性能。
- -Xnoclassgc：禁用垃圾回收。
- -XX:SoftRefLRUPolicyMSPerMB：设置每兆堆空闲空间中SoftReference的存活时间，默认值是 1s。
- -XX:PretenureSizeThreshold：设置对象超过多大时直接在老年代分配，默认值是 0。
- -XX:TLABWasteTargetPercent：设置TLAB占eden区的百分比，默认值是 1% 。
- -XX:+CollectGen0First：设置 FullGC 时是否先 YGC，默认值是 false。



#### 参考资料

- https://juejin.im/post/5e1505d0f265da5d5d744050#heading-28