[TOC]

### HTTPS

#### 基础

##### 1. HTTP的安全性问题

HTTP 有以下安全性问题：

- (1) 使用**明文**进行通信，内容可能会被**窃听**。
- (2) **不验证**通信方的身份，通信方的身份有可能遭遇**伪装**。
- (3) 无法证明报文的**完整性**，报文有可能遭**篡改**。

##### 2. HTTPS概念

HTTPS 并不是新协议，而是让 **HTTP** 先和 **SSL/TLS**（Secure Sockets Layer）**通信**，再由 **SSL/TLS 和 TCP** 通信，也就是说 HTTPS 使用了**隧道**进行通信。通过使用 SSL/TLS，HTTPS 具有了**加密（防窃听）、认证（防伪装）和完整性保护（防篡改）**。

**==HTTP + 加密 + 认证 +  完整性保护 = HTTPS==**。HTTPS 经由 HTTP 进行通信，但利用 **SSL/TLS 来保证安全**，即 ==**HTTPS = HTTP + SSL/TLS**==。

**TLS**：位于 HTTP 和 TCP **之间**的协议，其内部有 TLS 握手协议、TLS 记录协议。

<img src="assets/1563596355451-1590926741449.png" alt="1563596355451" style="zoom:52%;" />

下面会详述 HTTPS 是**如何解决加密、认证与完整性保护**的问题。

****

##### 3. HTTP和HTTPS的区别

- **端口不同** ：HTTP 的 URL由“**http**://”起始且默认使用端口 **80**，而 HTTPS 的 URL 由“**https**://”起始且默认使用端口 **443**。

- **安全性**：HTTP 协议运行在 TCP 之上，所有传输的内容都是**明文**，客户端和服务器端都**无法验证对方的身份**。HTTPS 是运行在 **SSL/TLS** 之上的 HTTP 协议，**SSL/TLS 运行在 TCP** 之上。所有传输的内容都经过**加密**，加密采用**对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密**。所以说 HTTP 安全性没有 HTTPS 高 。

- **资源消耗**：HTTPS 比 HTTP 耗费更多服务器资源。HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费。 

##### 4. HTTPS的缺点

- 因为需要进行**加密解密**等过程，对 CPU 的额外**开销较大**，因此速度会更慢；
- 需要支付证书授权的**高额费用**。



#### 加密

##### 1. 对称密钥加密

**对称密钥加密**（Symmetric-Key Encryption），加密和解密使用**同一密钥**。密钥只有一个，加密解密为同一个密码，且加解密速度快。

- **优点**：运算速度快。
- **缺点**：无法安全地将**密钥**传输给通信方。

常用的对称加密算法：**AES**、3DES。

<img src="assets/1563596371003-1590926744330.png" alt="1563596371003" style="zoom:60%;" />

##### 2. 非对称密钥加密

**非对称密钥加密**，又称**公开密钥加密**（Public-Key Encryption），加密和解密使用**不同的密钥**。密钥**成对**出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度**较慢**。

非对称加密一般有两种密钥，**公钥和私钥**，**公钥一般用于加密，私钥一般用于解密**。

非对称加密的安全性是基于**大质数分解的困难性**，在非对称的加密中公钥和私钥是一对大质数函数。计算两个大质数的乘积是简单的，但是这个过程的逆运算也就是把乘积分解成两个质数是非常困难的，在RSA 算法中，从一个公钥和密文中解密出明文的难度等同于分解两个大质数的难度。

常用的非对称加密算法：**RSA**（安全基于大质数的分解难度）、**ECC、SM2** 等。

公开密钥所有人都可以获得，**通信发送方获得接收方的公开密钥之后，就可以==使用公开密钥进行加密==，==接收方收到通信内容后使用私有密钥解密==。**

非对称密钥除了用来**加密**，还可以用来进行**签名**。因为私有密钥无法被其他人获取，因此通信发送方使用其**==私有密钥进行签名==**，通信接收方使用发送方的公开密钥**==对签名进行解密==**，就能判断这个签名是否正确。

- **优点**：可以更安全地将公开密钥传输给通信发送方；
- **缺点**：非对称**加密与解密**运算速度慢，消耗更多的资源。

![image-20191229163613698](assets/image-20191229163613698-1590926711864.png)

##### 3. HTTPS的加密方式

HTTPS 采用==**混合的加密机制**==，**在==交换密钥==环节使用==非对称加密==（公开密钥）方式，之后建立==通信==交换报文阶段（普通数据）则使用==对称加密==（共享密钥加密）方式**。

数据通信时需要用到一个**对称加密**的密钥，但是**直接**发过去是**不安全**的，所以使用**非对称加密**的方式将需要得**对称加密密钥**发送过去。

![image-20191229163806491](assets/image-20191229163806491-1590926711864.png)

一个非常好懂的**加密流程图**。

<img src="assets/1563596421424-1590926762186.png" alt="1563596421424" style="zoom:25%;" />

上述的流程**还差一步**，就是服务器发送**公钥**给客户端的时候，也会一起**发送 CA 数字签名**给客户端用于**认证。**（下面详述）

使用自己的**私钥**对自己所认可的消息生成一个该消息专属的**签名**，这就是**数字签名**，表明**我承认该消息来自自己**。注意：**私钥用于加签，公钥用于解签，每个人都可以解签，查看消息的归属人**。

**客户端：明文 + 公钥 = 密文**。

**服务器：密文 + 私钥 = 明文**。

注意：**公钥用于加密，私钥用于解密，只有私钥的归属者，才能查看消息的真正内容**。

#### 认证

当服务器接收到客户端发来的请求时，会向客户端**发送**服务器自己的**公钥**，但是**黑客有可能中途篡改公钥**，将其改成黑客自己的，所以有个问题，客户端怎么信赖这个公钥是自己想要访问的服务器的公钥而不是黑客的呢？所以客户端也需要对服务器发送过来的**公钥认证其合法性**。 这时候就需要用到 **CA 数字证书**。

**证书**：全称公钥证书（Public-Key Certificate, PKC），里面保存着归属者的基本信息，以及证书过期时间、归属者的公钥，并由认证机构（Certification Authority, **CA**）施加数字签名，表明某个认证机构认定该公钥的确属于此人。

**数字证书认证机构**（**CA**，Certificate Authority）：客户端与服务器双方**都可信赖**的第**三方机构**。

> **如何认证**？

(1) 首先阿里需要将自己的**公钥**发送给 **CA 机构**进行公钥申请，如果通过，则 CA 机构（CA 机构**自己也有公钥和私钥**）则利用其**私钥**对阿里的**公钥进行非对称加密**，得到加密后的**明文**（**数字签名**）。加密完之后，得到的密文再加上**证书的过期时间、颁发给、颁发者**等信息，就组成了**数字证书**。（**数字证书就是数字签名加上各种附加信息**）。

(2) 用户浏览器向阿里发起 HTTPS 连接请求，阿里会将其**公钥 + 数字证书**发送给客户端。

(3) 客户端首先需要对接收到的**公钥进行验证**，以确保公钥**真的就是阿里的而且没有被人篡改**。不论什么平台，设备的操作系统中都会**内置** 100 多个全球公认的 **CA 的公钥**。所以客户端使用 **CA 机构的公钥对数字证书中的数字签名**进行**认证**（因为证书是由 CA 机构的私钥加密的，所以可以用 CA 的公钥来验证）：

- 首先客户端会用设备中内置的 CA 的**公钥**尝试**解密数字证书**，如果所有内置的 CA 的公钥都**无法解密**该数字证书，说明该数字证书不是由一个全球知名的 CA 签发的，这样客户端就**无法信任**该服务器的**数字证书**。
- 如果有一个 CA 的公钥能够成功**解密**该数字证书，说明该数字证书就是由该 CA 的私钥**签发**的，因为被私钥加密的密文只能被与其成对的公钥解密。
- 除此之外，还需要检查客户端当前访问的服务器的域名是与数字证书中提供的“颁发给”这一项吻合，还要检查数字证书是否过期等。

只有通过**认证之后**才能确保这个公钥真的是阿里发送给客户端的，才能继续后面的加密与通信步骤。流程看下图。

<img src="assets/1563596449006-1590926768385.png" alt="1563596449006" style="zoom:72%;" />

|      密码      |                作用                |           组成            |
| :------------: | :--------------------------------: | :-----------------------: |
| **消息认证码** | 确认消息的完整、并对消息的来源认证 |   共享秘钥+消息的散列值   |
|  **数字签名**  |         对消息的散列值签名         |  公钥+私钥+消息的散列值   |
|  **公钥密码**  |     解决**秘钥**的**配送问题**     |      公钥+私钥+消息       |
|    **证书**    |         解决公钥的归属问题         | 公钥密码中的公钥+数字签名 |

#### 完整性保护

**SSL** 提供一种叫做 **MAC** 的==**报文摘要**==功能来进行**完整性保护**。

HTTP 也提供了 **MD5** 报文摘要功能，但**不是安全**的。例如报文内容被篡改之后，同时**重新计算** MD5 的值，通信接收方是无法意识到发生了篡改。

HTTPS 的报文**摘要功能**之所以安全，是因为它结合了**加密和认证**这两个操作。加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。



#### HTTPS通信流程总结

![image-20191229164615493](assets/image-20191229164615493-1590926711864.png)

**服务器端的公钥和私钥，用来进行非对称加密。客户端生成的随机密钥，用来进行对称加密通信。**

一个 HTTPS 请求实际上包含了**两次 HTTP** 传输，可以细分为 8 步。

(1) 客户端向服务器发起 **HTTPS 请求**，连接到服务器的 **443 端口**。

(2) 服务器端有一个密钥对，即**公钥和私钥**，是用来进行非对称加密使用的，**服务器端保存着私钥**，不能将其泄露，公钥可以发送给任何人。

(3) 服务器将自己的**公钥发送给客户端**。

(4) 客户端收到服务器端的公钥之后，会对**公钥进行检查**，验证其**合法性**，如果发现发现公钥有问题，那么 HTTPS 传输就无法继续。严格的说，这里就是**验证服务器发送的==数字证书==的合法性**，关于客户端如何验证数字证书的合法性，上文已经说明。如果**公钥合格**，那么**客户端**会生成一个**随机值**，这个随机值就是用于进行对称加密的**密钥**，将该密钥称之为 client key，即**客户端密钥**，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的**公钥**对**客户端密钥进行==非对称加密==**，这样客户端密钥就变成密文了，至此，HTTPS 中的第一次 HTTP 请求结束。

(5) **客户端**会发起 HTTPS 中的**第二个** HTTP 请求，将**加密之后的客户端密钥发送给服务器**。

(6) 服务器接收到客户端发来的密文之后，会用自己的**私钥**对其进行**非对称解密**，解密之后的明文就是**客户端密钥**，然后用客户端密钥对数据进行==**对称加密**==，这样数据就变成了**密文**。

(7) 然后服务器将**加密后的密文**发送给客户端。

(8) 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样 HTTPS 中的第二个 HTTP 请求结束，整个 HTTPS 传输完成。





#### SSL与TLS

##### 1. 概述

TLS/SSL是一种**加密通道的规范**。

- **SSL**：（Secure Socket Layer） 安全套接层，于 1994 年由网景公司设计，并于 1995 年发布了 3.0 版本。
- **TLS**：（Transport Layer Security）**传输层安全性协议**，是 IETF 在 SSL3.0 的**基础上**设计的协议，可以理解为 SSL 3.1，该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面。

以下全部使用 TLS 来表示。TLS 是一系列密码工具的**框架**，作为框架，它也是非常的灵活，体现在每个工具套件它都可以替换，即：客户端与服务端之间协商密码套件，从而更难的被攻破，例如使用不同方式的对称密码，或者公钥密码、数字签名生成方式、单向散列函数技术的替换等。

在**发送方**，SSL 接收**应用层**的数据，对数据进行**加密**，然后把加了密的数据送往 **TCP 套接字**。在**接收方**，SSL 从 TCP 套接字**读取**数据，**解密**后把数据交给**应用层**。 

##### 2. SSL/TLS 握手流程

SSL/TLS 握手是为了**安全**地协商出一份**对称加密**的秘钥，这个过程如下。

<img src="assets/https_com.png" style="zoom:67%;" />



###### (1) Client Hello

**握手**第一步是客户端向服务端发送 **Client Hello** 消息，这个消息里包含了一个客户端生成的随机数 **Random1**、客户端支持的**加密套件**（Support Ciphers）和 **SSL Version** 等信息。

###### (2) Server Hello

第二步是服务端向客户端发送 **Server Hello** 消息，这个消息会从 Client Hello 传过来的 Support Ciphers 里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体**使用哪些算法**，另外还会生成一份随机数 **Random2**。注意，至此客户端和服务端都拥有了**两个随机数**（Random1+ Random2），这两个随机数会在**后续生成对称秘钥**时用到。

###### (3) Server Certificate

这一步是服务端将自己的**证书下发给客户端**，让客户端验证服务器的身份，客户端验证通过后**取出证书中的公钥**。

###### (4) Server Hello Done

Server Hello Done 通知客户端 Server Hello 过程结束。

###### (5) Client Key Exchange

上面客户端根据服务器传来的**公钥**生成了 **PreMaster Key**，Client Key Exchange 就是将这个 **key 传给服务端**，服务端再用自己的**私钥**解出这个 **PreMaster Key** 得到客户端生成的 **Random3**。至此，客户端和服务端都拥有 **Random1** + **Random2** + **Random3**，两边再根据同样的算法就可以**生成一份秘钥**，握手结束后的应用层数据都是使**用这个秘钥进行对称加密**。

为什么要使用**三个随机数**？这是因为 SSL/TLS 握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解出来。

###### (6) Change Cipher Spec(Client)

这一步是客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥加密了，是一条事件消息。

###### (7) Finished(Client)

客户端发送 **Finished** 报文。该报文包含连接至今全部报文的整理校验值。这次握手协议是否能成功，要以服务器是否能够正确解密该报文作为判定标准。

###### (8) Change Cipher Spec(Server)

服务器同样发送 Change Cipher Spec 报文给客户端。

###### (9) Finished(Server)

服务器同样发送Finished报文给客户端。

###### (10-11) Application Data

到这里双方已安全地协商出了**同一份秘钥**，所有的应用层数据都会用这个秘钥加密后再通过 TCP 进行可靠传输。 

###### (12) Alert：warning, close notify

最后由客户端断开连接。断开连接时，发送close_notify报文。上图做了一些省略，在这步之后再发送一种叫做MAC（Message Authentication Code）的报文摘要。MAC能够查知报文是否遭到篡改，从而保护报文的完整性。

###### (*) demand client certificate

Certificate Request 是服务端要求客户端上报证书，这一步是可选的，对于安全性要求高的场景会用到。

###### (*) check server certificate

客户端收到服务端传来的证书后，先从 CA 验证该证书的合法性，验证通过后取出证书中的服务端公钥，再生成一个随机数 **Random3**，再用服务端公钥非对称加密 **Random3** 生成 **PreMaster Key**。

流程图示如下：

<img src="assets/SSL_handshake.png"/>

#### RSA算法

RSA 是一种**公钥密码算法**，简单的走一遍它的加密解密过程。

- **加密算法**：密文 = **(明文^E) mod N**，其中公钥为{E, N}，即”求明文的 E 次方的对 N 的余数“。  

- **解密算法**：明文 = **(密文^D) mod N，**其中秘钥为{D, N}，即”求密文的 D 次方的对 N 的余数“。

例：已知公钥为{5, 323}，私钥为{29, 323}，明文为 300，请写出加密和解密的过程：

**加密**：密文 = 123 ^ 5 mod 323 = 225。

**解密**：明文 = 225 ^ 29 mod 323 = [[(225 ^ 5) mod 323] * [(225 ^ 5) mod 323] * [(225 ^ 5) mod 323] * [(225 ^ 5) mod 323] * [(225 ^ 5) mod 323] * [(225 ^ 4) mod 323]] mod 323 = (4 * 4 * 4 * 4 * 4 * 290) mod 323 = 123。



