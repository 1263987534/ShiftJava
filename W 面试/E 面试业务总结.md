#### Java

##### 1. 数据类型与程序结构

float 存储格式：符号（1 位）+ 指数（8 位）+ 有效数字（23 位）。

**浮点数运算也是不精确的**，==**比较的时候别用 float**==。金融计算用 BigDecimal 类或者采用整型存储最小单位（人民币的分），在需要时转换。

基本数据类型所占字节：**11224488**。

int 类型是 **4 字节**，范围：**(-2 ^ 31, 2 ^ 31 - 1)**，因为有一位是**符号位**。注意一个 Integer 对象是 16 字节，因为包含有 12 字节的对象头信息。

char 用于表示**一个字符**，本质上是一个固定占用**两个字节**的无符号**正整数**。

Java 的参数是以**==值传递==**的形式传入方法中，而**不是**引用传递。对于引用类型，传递的是对象的**==地址值==**。

switch 表达式支持的类型可以是 ==**byte, short, int, char，枚举， String（Java7 之后）**==。支持的都是==**小整数类型**==（String 转为 **hashCode** 也为整数）。不支持 null 与 long。switch 语句如果分支比**较少**，可以直接转换为**跳转指令**。如果分支较多，则会使用**跳转表**（**32 位**），**存储不下** long 型值（64 位 / **8 字节**）。

##### 2. 类的基础与继承

###### 构造方法

**构造方法不能被继承，不能被覆写，不能被直接调用。**但是可以多个构造方法**重载**。构造方法也可以是==**私有**==的，比如用在**单例模式**中。

###### 初始化

**普通初始化块**会在 **==构造方法调用之前==** 执行，**==每次==构造对象**时就会执行。**构造方法**与普通初始化块在每次生成实例对象时**都执行一次**。

**静态初始化块**会在==**类第一次加载**==的时候调用，仅调用**一次**。可对类中的**静态域**进行初始化。

执行顺序：**静态初始化块 -> 初始化块 -> 构造方法**。

存在**继承**的情况下较复杂，**初始化顺序**为（常考）：==**静态优先、父类优先、初始化块优先于构造方法**==。执行顺序为：

- 父类（**静态变量、静态语句块**）
- 子类（**静态变量、静态语句块**）
- 父类（**实例变量、普通语句块**）
- 父类（**构造方法**）
- 子类（**实例变量、普通语句块**）
- 子类（**构造方法**）

静态变量初始化时，首先会**首先声明所有静态变量并赋==默认值==**，然后再**按代码顺序对被初始化**的变量**重新赋值**，这里的赋值可以是直接赋值也可以是静态初始化块内部赋值。**静态变量**的**声明与初始化**是两个不同的操作，静态变量的**声明**在**编译时**已经明确了**内存的位置**。由于静态变量的声明在**编译**时已经**明确**，所以静态变量的声明与初始化在编码顺序上可以**颠倒**。也就是说**可以先**编写初始化的代码，再编写声明代码。

###### 覆写与重载

**覆写**指在类的**继承体系**中，子类实现了一个与父类在**方法签名上完全相同**的一个方法。**元空间有一个方法表保存着每个可以实例化类的方法信息**，JVM 可以通过方法表快速的激活实例方法。如果某个类覆写了父类的某个方法，则方法表中的方法指向引用会指向子类的实现处。覆写时**方法名、参数类型及个数必须严格一致**，为了满足里式替换原则，覆写还有**三个限制条件**，可以总结为：**一大两小两同**。

- **一大**：子类的方法访问权限控制符只能相同或变大。
- **两小**：子类抛出异常和返回值只能相同或变小，能够转型为父类对象。
- **两同**：方法名和参数名必须完全相同。

重载存在于**同一个类**中，指不同方法**方法名称上相同**，但是**参数类型、个数、顺序**至少有一个不同。也就是**方法签名不同**。

**方法签名 = 方法名 + 参数类型**。==**返回类型不是**==方法签名的一部分，所以返回值不同而其它都相同**不算**是重载。

###### 多态

**多态**指的是编译层面无法确定最终调用的方法体，以覆写为基础来实现面向对象特性，在运行期由 JVM 进行动态绑定，调用合适的覆写方法体来执行，**本书认为多态专指覆写**。多态是同一个**行为**具有多个**不同表现形式或形态**的能力。

对于 **private、static 和 final 方法或者构造器**，编译器可以**准确知道**要调用哪个方法，将这种调用方式称为**静态绑定**。

**静态类型**：指出现在**声明**中的类型，静态类型是在**编译**时确定的。所以变量 animal 的静态类型是 **Animal** 。 

**动态类型**：指**运行时**某一时刻变量**指向对象**的类型，动态类型随着运行进程改变。所以 Animal animal = dog 使得变量 animal 的动态类型为 Dog。

**变量决定使用哪个方法名，动态类型决定了可以调用的方法版本。**

**多态实现原理**：JVM 的**方法调用**指令有五个，分别是：

- **invokestatic**：调用静态方法；

- **invokespecial**：调用实例构造器 \<init>方法、私有方法和父类方法；

- **invokevirtual**：调用虚方法；

- **invokeinterface**：调用接口方法，运行时确定具体实现；

- **invokedynamic**：运行时动态解析所引用的方法，然后再执行，用于支持动态类型语言。

其中，invokestatic 和 invokespecial 用于**静态绑定**，invokevirtual 和 invokeinterface 用于**动态绑定**。可以看出，动态绑定主要应用于**虚方法和接口方法**。

##### 3. 接口与抽象类

###### 概述

一个接口中可包含：**常量，普通方法，默认方法，静态方法，私有方法**。

- **Java7 及之前**，它可以看成是一个**完全抽象**的类，也就是说它不能有任何的方法实现。接口里面只能有常量变量和抽象方法，实现类必须实现全部抽象方法。
- **Java8** 接口引入**默认方法**和**静态方法**。默认方法解决修改接口的成本高的问题。
- **Java9** 接口引入 private 方法。可以在接口中编写**私有方法**与私有静态方法。可以解决**多个默认方法之间重复代码**问题。

Java8 之后接口中使用 **default** 修饰**默认方法**，为接口方法提供**默认实现**。Spring 中很多默认实现方法。默认方法是为了解决**接口升级**问题。Java8 之前**修改接口方法成本极高**。Java8 引入**默认方法另一大用处是==函数式数据处理==**的需求，是为了**便于给接口增加新的功能**。**引入默认方法，不仅给接口增加了功能，而且其他实现类不用做任何改变**。

**接口方法冲突**：**接口与超类**之间的冲突(**==超类优先==**)。**接口与接口**之间冲突(需要**覆写方法**来**解决二义性**)。

**接口与抽象类比较**：

==抽象类**不能实例化**==。

- 从**设计层面**上看，**抽象类**提供了一种 **IS-A** 关系，那么就必须满足**里式替换**原则，即子类对象必须能够替换掉所有父类对象。而**接口**更像是一种 **LIKE-A** 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。
- 从**使用层面**上看，一个类可以**实现多个接口**，但是只能**继承一个抽象类**。多数情况下，**==接口优先于抽象类==**。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。从 Java8 开始，**接口也可以有默认的方法实现，使得修改接口的成本也变的很低**。

##### 4. 内部类

分为：普通内部类、静态内部类、匿名内部类、局部内部类。

内部类是一种**编译器**现象，与虚拟机无关。**编译器**将会把内部类翻译成用 **$** (美元符号）分隔外部类名与内部类名的**常规类文件**， 而虚拟机则对此一无所知。每个内部类都会被编译为一个**独立**的类。

**普通内部类**：**普通内部类对象依赖外部类对象**而存在，即在创建一个普通内部类对象时**首先需要创建其外部类对象**。可以把这个内部类理解为外部类的一个**==实例属性==**。**内部类对象**可以访问**外部类对象中所有访问权限的字段**，原理就是外部类知道内部类的**类型信息**，所以外部类可以访问内部类的类型信息；反过来内部类是通过**编译**后**持有外部类对象的引用**才能访问外部类的**非静态**字段。

**静态内部类**：一个类的**静态成员**独立于这个类的**任何一个对象**存在。在有访问权限的地方就可以通过 **类名.静态成员名** 的形式来访问这个静态成员。**静态内部类**也可以理解为一个外部类的**==静态成员==**，**创建一个类的静态内部类对象不需要依赖其外部类对象**。**内部与外部类的静态属性可以互相访问**。

**匿名内部类**：在匿名内部类中可以使用外部类的属性，但是外部类却**不能**使用匿名内部类中定义的属性，因为是**匿名**内部类，因此在外部类中无法获取这个类的类名，也就**无法得到属性信息**。

**局部内部类**：局部内部类的定义只在其特定的**方法体或代码块**中有效，一旦出了这个**定义域**，那么其定义就**失效**了。局部内部类**不仅能够访问包含它们的外部类**， 还**可以访问==局部变量==**。不过那些局部变量**必须**事实上为 ==**final**==。

**原理解析**：**其实==内部类持有外部类的一个引用==，在==内部类构造函数==中会将外部类的引用传递进来**。这个可以通过反编译得到字节码观察出来。**编译器**给内部类提供了一个接受 InnerClassTest 类型对象（即外部类对象）的**构造方法**，内部类本身还定义了一个名为 **this$0** 的 InnerClassTest 类型的**引用**，这个引用在构造方法中指向了参数所对应的外部类对象。所以内部类是持有外部类对象的**引用**的，因此内部类可以使用外部类的 private 属性。

**匿名内部类和局部内部类**都持有外部类对象的引用，所以可以访问外部类非静态字段，然而外部类是**不知道**匿名内部类和局部内部类的**类型信息**的，所以外部类不能访问其字段。

总之，**非静态内部类（普通、匿名、局部）中都会持有对外部类的对象的引用，从而可以访问外部类对象。反过来就要看外部类是否知道内部类的类型信息了。**

##### 5. 枚举类

**enum 类中的每个属性默认就是 ==static final== 的**。所有枚举类都是 **java.lang.Enum** 类的**子类**。enum 类的构造方法是 protected 的，所以普通**枚举类的构造方法**是特殊的存在，**它可以被定义，但是不能加 public 修饰符**，因为它**默认继承了 enum 类的 protected** 修饰符。

从枚举类**反编译**得到的代码可以看到，枚举类编译出来的**属性**都是 **static** 类型的，而 static 类型的属性会在类被加载之后初始化，而 Java 类的**加载和初始化**过程都是**线程安全**的，所以**创建**一个 enum 类型是天生**线程安全**的。

**好处**：可读性、编译时检查、严格单例。

enum 关键字定义的类，其**实例对象**只能在这个 enum 类中**定义好**，它的实例个数是**有限**的，外部是不能创建实例对象的。如果**不自定义**枚举类的**成员变量和构造方法**，只定义枚举**实例**，则枚举实例内容都将以**字符串**的形式存在，在**类加载**的时候虚拟机会通过 ==**protected**== **Enum**(String name, int ordinal) **构造函数**被创建为基本的 Enum **实例**。比如一个星期的枚举类，定义了七天，那么是由**虚拟机**来调用私有构造方法生成七个枚举实例，其他地方无法生成。

**枚举与单例模式**：**由 JVM 从根本上提供保障，绝对防止多次实例化**，是更简洁、高效、安全的实现单例的方式。枚举实现单例可以解决**序列化和反射**破坏单例的问题。**枚举序列化**确实**不会重新创建新实例**，因为编译器在枚举类中禁止了一些用于序列化与反序列化的方法。对于**防反射破坏**的问题：反射中 **Constructor.newInstance 方法**可以生成实例，但是其**源码**中对当前类是否是 ENUM 类做了判断，如果是就直接抛异常。

##### 6. Object类

```java
// 返回当前运行时对象的Class对象
public final native Class<?> getClass();
// 返回对象的哈希码，主要使用在哈希表中，如HashMap
public native int hashCode();
// 比较2个对象的内存地址是否相等
public boolean equals(Object obj);
// 创建并返回当前对象的一份拷贝。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常
protected native Object clone() throws CloneNotSupportedException
// 返回类的名字@实例的哈希码的16进制的字符串，建议Object所有的子类都重写这个方法
public String toString();
// 不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个
public final native void notify();
// 不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程
public final native void notifyAll();
// 不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁。timeout是等待时间
public final native void wait(long timeout) throws InterruptedException
// 多了nanos参数，这个参数表示额外时间，指超时的时间还需要加上nanos毫秒
public final void wait(long timeout, int nanos) throws InterruptedException
// 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
public final void wait() throws InterruptedException
// 实例被垃圾回收器回收的时候触发的操作
protected void finalize() throws Throwable { }
```

###### equals()

用来检查一个对象与调用这个 equals() 的这个对象**是否相等**。Object 类**默认**的 eqauls() 函数进行比较的依据是：调用它的对象和传入的对象的**引用**是否相等，默认进行的是**引用比较**。

**对于引用类型，== 判断两个变量是否引用==同一个==对象，而 equals() 判断两个对象内容是否==等价==。**

**等价的特性**：覆写 equals() 函数的时候要遵守一些**规则**。

- **自反性**：对于任意非空的引用值 x，x.equals(x) 返回值为真。
- **对称性**：对于任意非空的引用值 x 和 y，x.equals(y) 必须和 y.equals(x) 返回**相同**的结果。
- **传递性**：对于任意的非空引用值 x, y 和 z, 如果 x.equals(y) 返回真，y.equals(z) 返回真，那么 x.equals(z) 也必须返回真。
- **一致性**：对于任意非空的引用值 x 和 y，无论调用 x.equals(y) 多少次，都要返回**相同**的结果。在比较的过程中，对象中的数据不能被修改。

**覆写** equals 方法的步骤：

- 检测 this 与 otherObject 是否**引用同一对象**（地址相同）。
- 检测 otherObject **是否为 null**（null 就肯定不是了）。
- 比较 this 与 otherObject 是否属于**同一个类**（类型不同也不是）。
- 将 otherObject **类型转换**为相应的类类型变量。
- 现在开始对**所有需要比较的域依次进行比较**。使用 **==** 比较**基本类型域**，使用 **equals 比较对象域**。这里就需要看对不同类自己的情况写。

```java
// 以下是Employee类的equals方法
public boolean equals(Object otherObject){
     // 检测this与otherObject是否引用同一对象
    if(this == otherObject) return true;   
    // 检测otherObject是否为null
    if(otherObject == null) return false;   
    // 比较this与otherObject是否属于同一种类型
    if(this.getClass() != otherObject.geClass()) return false;
    // 将otherObject转换为相应的类类型变量：类型转换
    Employee other = (Employee) otherObject;    
    // 现在开始对所有需要比较的域进行比较。使用 == 比较基本类型域，使用equals比较对象域。
    return Object.equals(name, other.name) && salary == other.salary && Objects.equals(hireDay, other.hireDay);
}
```

<img src="assets/image-20200626140641201.png" alt="image-20200626140641201" style="zoom:62%;" />

###### hashCode()

hashCode() 返回**散列值**，散列值是由对象导出的一个**整形值**。每个对象都有一个**默认的散列值**，不覆写这个方法就返回对象的**存储地址**。

> 为什么需要同时覆写 equals 方法和 hashCode 方法？

因为两种定义必须**一致**：如果 x.equals(y) 返回 **true**，那么 x.hashCode() 与 y.hashCode() 就必须**相同**。在覆写 **equals**() 方法时应当**总是同时覆写** hashCode() 方法，保证**等价的两个对象散列值**也**相等**。

**因为 HashMap 或 HashSet 就是同时通过这个两个方法来判断对象是否存在的，当键发生哈希冲突时，仅一个方法是不能有效的组织与检索的。**

最方便的就是利用 **Objects 工具类覆写 hashCode** 方法。

```java
// 一个简单的覆写hashCode方法
@Override
public int hashCode() {
    // 传入多个对象到hash()返回hashCode
	return Objects.hash(firstName, lastName);   
}
```

###### wait()

wait 方法会引起**当前线程阻塞**，直到另外一个线程在**对应的锁对象**上调用 notify 或 notifyAll 方法，或达到了方法参数中**指定的时间**，当前线程才会被唤醒。

###### notify()

**唤醒**可能等待**该对象**的**对象锁的其他线程**。由 JVM（与优先级无关）**随机挑选**一个**处于 wait 状态**的线程进行唤醒。

###### finalize()

该方法用于**垃圾回收**。用于对象被回收之前的**自救**（详见 JVM 部分）。

##### 7. 包装类

**缓存池**：为了减少开销，运用了**池化思想**，为这些不可变的对象创造相应的**缓存池**，用于共享数据，是一种==**享元模式**==的思想。由于包装类内部的数据表示是使用 **final** 修饰的所以是**不可变**的，所以缓存的对象可以被**安全的共享**。

Integer 缓存池的大小==默认为 **-128\~127**==。其他的包装类也有缓存池，但是只有 Integer 可以修改缓存池大小，需要配置**虚拟机参数**。

**==valueOf()== 方法**的实现比较简单，就是先判断值是否在**缓存池**中，如果在的话就**直接返回缓存池的内容**。编译器会在**自动装箱**过程调用 **valueOf**() 方法，因此多个值相同且值在缓存池**范围内**的 Integer 实例使用自动装箱来创建，那么就会引用**相同的对象**。

建议包装类都用用 **equals**() 方法比较，不要直接用 == 。

> **new Integer(123)** 与 **Integer.valueOf(123)** 的区别?

- new Integer(123) 每次都会**==新建==一个对象**（用了 new 关键字）。
- Integer.valueOf(123) 会使用**缓存池中的对象**，多次调用会取得**同一个对象**的引用。

##### 8. String类

String 类对象为**==不可变==**字符串。优点是编译器可以共享。String 被声明为 **==final==**，因此它**不可被继承**。在 Java 9 **之后**，String 类的实现改用 **==byte 数组==**存储字符串，同时使用 **coder** 来标识使用了哪种**编码**。**value 数组被声明为 final**，这意味着 value 数组初始化之后就**不能再引用其它数组**。并且 String 内部没有改变 value 数组的方法，因此可以保证 String **不可变**，由于是不可变对象，所以**天生线程安全**。

许多**看似修改** String 的方法，实际上都是通过**创建新的 String 对象**来实现的。

**不可变的好处**：可以换成 hash 值，避免重复计算；可以创建 缓存池；参数安全性；线程安全。

**字符串常量池**（String Pool）保存着所有**字符串字面量**（literal strings），这些字面量在**编译时期**就确定。还可以使用 **String 的 ==intern()==** 方法在运行过程中**将字符串添加到 String Pool** 中。虚拟机为字符串字面量开辟一个**字符串常量池**，类似于**缓存区**，创建**字符串常量**时，首先**查询字符串常量池是否存在该字符串**，如果存在该**字符串**，返回**引用实例**，不存在，**实例化该字符串并放入池**中。

两种创建**字符串对象**的方式：1）采用**字面值**的方式赋值  2）采用 **new** 关键字新建一个**字符串对象**。

**字面量**形式创建会在编译时就**==自动==地将字符串放入 String Pool 中**。

**注意**：**new String()** 方式首先检查 String pool 中有没有这个字符串，如果没有则先在 String pool 中创建一个字符串，然后再在**堆**中创建一个字符串，并返回堆中字符串的引用。如果 String Pool 中已经有了，则仅在堆中创建。所以可能**创建一个对象也可能创建两个对象**。

总结：

- 单独使用 "" 引号创建的字面量字符串和使用只包含常量的字符串连接符如 "aa" + "bb" 创建的字符串都是**常量**，**编译期**就已经确定存储到 String Pool 中。
- 使用 **new String("")** 创建的对象会存储到**堆中**（如果 pool 中没有也会创建），是**运行期**新创建的。
- 使用包含变量的字符串连接如 "aa" + s 创建的对象是**运行期**才创建的，存储到 **堆** 中。
- 运行期调用 String 的 intern() 方法可以向 String Pool 中动态添加字符串。

在 Java7 之前，String Pool 被放在**运行时常量池**中，它属于**永久代**。而在 Java 7，String Pool 被移到**==堆==**中。这是因为永久代的空间**有限**，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。

> **StringBuilder、StringBuffer、String对比**

**可变性** ：String **不可变**（字符数组用 final 修饰），每次操作都是产生**新对象**。StringBuffer 和 StringBuilder 可变，可以多次修改，操作不产生新对象。

**线程安全**：String **不可变**，因此是**线程安全**的；StringBuilder 不是**线程安全**的；StringBuffer 是线程安全的，内部使用 **synchronized** 进行同步，所以**速度慢**。

**基本原则**：如果要操作少量的数据，用 String ；单线程操作大量数据，用 StringBuilder ；多线程操作大量数据，用 StringBuffer。

##### 9. 其他类

BigInteger 用于处理大型数据，可以处理**任意长度**数字序列的数值，BigDecimal 用于**精确计算**（如财务数据）

##### 10. 常用接口

###### 比较器接口

```java
public interface Comparator<T> {
    // 比较方法
    int compare(T first, T second);     
}
```

###### 克隆接口

clone() 是 **protected** 方法，一个类**不显式**去**覆写 clone()**，**其它类**就**不能直接去调用**该类实例的 clone() 方法。

**要克隆必须实现 Cloneable 接口然后再覆写 clone() 方法，并且将 clone 定义为 public 方法，**这样其他类才能调用。否则就会抛出 **CloneNotSupportedException**。clone 方法中可直接调用 Object 类的方法（**由虚拟机实现**的 native 方法）即 **super.clone()**，直接用 clone 方法是实现的**浅克隆**。**深克隆**需要自己去克隆所有的属性。

浅拷贝中 String 等**不可变**的对象即使是浅拷贝也是**安全**的，**基本数据类型**也是。

Effective Java 建议最好不要去使用 clone()，**可以使用==拷贝构造方法==或者==拷贝工厂==来拷贝一个对象**。即自己实现一个用于拷贝原对象的**构造方法**，传入需要拷贝的原对象进行状态拷贝。

**序列化**一个对象时，当一个对象的实例变量引用其它对象，序列化该对象时也会把引用对象进行序列化。所以能**用序列化解决深拷贝问题**。

##### 11. 关键字

###### final

实例域可以包含**基本数据类型**或者**引用类型**，final 修饰后效果不同。

- 对于**基本**类型，final 使==**数值不变**==；声明数据为==**常量**==，可以是编译时常量，也可以是在运行时被初始化后**不能被改变**的常量。
- 对于**引用**类型，final 使==**引用不变**==，构造器初始化之后就不能再修改，也就是这个变量**不能引用其它对象**。相当于该实例域==**没有 setter 方法**==。但是**被引用**对象的**内部数据**是可以修改的。

final 修饰**方法**表示该方法不能被子类**覆写**。final 修饰类时表明该类**不允许**被**继承**。

> **final、finally和finalize区别**

**final**：用于声明**属性、方法和类**，分别表示属性不可变、方法不可覆盖和类不可被继承。

**finally**：用于**搭配 try catch 语句来处理异常情况**。finally 一般情况下是都会执行的（可能也不会执行，参考异常部分），可以用于执行一些关闭资源操作。

**finalize()**：是 **Object** 中的方法。这里涉及到 JVM 如何判定对象是否存活的可达性分析算法，可达性分析算法对 GC Roots 不可达的对象进行标记，如果这个**对象覆写了 finalize 方法**，且在方法将这个对象重新与 GC Roots 关联的话，对象就**不会被回收**，用于对象被回收之前的**自救**（引诱面试官去问 JVM）。

###### strictfp

strictfp，即 **strict float point** (**精确浮点**)。 如果想让**浮点运算更加精确**，而且不会因为不同的硬件平台所执行的结果不一致的话，可以用关键字 strictfp。

###### super与this

- this 引用**当前对象**是实实在在存在的，可以作为**函数参数**，可以作为**返回值**，但 super 只是一个关键字，不能作为参数与返回值，它只是告诉**编译器**访问父类的相关变量与方法。

- super() 和 this() 均需放在构造方法内**第一行**。

- this 和 super **不能同时出现在一个构造函数里面**，因为 this 必然会调用其它的构造函数，其它的构造函数必然也会有 super 语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。

##### 12. 注解

Java 注解是**附加在代码**中的一些**元信息**，用于一些工具在编译、运行时进行解析和使用，起到**说明、配置**的功能。

为什么用注解/场景：生成注释文档，实现替代**配置文件**功能，实现**编译时进行格式检查**。

**元注解**：元注解就是**修饰注解**的注解，通常用在注解的定义上，一般用于指定某个注解**生命周期以及作用目标**等信息。

|     元注解      |                             用途                             |
| :-------------: | :----------------------------------------------------------: |
| @**Retention**  | 定义该注解的**生命周期**。RetentionPolicy.**CLASS**，RetentionPolicy.**RUNTIME**等 |
|   @**Target**   | 定义注解可以用于**什么地方**。ElementType.**FIELD**、ElementType.**METHOD**等 |
| @**Documented** |               注解是否将包含在 **JavaDoc** 中                |
| @**Inherited**  |                  是否允许子类**继承**该注解                  |

Annotation 型定义为 @**interface**, 所有的 Annotation 会自动继承 java.lang.**Annotation** 这一**接口**，并且不能再去继承别的类或是接口。**参数成员**只能用基本类型 byte、short、char、int、long、float、double、boolean 八种**基本数据类型**和**String、Enum、Class、annotations** 等**数据类型**，以及这一些**类型的数组**。

要获取类方法和字段的注解信息，需通过**==反射==**来获取 **Annotation 对象**。

**注解本质**是一个继承了 **Annotation** 接口的**特殊接口**，其具体**实现类**是 Java 运行时生成的**动态代理类**。通过**反射获取注解**时，返回的是 Java **运行时生成的动态代理对象 $Proxy1**。通过代理对象**调用自定义注解（注解就是特殊的接口）**的**方法**，会最终调用 **AnnotationInvocationHandler** 的 **invoke** 方法。该方法会从 **memberValues 这个 Map 中索引出对应的值**。而 memberValues 的来源是 Java **常量池**。

##### 13. 异常体系

###### 基础

<img src="assets/1563604669873.png" alt="1563604669873" style="zoom:77%;" />

Throwable 可以用来表示任何可以作为异常抛出的**类**，分为两种： **Error（错误）**  和 **Exception（异常）**。异常和错误的区别是，**异常是可以被处理的，而错误是没法处理的**。 

**Exception** 是异常，主要分为两种：

- **受查异常** ：程序==**编译阶段**==发生异常，必须要使用 **try…catch**（或者 throws）进行处理否则编译不通过；受查就是**可以检查**到的，与 **IO 操作相关**的很多异常就是这个。比如 ：ClassNotFoundException，NoSuchFieldException，NoSuchMetodException。除了 **RuntimeException** 及其子类以外，都是受查异常。
- **非受查异常** ：程序==**运行时**==错误，例如除 0 会引发 ArithmeticException，此时程序崩溃并且无法恢复。派生于 **Error** 类和 **RuntimeException 类**的异常。程序运行过程中才能发现的异常，所以是**不能检查**的异常。

可能会叫说几个异常类型。

**受查异常**使用 ==**throws**== 关键词**声明**异常。**非受查异常**使用 ==**throw**== 关键词**抛出**异常。

###### try-catch-finally

finally 用于**回收资源**。涉及**资源操作**的都需要执行！！比如文件打开、Redis 或 MySQL 连接等。不管是**否有异常被捕获**， finally 子句中的代码**都被执行**。

**注意**：就算 **try 语句中含有 return 语句，那么 finally 语句依然会执行**。try 代码块中的 **break 或 continue** 语句也可能使控制权进入 finally 代码块。

当 **finally 子句包含 return 语句**时，将会出现一种**意想不到**的结果，假设利用 return 语句从 **try** 语句块中**退出**。**在方法返回前，finally 子句的内容将被执行**。如果 finally 子句中也有一个 return 语句，这个返回值将会==**覆盖**==原始的**返回值**。

如果需要**关闭资源**，最好使用**带资源的 try 语句**，但是这个资源实现了 **AutoCloseable** 接口。

> **finally语句块一定会执行吗？**

不一定。1. **代码没有执行到 try 块中**，后面的 finally 也不会执行。2. 当在 try 块或者 catch 块中**有 System.exit(0);** 3. 一个线程在执行 try 语句块或者 catch 语句块时被打断（interrupted）或者被终止（killed）；4. 断电了。

##### 14. 泛型

**泛型的本质是参数实例化，解决不确定具体对象类型的问题。**泛型只是一种编写代码时的语法检查。使用泛型可以让编译器对**类型进行检查**，避免**插入错误类型**的对象。它提供了**编译期的类型安全**，确保你只能把**正确类型**的对象放入集合中，避免了在运行时出现 **ClassCastException**。

泛型只在**编译阶段**有效而不会进入到运行时阶段。在**编译过程**中，正确**检验泛型结果**后，会将泛型的相关信息**擦除**，并且在对象进入和离开方法的边界处**添加类型检查和类型转换**的方法。

**使用泛型的好处**：**安全性、可读性、代码重用**。安全性是指编译器会帮检测类型错误，使类型安全；可读是指编码的时候直接就知道集合里面是什么类型；代码重用是指泛型合并了同类型的处理代码。

泛型可有泛型**类**、泛型**方法**、泛型**接口**。

泛型方法的返回类型之前是==**类型参数**==，可以对类型参数进行**限定**。如 **\<T extends Comparable>**。

**编译期**进行泛型**类型擦除**会把**类型变量**替换为相应的**限定类型**。泛型的诸多限制多半是由**类型擦除**造成的。

**重要★**：==**\<T>**是**类型参数**，**T 是返回类型**==，类型参数放在**返回值之前**。**\<T extends Comparable>** 也是**类型参数**，限定**传入的类型**。

类型参数上界可以是**类或接口**，此时 **T** 必须**实现**这个接口或者继承这个类。如果有多个类型变量和多个限定类型，限定类型用 **& 分隔**，类型变量用**逗号分隔**。

除了用 \<T> 表示泛型外，还有 **\<?>** 这种形式。**？** 被称为**通配符**。Sub 是 Base 的子类，**不代表 List\<Sub> 和 List\<Base> 有继承关系**。Java 中**集合是==不能协变==**的，也就是说 List\<Base> 不是 List\<Sub> 的父类，这时候就可以用到**通配符**了。

通配符主要有以下三类：

- **无边界的通配符**：就是 ==**\<?>**==, 比如 **List<?>**。无边界的通配符的主要作用就是让**泛型能够接受==未知类型==**的数据。
- **固定上边界**的通配符：使用**固定上边界**的通配符的泛型, 就能够接受**指定类及其子类类型**的数据。要声明使用该类通配符, 采用 ==**<? extends E> **== 的形式，这里的 **E** 就是该泛型的**上边界**。注意：这里虽然用的是 **extends** 关键字, 却不仅限于继承了父类 E 的子类, 也可以代指实现了**接口** E 的**类**。
- **固定下边界**的通配符：使用**固定下边界**的通配符的泛型, 就能够接受**指定类及其父类类型**的数据。要声明使用该类通配符, 采用 ==**<? super E>**== 的形式, 这里的 **E** 就是该泛型的**下边界**。

==**类型擦除**：Java 泛型是通过**类型擦除**实现的==。 **类型擦除**指的是**泛型相关的信息在编译后被擦除的情况**，其过程就是**擦除(erased) 类型变量**, 并**替换**为相应的**限定类型**。**类型参数**给类型擦除指定一个**边界**，类型擦除之后所有的类型参数都用它们的**限定类型替换**，无限定类型的变量用 **Object** 替换。所以泛型信息只存在于代码**编译阶段**。

在泛型类被**类型擦除**的时候，如果类型参数**没有指定上限**，如 \<T> 则会被转译成普通的 **Object** 类型，如果指定了类型参数上限如 \<T extends String> 则类型参数就被**替换成类型上限**。

##### 15. 集合类

###### 概述

**集合框架**主要包括 **Collection** 和 **Map** 两大体系，Collection 存储着对象的**集合**，而 Map 存储着键值对（两个对象）的**映射表**。



![image-20200603150116573](assets/1535785576589.png)

容器：**普通容器、同步容器、并发容器类**。常见的同步容器类，几乎都是直接加 **synchronized** 实现的：

- **Vector**(implements List)
- **Hashtable**(implements Map)
- **Stack**(extends Vector)。
- **Collections.synchronizedXxxx**。

**同步容器**的**单个操作是安全**的，但是**迭代操作不是**。如果在遍历容器时发生了**结构性变化**，就会**抛出异常**。同步容器没有解决这个问题，要避免这个异常，需要在遍历时给整个容器对象加锁。由于加了**锁**，所以**开销**比较大。

> Hashtable与HashMap对比

- **底层数据结构：** 内部都是用**数组存放元素**。JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。
- **线程安全性**： HashMap 是**非**线程安全的，HashTable 内部的方法基本都经过 **synchronized** 修饰所以是线程安全的。
- **效率：** HashTable 加了锁，效率低下。要同时保证**线程安全与效率**的话就使用 **ConcurrentHashMap**。
- **对 Null key 和 Null value 的支持：** HashMap 中，**null 可以作为键**，这样的**键只有一个，**可以有一个或多个键所对应的值为 null。但是 HashTable **不支持键或值**为 null，插入 null 直接抛出 NPE。
- **内部初始容量大小和数组扩容量大小不同：** ① 不指定容量初始值时 Hashtable 默认的初始大小为 **11**，之后每次扩容为原来的 **2n+1**。HashMap 默认的初始化大小为 **16**。之后每次扩容为原来的 **2 倍**。② 创建时如果**给定**了容量初始值，那么 Hashtable 会**直接使用**这个容量值。而 HashMap 会将其扩充为 **2 的幂次方**大小。

###### ArrayList

- **基本结构**：ArrayList 内部使用**动态数组**实现元素存储，同时也实现了 RandomAccess 接口，所以支持**快速随机访问**。并允许插入所有元素，包括 **null**，元素**可重复**。**动态数组**是通过 **transient** 修饰的，默认**不被序列化**（因为动态数组可能**没有存满**），ArrayList 自定义了序列化与反序列化的方法保证只对数组中的**有效元素**进行序列化。

- **增**：每次**添加元素**时通过  **ensureCapacityInternal() 方法** 检查动态元素数组**容量是否足够**。如果初始化时**没有指定**数组大小，那么**第一次**添加元素时**会扩容**，这时候就会**扩容到默认的 10**。如果容量不够时，需要使用 **grow() 方法进行动态扩容**，新容量的大小为 **oldCapacity + (oldCapacity >> 1)**，也就是旧容量的 **1.5 倍**。扩容时会**复制**原来的数组，所以扩容的开销很大，所以一定要根据业务场景**指定初始化容量**防止过多的扩容与复制开销（阿里规范）。

- **删改查**：指定位置的插入与删除元素效率低，因为需要**移动其它**元素。实现了 **RandomAccess** 接口，可实现**快速随机**访问，按照**索引**进行访问的效率很高，效率为 O(1)。按照内容**查找**元素效率**较低**，效率为 O(N)。

- **安全性**：ArrayList 是线程**不安全**的，建议在**单线程**中才使用 ArrayList，**多线程**可以使用 Vector 类、**Collections.synchronizedList**、JUC 的 **CopyOnWriteArrayList** 类等方法解决并发安全问题。

- **迭代删除**：ArrayList 的**迭代器**会返回一个 **内部类 Itr 对象**，**迭代时删除元素**应该使用**迭代器的 remove** 方法而非 ArrayList **本身的 remove** 方法，否则会产生 **Fail Fast** 异常。当然一般使用一次 ArrayList 的 remove 方法是没问题的。使用 ArrayList 的 **iterator**() 方法获取到**迭代器**进行遍历时，会把 ArrayList **当前状态下的 modCount 赋值给 Itr 类的 expectedModCount** 属性，相当于创建迭代器时候对外部的 modCount 记录了一个**版本快照**。如果在迭代过程中使用了 ArrayList 的 **remove**() 或 **add**() 方法，它们会修改外部的 modCount 就会加 1 ，但是迭代器中的 **expectedModeCount** 并没有变化，当我们再使用迭代器的 next() 方法时，它会调用 **checkForComodification**() 方法，通过对比发现现在的 expectedModCount 已经与外部的 modCount **不一致**了，则会抛出ConcurrentModificationException 异常。

    但是**如果使用**内部类 **Itr 迭代器提供的 remove()方法**，它会调用 ArrayList 提供的 remove 方法，同时还有一个操作：**==expectedModCount = modCount==**;，这会修改当前迭代器内部记录的 expectedModCount 的值，所以就不会存在版本不一致问题，也就不会抛出异常。

- **modCount** 属性是继承自 **AbstractList** 的，用来记录 **结构发生变化的次数**。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。如果迭代或者序列化会检查 modCount 版本，如果不一致则会产生 **Fail Fast 异常**。

- **序列化**：基于**数组**实现，并且具有**动态扩容**特性，因此保存元素的数组**不一定都会被使用**，那么**就没必要全部**进行序列化。所以保存元素的数组 **elementData** 使用 **transient** 修饰，该关键字声明数组默认**不会被序列化**。ArrayList 实现了 **writeObject**() 和 **readObject**() 来控制==**只序列化数组中有元素填充那部分**==内容。注意：序列化时也会**检查 modCount**，如果序列化时并发**修改**列表，可能造成 Fail Fast 而抛异常。

###### LinkedList

###### ArrayDeque

###### PriorityQueue

###### HashMap与HashSet

###### LinkedHashMap

###### TreeMap

###### WeakHashMap

###### CopyOnWriteArrayList

###### ConcurrentHashMap

###### BlockingQueue

##### 16. 并发

###### 多线程基础

###### JMM与Volatile

###### JUC与AQS

###### 锁与互斥同步

###### 线程安全总结

###### JUC组件与线程协作

###### Atomic与Unsafe与CAS

###### 线程池与定时任务

###### ThreadLocal

##### 17. IO

##### 18. 动态与函数式编程

###### 反射

###### 代理

##### 19.面试问题

###### 基础

- sychronized 锁状态转换
- 几种GC算法，**内存碎片如何解决**
- synchronized锁升级机制
- 说一下CountDownLatch和CyclicBarrier
- hashcode 方法的底层实现
- hashmap中如何计算下标
- 内存泄漏问题，什么情况会引发（答了各种流未关闭，以及threadlocal中的key）
- 多态及多态实现原理
- 在java里面，final，finally，finalize它们三个有什么区别
- 举几个你用过的exception的例子
- java中，在hashmap中放入100个元素，如果希望不发生扩容，那么一开始声明的hashmap应该多大呢？

###### 集合

- HashMap的put()流程，扩容
- 讲一讲concurrentHashMap，如果下标空是怎么操作的。concurrenthashmap加锁和扩容机制
- aqs原理

###### 并发

- 说一下CAS 以及应用，CAS有什么问题，CAS存在的问题（ABA问题，其他的？）
- CAS为什么是原子性的。底层CAS怎么实现的
- 两个线程读，一个线程写，如何实现，不用锁可以吗
- wait()和sleep()的区别
- callable和runnable有什么本质区别
- 停止一个正在运行的线程
- interrupted与isInterrupted方法的区别。
- 介绍一下ThreadLoacl的实现原理，如果ThreadLoaclMap的Key有null的情况呢？
- ThreadLocal 原理，线程池中使用 ThreadLocal 会有什么问题，为什么？

###### 线程池

- 项目中如何使用线程池
- 线程池参数
- 线程池添加任务的过程
- 拒绝策略？默认拒绝策略？有没有自定义过拒绝策略？

###### JVM

- Class类文件怎么回收
- xms xmx分别代表什么
- GC ROOTS具体是怎么遍历的？GC Root有哪些。
- CMS和G1的优缺点，G1能百分百保证在指定时间内完成回收吗
- 类加载机制，双亲委派模型、findClass 和 loadClass。
- Class.forName与ClassLoader的区别。
- final/static关键字的对象存放在内存什么位置。

###### 其他

- 序列化底层实现



#### 数据结构与算法



##### 面试问题

- 快排时间复杂度。为什么会退化？单次partition的时间复杂度。怎么让它不退化（随机打乱）。
    排序算法的稳定性是什么意思。快速排序讲一哈，时间复杂度，怎么使得快排避免O(n2)复杂度。时间复杂度，怎么计算的，为什么是O(nlogn)
- 可能存在比nlogn还低的，基于交换的排序算法吗？
- 压缩算法：1万个数在文件中，范围在 1- 65536 之间，如何压缩。



#### 网络

##### 1. 基础

###### TCP/UDP

- tcp、udp区别，tcp可靠连接用什么保证，三次握手、四次挥手各个状态名称，TIME_WAIT为什么是2MSL，如何解决TIME_WAIT状态过多。什么时候出现TIME_WAIT，谁出现，大量time_wait会怎么样。2msl原因  1msl行不行。
- 四次挥手最后等待为什么2MSL
- TIME_WAIT和CLOSE_WAIT的区别
- close_wait太多怎么检测和解决
- SYN Flood是什么？有什么解决办法？
- TCP的长连接与短连接
- 有什么基于UDP的可靠连接协议，如何使用udp实现可靠传输(3)
- 拥塞控制
- TCP 连接底层用了哪些 系统调用？ 如果服务端与客户端同时调用 close() 会发生什么？
- TCP 如何保证可靠传输(2)
- TCP粘包？为什么会发生TCP粘包 https://www.cnblogs.com/kex1n/p/6502002.html
- 一个数据包，从发出到接收经历了什么
- UDP和TCP的区别（N）
- UDP有哪些协议
- 如果服务端的**机器**挂了，而客户端去连接会发生什么？如果是服务端的**进程**挂了，客户端去连接会发生什么？
- tcp三次握手第三个包丢了会怎么样
- 客户端挂了以后，服务器怎么办，tcp连接会不会断开（问吐了）
- UDP协议为什么能实现广播
- 如果发报文段1 2 3 4 5，收到2 1 4 5，收到每个报文段时返回的是什么
- TCP的keep alive字段。HTTP的keep alive字段
- tcp慢启动

###### DNS

- DNS解析过程（访问流程），DNS劫持了解吗（如何防御？HTTPS？），DNS用的协议。

###### ARP

- ARP详细说说
- ARP，如果要查找的MAC地址不在同一个网段怎么办
- arp欺骗是什么？如何避免？
- ARP协议，怎么工作的、属于哪一层，为什么属于数据链路层，数据链路层会认识ip地址吗

###### 其他

- 浏览器输入url发生了什么？（细说，包括每一层涉及到的协议）(3)
- RIP协议怎么解决的环路问题
- 公网ip和内网ip怎么转换
- 应用层有什么协议。HTTP，SMTP，DNS
- ICMP了解吗？是做什么的？ping的具体过程？ICMP作用
- ISO分层
- 路由器和交换机的区别

##### 2. HTTP

- http2.0
- http code
- get和post的区别？
- SSL握手过程，然后问我第一次握手是什么加密，第二次握手怎么加密
- http1.0和1.1和2.0有什么区别
- https怎么实现负载均衡的？有哪些负载均衡的算法？
- https与http的区别，详细讲述一下SSL
- PUT和POST的区别
- get能把参数放body吗，post能把参数放在url里面吗。post不用request body可以吗
- 状态码301 302 502 504。http响应码，问了502
- HTTP里面可以放哪些数据？
- **跨域了解吗？知道是什么原理吗？**cookie支持跨域吗？
- 项目HTTPS的握手过程，能被中间人劫持吗？
- cookie session讲一下(N)
- https是对请求头还是请求体加密？
- 除了get和post，还用到别的方法了吗？
- .content-length一定有吗？如果数据特别长，一次都能读取吗？那length表示的是每次读取的长度还是总长度？
- 长连接是干啥用的？举个场景说。长连接的连接数有限制吗？
- .cookie可以包括哪些类型的数据？cookie里面保存了什么数据。
- 用户禁用cookie之后怎么保持有状态连接。
- get和post的区别，post一定会发两个包嘛？
- http2.0和http1.0区别，http2.0可以**推送弹幕消息**吗
- HTTP是怎么找到TCP的
- 服务器如何处理**大文件**传输



#### 操作系统

##### 1. 基础

- 单个进程分配最大内存多少 (2) 32位的计算机为 4G？
- IO 多路复用，讲下select、poll、epoll，边沿触发，水平触发。
- 用户态、内核态
- 两个进程怎么共享一个物理内存页
- 有操作过共享内存吗
- 什么是僵尸进程(3)僵尸进程和孤儿进程。僵尸进程太多了有什么危害
- 32 位，4G 的内存，内存布局，操作系统内存模型？
- 虚拟内存
- 进程栈与线程栈的区别
- 进程、线程、协程区别，有么有用过协程？管程是啥？
- 进程切换怎么切换
- 进程的通信方式(N)，以及对应的应用场景。进程间通信方式及其优缺点
- 父子进程了解吗，如何创建一个子进程？
- 线程能访问虚拟内存的哪些空间
- 线程间通信？
- 虚拟地址和物理地址怎么换算
- 操作系统中的 fork？
- 为什么要IO多路复用
- epoll触发问题，边沿触发，水平触发
- 介绍下虚拟内存和物理内存，如何映射的呢
- CPU中断
- 死锁产生条件
- 栈和堆的区别
- 比较分页与分段
- 操作系统中内存管理用到的数据结构有哪些
- 进程间通信中的共享内存通信，怎么保证安全


##### 2. Linux

- linux进程怎么实现类似一个进程底下多线程的资源共享
- Linux中的流控工具 Traffic Control 的原理
- Linux如何查看内存情况
- Linux命令 给文件改名 查文件 查文件内容 查暴露端口
- 什么是软硬链接
- 线程cpu占用率过高，如何查询
- linux的对象池、内存、写时拷贝
- linux系统 如果有个进程在写数据，另一个进程用remove会怎么样
- Linux内存布局
- linux top命令 具体CPU负载是怎么计算出来的 （不会）
- 怎么查看端口 netstate
- 提供一个日志文件，里面是用户的访问记录，用shell命令做一些统计工作



#### 数据库

##### 1. 基础

- **数据库范式讲一下**
- ACID
- MySQL 慢查询
- Binlog 是什么，Redo log 和 Undo log 在事务中表现了怎样的角色。mysql redo 日志 undo 日志 二进制日志讲讲。
- 介绍一下 binlog。
- 说一下 高并发情况下 mysql 中 update good set count = count + 1 where id = 1  会发生什么，为什么会这样？
- 说一下 mysql的for update
- 说一下MySQL可重复读的隔离级别下如何保证不幻读
- InnoDB、Myisam区别
- 可重复读的实现(mvcc，锁等等)、
- MySQL的锁，间隙锁，乐观锁，悲观锁怎么实现
- 索引有哪些，数据结构是什么，区别是什么
- inner join、left join、right join的区别？连接分为内连接与外连接，**内连接仅选出两张表中互相匹配的数据，而外连接会选出其他不匹配的记录。**（参考网易的书）
- Mysql回表
- mysql的undolog和redulog的意义。
- MVCC
- 复合索引的数据结构是怎么存储的
- 分布式数据库 二阶段提交
- 数据库的索引是什么，索引为什么提高查找速度，什么时候用索引，什么时候不用
- MySQL默认隔离级别是什么，可重复读是如何避免幻读现象的？gap lock、next-key locks是属于哪种锁？
- 讲一讲gap lock和next-key lock，具体是怎么锁的，比如age=20,锁的是id还是age
- MVCC
- 聚簇索引和非聚簇索引区别，sql 语句执行有哪些步骤？
- MySQL 索引使用的注意事项
- DDL、DML、DCL分别指什么
- explain命令
- left join，right join，inner join
- 数据库事物ACID（原子性、一致性、隔离性、持久性）
- 事物的隔离级别（读未提交、读以提交、可重复读、可序列化读）
- 脏读、幻读、不可重复读
- 数据库的几大范式
- 数据库常见的命令
- 说说分库与分表设计
- 分库与分表带来的分布式困境与应对之策（如何解决分布式下的分库分表，全局表？）
- 说说 SQL 优化之道
- MySQL遇到的死锁问题、如何排查与解决
- 存储引擎的 InnoDB与MyISAM区别，优缺点，使用场景
- 索引类别（B+树索引、全文索引、哈希索引）、索引的原理
- 什么是自适应哈希索引（AHI）
- 为什么要用 B+tree作为MySQL索引的数据结构
- 聚集索引与非聚集索引的区别
- 遇到过索引失效的情况没，什么时候可能会出现，如何解决
- limit 20000 加载很慢怎么解决
- 如何选择合适的分布式主键方案
- 选择合适的数据存储方案
- 常见的几种分布式ID的设计方案
- 常见的数据库优化方案，在你的项目中数据库如何进行优化的
- **for update** 的一个SQL是否会触发间隙锁？（猿辅导）
- 覆盖索引
- 索引什么时候失效
- Explain
- MVCC
- 死锁
- 查询优化
- 主从复制
- 读写分离

---

##### 2. 场景设计

- 多线程事务回滚：开启1万个线程，每个线程往mysql中写入1千条数据，共1千万条数据，如何保证这一千万条数据要么都插入成功，要么都插入失败。即当其中一条线程出现异常，或者处理结果为非预期结果，则全部线程均回滚。
- 微博如何设计表，考虑：用户，博文，评论，点赞。
- 场景：火车买票，多区间，设计表。
- 场景：抖音 关注 粉丝 设计表。

##### 3. 撸SQL

> **查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩**

**写法1**：先从成绩表分组过滤平均成绩大于 60 的学生 id 和成绩。再和学生表连接，获取学生姓名。

```mysql
select student.s_id, student.s_name, a.avg from student
inner join (
    select s_id, avg(s_score) from score 
    group by s_id having avg(s_score)>=60
) AS a 
on student.id=a.s_id
```

**写法2**：直接连接两表。

```mysql
select a.s_id, a.s_name, avg(b.s_score) as avg_score
    from student a join score b
    on a.s_id = b.s_id
    group by 
    a.s_id
    a.s_name
    having
    avg_score >= 60;
```

----

> **统计全校重名最多的十个名字**

```mysql
SELECT sname, count(distinct sno) as times
from student
group by sname
order by times desc
limit 10;
```

---

- sql-统计不同分数段人数
- 学生表，求学生的总成绩并按成绩降序。
- 公司表与员工工资表，求平均工资大于5000的公司
- sql查询一个月内数据的前5 的id
- 手写sql 找某个列最大的那条记录
- 写一个简单的去重复的sql语句
- 手撕数据库sql语句：老师表、学生表和老师学生对应表，查询学生最多的老师。



#### Redis

- 跳表。介绍一下、画一下基本结构，搜索插入数据过程，**时间复杂度**。问到为什么用跳表而不是红黑树？跳表怎么实现代码描述？查询和插入复杂度
- Redis还有什么高级数据结构？
- Redis了解哪些（我把底层的SDS，渐进式hash，压缩表，raft算法，gossip协议疯狂输出）
- 持久化方式 RDB 和 AOF，然后说了一堆指令，相关的指令。
- 你用redis怎么避免缓存穿透
- redlock
- Redis内存淘汰机制
- redis的五种对象数据结构，底层编码
- Redis分布式锁是怎么实现的。如果多个线程同时要setnx，redis会怎么做
- redis怎么实现事务
- Redis 有哪些数据类型，可参考《[Redis常见的5种不同的数据类型详解](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247483987&idx=1&sn=5c5e4cd5bc73a7e6f84e5d6adfab0935&chksm=e9c5fbe2deb272f4b5b75bd2ac92bb27950452623ec83c0e1add7e30c773160421fab1571680&scene=21#wechat_redirect)》
- Redis 内部结构
- Redis 使用场景
- Redis 持久化机制，可参考《[使用快照和AOF将Redis数据持久化到硬盘中](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247483992&idx=1&sn=8f554bc490c4db1a78a30144f873e911&chksm=e9c5fbe9deb272fff47483c241e6d2a7aae99dc8f6fe9fee31f2dd214d0cf81b33d51f7a7dbe&scene=21#wechat_redirect)》
- Redis 集群方案与实现
- Redis 为什么是单线程的？
- 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级
- 使用缓存的合理性问题
- Redis常见的回收策略，数据淘汰策略。
- redis限流如何做的
- Redis是单线程的，如何提高多核CPU的利用率？**一个机器通过不同端口开多个实例**。
- 如何Redis并发竞争key问题。
- 数据分片模型
- 哈希槽
- **缓存与数据库双写一致性**



#### Spring

- Spring MVC工作流程
- 常用注解说一下
- Spring里面的设计模式
- @Autowired注解原理
- Servlet的生命周期
- 转发与重定向的区别
- BeanFactory 和 ApplicationContext 有什么区别
- Spring Bean 的生命周期
- Spring IOC 如何实现
- Spring中Bean的作用域，默认的是哪一个
- 说说 Spring AOP、Spring AOP 实现原理
- 动态代理（CGLib 与 JDK）、优缺点、性能对比、如何选择
- Spring 事务实现方式、事务的传播机制、默认的事务类别
- Spring 事务底层原理
- Spring事务失效（事务嵌套），JDK动态代理给Spring事务埋下的坑，可参考《[JDK动态代理给Spring事务埋下的坑！](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247484940&idx=1&sn=0a0a7198e96f57d610d3421b19573002&chksm=e9c5ffbddeb276ab64ff3b3efde003193902c69acda797fdc04124f6c2a786255d58817b5a5c&scene=21#wechat_redirect)》
- 如何自定义注解实现功能
- Spring MVC 运行流程
- Spring MVC 启动流程
- Spring 的单例实现原理
- Spring 框架中用到了哪些设计模式
- Spring 其他产品（Srping Boot、Spring Cloud、Spring Secuirity、Spring Data、Spring AMQP 等）
- 有没有用到Spring Boot，Spring Boot的认识、原理
- MyBatis的原理



#### MQ

- mq消息可靠性 重复消费
- mq怎么实现延迟队列
- mq基本组件
- Kafka发送消息的三种方式
- 消息队列怎样解决消息的重复消费和漏消费
- Kafka、RabbitMQ、RocketMQ的优缺点，怎么选择？
- 项目 消息加入异步队列超时或者失败，你是怎么处理的。
- 消息队列的使用场景
- 消息的重发补偿解决思路
- 消息的幂等性解决思路
- 消息的堆积解决思路
- 自己如何实现消息队列
- 如何保证消息的有序性
- 服务端消息堆积，如何解救？说了消息队列，分发处理，还有其他方法么？如果堆积了，可以将消息丢弃么？不会，说了看情况，如果不重要的，可以丢弃。
- 问了一下kafka的一些机制。通过kafka消息队列异步落数据库时，如何保证数据可靠地落到数据库里。
- 为什么kafka的一个partition里面的消息，一个consumer group里面只有一个消费者能消费，而不能两个消费者同时并行地消费。
- 如果一个消费者拉走了一条消息，但是还没消费就挂了，kafka如何保证这条消息能够被消费而不导致消息丢失。
- 消息队列如何保证不丢，你们是怎么做的
- 多少个消费者？多少个partition？



#### ZK

- zookeeper中的节点类型，服务端宕机后zk发生的变化



#### Netty

- 为什么选择 Netty
- 说说业务中，Netty 的使用场景
- 原生的 NIO 在 JDK 1.7 版本存在 epoll bug
- 什么是TCP 粘包/拆包
- TCP粘包/拆包的解决办法
- Netty 线程模型
- 说说 Netty 的零拷贝
- Netty 内部执行流程
- Netty 重连实现
- **Netty内存共享**

#### 分布式

- 谈谈业务中使用分布式的场景
- Session 分布式方案
- Session 分布式处理
- 分布式锁的应用场景、分布式锁的产生原因、基本概念
- 分布是锁的常见解决方案
- 分布式事务的常见解决方案
- 集群与负载均衡的算法与实现
- 说说分库与分表设计，可参考《[数据库分库分表策略的具体实现方案](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247483931&idx=1&sn=6eda41aa81c1243422a603205d2fad22&chksm=e9c5fbaadeb272bc92537803c14a6f55e1170b1a3b8f60160f66417800c0ace960dfe192717a&scene=21#wechat_redirect)》
- 分库与分表带来的分布式困境与应对之策
- Paxos协议
- Raft协议
- ZAB协议
- 基于Zookeeper的分布式锁
- 



#### 设计模式

- 说一个你最熟悉的设计模式
- 原则有哪些
- 



#### 项目问题

- 项目最牛逼的代码是什么？

- 如何提升项目性能。

- 数据库查询优化怎么做的

- 项目里面用了哪些Redis的数据结构？

- 项目里出现过oom吗，怎么排查

- 项目里用过多线程相关吗

- 项目是如何保证缓存和数据源的数据一致性的？

- 框架中什么地方用到了反射？

- 项目中用了什么设计模式？

- GC调优经历？

- 项目架构？

- 项目有没有自定义过注解？**有用过注解吗**？

    用过啊，先说几个**常见**的注解。比如 @Override，以及 @Deprecated，还有注释注解。

    然后说一下使用了**自定义注解**。比如定义了一个用于**统计方法执行时间**的注解。只有标注了这个注解的方法才统计执行时间（用在执行时间可能很长的方法上）。

- 



#### 智力题

---

> **一硬币，一面向上概率0.7，一面0.3，如何公平？**

**抛两次，正反 A 胜，反正 B 胜。**

----

> **概率题：两个人轮流抛硬币，先抛到正面的赢，问先抛的人赢的概率**

**2/3**：每一轮抛硬币，**A 先抛赢得概率是1/2**，B 后抛赢得概率是**（1/2）*（1/2）= 1/4**。那么每一轮 A 赢得概率都是 B 赢得概率的 2 倍，总概率为 1，所以 **A 赢的概率是 2/3**。

---

> **连续抛掷硬币，直到最近三次硬币抛掷结果是“正反反”或者“反反正”。如果是前者A获胜；如果是后者B获胜。这个游戏公平吗？**

A和B获胜的概率比？
什么情况B就跟A公平了？
什么情况B的获胜概率比较大？

----

> **两根香，一根烧完 1 小时，如何测量 15 分钟**

开始时**一根香两头点着**，一根香只点一头，**两头点着的香烧完说明过去了半小时**，这时将只点了一头的香另一头也点着，从这时开始到烧完就是 15 分钟。

---

> **64 匹马，8 个跑道，选跑最快的 4 匹马需要比赛多少次。**

如果**可以计时**的话，只需要 8 场就行了。

不能计时：锦标赛排序算法，需要次数：8 + 1 + 1 + 1 = **11**。

**第一步**：首先每 8 匹马跑一次，总共**需要 8 次**，假设结果中 A1>A2>A3>......,B1>B2>B3>....等，这 8 组的第一名不一定就是前 8 名。这里可以淘汰掉每组的后四名，每组后 4 名一定进不了前四。这里需要**八场比赛**。

<img src="assets/image-20200811134851798.png" alt="image-20200811134851798" style="zoom:60%;" />

**第二步**：这 8 组中的**第一名拉出来跑一次**，那么**这次最快的一定是总的第一名**，假设是 A1，同时**假设 B1>C1>D1**。这时还要**角逐 2, 3, 4 名**，那这一轮中的**第五名到第八名都可以直接舍弃**，因为这几组**所有的马**一定进不了前 4 名。这里需要 **1 场比赛**。

<img src="assets/image-20200811134946942.png" alt="image-20200811134946942" style="zoom:60%;" />

这个时候总冠军已经诞生，它就是 A1，蓝色区域的已经全部淘汰，而其他可能跑得最快的三匹马只可能是下图中的黄色区域了（**A2, A3, A4, B1, B2, B3, C1, C2, D1**，共 9 匹马）

<img src="assets/image-20200811140618275.png" alt="image-20200811140618275" style="zoom:60%;" />

**第三步**：只要从上面的 9 匹马中找出跑得**最快的三匹马**就可以了，但是现在只要 8 个跑道，**怎么办**？那就**随机选出 8 匹马**进行一次比赛，这里需要**比赛一场**。

**第四步**：上面比赛完，选出了**前三名**，但是 9 匹马中**还有一匹马**没跑，它可能是一个潜力股啊，那就和**前三名比一比**，这**四匹马比一场，选出前三名**。最后加上总冠军，就是最快的四匹马，这里需要**一场比赛**。

所以**总共 11 场**比赛。但是如果第 10 轮选择 A4 不上场，如果 A3 获得了第 4 名，那么 A4 就不需要比赛了，这样总共就是 10 场。

但是这里可能会问最少的次数，最少的话应该 9 次就行了，前面 8 次必须的，第 9 次则刚好遇到。

变化题：25 匹马，5 个赛道，最少比几次能找出最快的 3 匹马。

---

> **坐标系中有一个球桌，四个角坐标：(0,0), (0,4), (2,4), (2,0)，一颗球在(1,1)，请问从哪些角度可以射入洞内（可无限次碰撞）？**

一般想法是将球镜像对称，但这道题是把**洞镜像对称**。**将这个桌面在这个平面无限延展，可类比成无限张球桌紧密放置**。**那么每一个和球洞的连线都是合法路径**。

---

> **54 张扑克牌，平均分成 3 份，大小王在同一份的概率**

首先**大王**一定会在某一份中，然后要计算**这一份中还要包含小王的概率**。去掉大王还剩 53 张牌，这一份还可以分 17 张牌，那么**每次分到小王的概率是 1/53**，所以**总概率是17/53**。

<img src="assets/image-20200810164840311.png" alt="image-20200810164840311" style="zoom:50%;" />

---

> **有 n 个苹果，两个人去取，每次只能取一个或两个，取到最后一个就输，请问有没有必胜的方法，你应该先取还是后取？**

用 n 对 3 进行取模，如果取模的结果是 0 或者 2，就先取，如果结果是 1，就后取，这样可以立于不败之地。

---

> **12个球 一个不一样，轻或重，秤几次可以找到**

---

> **有n个点，都落在圆周上，问所有点都落在直径一侧的概率是多少**

---

> **一个路口观察十分钟有车经过的概率是99%，那么五分钟能观察到有车经过的概率是多少。**

---

#### 场景及系统设计题

---

如何测试你的代码？

测试各种边界。正反例都需要测试。还需要测时间空间复杂度。

---

如果你的用户反应页面刷不出来你会如何排查。

----

服务器内存泄漏，怎么排查问题？具体使用这些工具按什么规则排查。

---

如果一台机子访问量高，都是tcp短连接，可能会有什么问题？（不太懂）

---

**让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。**

传入参数有总钱数，分的份数，随机分还是等分。先判断钱数能不能分那么多份，这个直接用总钱数>=0.01份数判断就可以了。然后根据分发策略，选择随机还是等分，随机的话就给 1到总钱数-（总份数-1）0.01 的随机数（总钱数以分为单位），等分的话直接除判断能不能除开，有余数就将余数加到最后一份里面。

发红包的算法：

二倍均值法：假设**剩余**红包金额为 m 元，**剩余人数为 n**，那么有如下公式：

**每次抢到的金额 = 随机区间 [0.01，m / n × 2 - 0.01]元**。

---

**需求：谁关注了我，我关注了谁，谁与我互相关注。表该如何设计，索引怎么建。查询语句怎么写**

**粉丝关注表使用四列**，主键 id，userId，fansId，是否互相关注。**用两行数据来保存互相的关注关系**，这样查询起来更方便，用空间换时间。

主键有主键索引，剩下的字段不适合建索引，因为字段重复太多。

---

**分布式多个机器生成id，如何保证不重复?**

**snowflake方案**、**用Redis生成ID**

----

**数据库连接池怎么设计?**

需要考虑的问题：      

1. 限制连接池中最多、可以容纳的连接数目，避免过度消耗系统资源。               
2. 当客户请求连接，而连接池中所有连接都已被占用时，该如何处理呢？一种方式是让客户一直等待，直到有空闲连接，另一种方式是为客户分配一个新的临时连接。               
3. 当客户不再使用连接，需要把连接重新放回连接池。               
4. 连接池中允许处于空闲状态的连接的最大项目。假定允许的最长空闲时间为十分钟，并且允许空闲状态的连接最大数目为5，              

那么当连接池中有n个(n>5)连接处于空闲状态的时间超过十分钟时，**就应该把n-5个连接关闭，并且从连接池中删除，**这样才能更有效的利用系统资源。

----

**扫码登录是如何实现的？**

---

**1亿个正整数,范围是0-42亿。求出现次数是2的数字，空间复杂度**

用位图bitMap。位图是以bit位为单位进行数据存储，这样每个字节8个位就可以存储8个数字，普通的一个int占4个字节，32位，用了位图之后可以将空间节省32倍。      

开一个42亿大小的位图，将这一亿个数字存进数字大小对应的位置，一个bit每存进去一个数字，就将value+1,比如第一次存8，就将索引为8的位置的value置为1，第二次就置为2，存完之后搜索value为2的key是多少。      

32位机器最大能表示的数字是42亿9千多万。      

42亿bit /(8 * 1024 * 1024) = 500MB。

----

**算法：有一个IP地址库，假设有几十万条ip，如何判断某个ip地址是否在这个库中？**

**思路一**：分治法，将ip地址根据前三位分成256份，然后看这个ip地址对应的网段，只比对这个网段里面是否有这个ip，当然还可以继续分下去，根据数据量来决定分成多少份。      

**思路二**：位图，将每一条ip对应位图中的一个位，2^32次方(42亿多)个数据只需要512M空间。可以实现O(1)的时间搜索，O(n)的时间存储。

----

**场景题：2g内存，要求一个10g文件的中位数**

http://blog.sina.com.cn/s/blog_8e9c63c70101f5pl.html

----

**情景题，一个5T的文件，里面全是id，1-10^9 ，如何计算不同id的个数？**

哈希到不同的文件，再逐个文件内找不同的。

----

**场景题：Redis设置高并发抢单一的东西，如何避免高并发对一个键进行访问？**

----

**场景设计：系统中有几万个任务需要在各自的特定时刻触发执行，怎么做？**

----

**场景题：游戏里，一个玩家可能吃到很多种debuff，每个debuff有一定持续时间。给你一个定时器，怎么设计数据结构，来维护玩家的debuff状态？**

----

**一个很复杂的场景，大概是微博用户有个关注列表，以及知道各种大V的动态，设计数据结构啥的，到最后在用户这边显示一个更新微博列表这样。最后扯了一堆围绕红黑树的实现**

----

千万数据查一个id的出现次数 要求时间空间复杂度尽量优化

---

如何实现微信的“消息撤回”

“消息撤回”为什么要给定时间限制

如何实现一个类似朋友圈的功能

----

两个用户同时支付订单，如何不重复支付

两个用户同时登录，如何把另外一个用户挤下线；

---

设计一个短网址系统

----

如何防止表单重复提交

---

如何设计一个生成唯一UUID的算法？

---

扫描二维码登录的过程解析；

---

实现一个负载均衡的算法，服务器资源分配为70%、20%、10%；

#### HR面

- 兴趣爱好
- 最大的优点与缺点。缺点，**容易紧张**。
- 项目分工
- 项目中最大的困难，如何解决的
- 有哪些offer？已经投了哪些公司？
- 为什么转专业？（机械就做自动化相关的，研究生做物联网）
- 项目角色。
- 项目中所遇到的挑战，难点。
- 职业规划
- 做过最有成就感的事情。
- 遇到过的最大困难。转专业学习难度较大。
- 说说你的优缺点、亮点
- 说说你最近在看什么书、什么博客、在研究什么新技术、再看那些开源项目的源代码。
- 说说你觉得最有意义的技术书籍
- 工作之余做什么事情、平时是如何学习的，怎样提升自己的能力
- 说说个人发展方向方面的思考
- 说说你认为的服务端开发工程师应该具备哪些能力
- 说说你认为的架构师是什么样的，架构师主要做什么
- 如何看待加班的问题
- 平时如何学习的（先应用、再原理和源码；看书、视频、专栏、源码）
- 最大的挫折，最大的成就。

---

> 为什么想加入我们公司？

- 前期体验：公司体量较大，是一个较好的发展平台，发展空间很大。公司良好的企业文化和氛围，公司的品牌和影响力。
- 面试体验：面试的时候体验极佳，感觉团队氛围很好。
- 顺丰：生活中就有体会，从寄快递到收快递就能感受出来。让人非常安心。

---

#### 反问问题

- 是否可以提前实习？
- 对新人是如何培养的？
- 如果通过，是否有人指引，提前学习一些东西？