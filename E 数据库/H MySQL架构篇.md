[TOC]

### MySQL架构篇

#### 分区与切分

##### 1. 垂直切分

**垂直切分**是将一张表**按列切分**成多个表，通常是按照列的**关系密集程度**进行切分，也可以利用垂直切分将**经常被使用的列**和不**经常被使用的列**切分到不同的表中。

在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。

如果一个表中某个字段的**内容长度过长**，通常需要单独切分出去，比如 TEXT 类型的字段，可以考虑单独切分。

<img src="../../JavaNotes/E 数据库/assets/1563519660804.png" alt="1563519660804" style="zoom:80%;" />

- **垂直拆分的优点：** 可以使得列数据变小，在查询时减少读取的 Block 数，减少 I/O 次数。此外，垂直分区可以简化表的结构，易于维护。
- **垂直拆分的缺点：** **主键会出现冗余**，需要管理冗余列，并会引起 **Join 操作**，可以通过在**应用层进行 Join** 来解决。此外，垂直分区会让事务变得更加复杂。



##### 2. 水平切分Sharding

**水平切分**又称为 **Sharding**，它是将**同一个表**中的记录拆分到**多个结构相同的表**中。

当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到**集群**的不同节点上，从而缓解**单个数据库**的压力。

<img src="../../JavaNotes/E 数据库/assets/1563519648151.png" alt="1563519648151" style="zoom:80%;" />

《Java工程师修炼之道》的作者推荐 **尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度** ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择**客户端分片**架构，这样可以减少一次和中间件的网络 I/O。

**下数据库分片的两种常见实现方案：**

- **客户端代理：**  **分片逻辑在应用端，封装在 jar 包中，通过修改或者封装 JDBC 层来实现。** 当当网的 **Sharding-JDBC** 、阿里的 **TDDL** 是两种比较常用的实现。
- **中间件代理：** **在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。** 比如 **Mycat** 、360 的 **Atlas**、网易的 **DDB** 等等都是这种架构的实现。

##### 3. Sharding策略

- **哈希取模**：**hash(key) % N**。
- **范围**：可以是 **ID 范围**也可以是**时间范围**。
- **映射表**：使用**单独**的一个数据库来存储映射关系。
- **根据键的特点分**：比如主键是**身份证号**，就可以根据身份证号的特点来依据地域或者出生年月分。

##### 4. Sharding存在的问题

###### (1) 事务问题

使用**分布式事务**来解决，比如 XA 接口。

###### (2) 连接

可以将原来的连接分解成**多个单表查询**，然后在**用户程序**中进行**连接**。

###### (3) ID唯一性

- 使用**全局唯一 ID（GUID）**。
- 为每个**分片指定一个 ID 范围。**
- **分布式 ID 生成器** (如 Twitter 的 **Snowflake** 算法)。

##### 5. 分布式ID

因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，需要一个**全局唯一的 id** 来支持。

生成全局 ID 有下面这几种方式：

- **UUID**：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。
- **数据库自增 ID** : 两台数据库分别**设置不同步长**，生成不重复 ID 的策略来实现高可用。这种方式生成的 ID 有序，但是需要**独立部署数据库实例**，成本高，还会有性能瓶颈。
- **利用 Redis 生成 ID :** 性能比较好，灵活方便，不依赖于数据库。但是引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。
- **Twitter 的 snowflake 算法** ：**雪花算法**。Github 地址：https://github.com/twitter-archive/snowflake。
- **美团的 Leaf 分布式 ID 生成系统** ：Leaf 是美团开源的分布式 ID 生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、**Zookeeper** 等中间件。参考美团技术团队的一篇文章：https://tech.meituan.com/2017/04/21/mt-leaf.html 。



#### 主从复制与读写分离

##### 1. 复制步骤

- master 记录**更改**的明细，存入到**二进制日志**（binary log），如记录增删改的过程，不记录查询的过程。
- master 发送**同步消息**给 slave。
- slave 收到消息后，将 master 的二进制日志复制到本地的**中继日志**（relay log）。
- slave **重现**中继日志中的消息，从而改变数据库的数据。 

主要涉及三个线程：**binlog 线程、I/O 线程和 SQL 线程**。

-  **binlog 线程** ：负责将**主服务器上的数据**更改写入**二进制日志**（Binary log）中。
-  **I/O 线程** ：负责**从主服务器上读取二进制日志**，并写入从服务器的**中继日志**（Relay log）。
-  **SQL 线程** ：负责**读取中继日志**，解析出主服务器已经执行的数据更改并在**从服务器中执行**。

<img src="assets/1563519695873.png" alt="1563519695873" style="zoom:80%;" />

主库将**变更写入 binlog 日志**，然后从库连接到主库之后，从库有一个 **IO 线程**，将主库的 binlog 日志**拷贝到自己本地**，写入一个 **relay 中继日志**中。接着从库中有一个 **SQL 线程会从中继日志读取 binlog**，然后执行 binlog 日志中的内容，也就是在自己**本地再次执行一遍 SQL**，这样就可以保证自己跟主库的数据是一样的。

<img src="assets/mysql-master-slave.png" alt="mysql-master-slave" style="zoom:80%;" />

##### 2. 日志

 MySQL复制的**日志**格式有三种，根据**主库存放数据的方式不同**有以下三种，也就对应**三种复制方式**： 

|   复制方式    |                             特点                             |                             优点                             |                             缺点                             |
| :-----------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|    **row**    | 基于行的格式复制，记录需要修改的**每行的数据信息**。 如果一个SQL修改了2w行的数据，那么就会记录2w行的日志格式 | 保证了数据的**强一致性**，且由于记录的是执行后的结果，在从库上执行还原也会比较快 | 日志记录**数量很多**，日志文件巨大，主从之间的传输需要更多的时间。 |
| **statement** | 基于段的日志格式复制，也就是记录下**更改的 SQL 记录**，而不是更改的行的记录。 |                      日志记录量**最小**                      | 对于一些输出结果不确定的函数，在从库上执行一遍很可能会出现问题，如 uuid，从库根据日志还原主库数据的时候需要执行一遍SQL，时间相对较慢。 |
|   **mixed**   | 混合上面两种日志格式记录记录日志，至于什么时候使用哪种日志方式由MySQL本身决定。 |               可以平衡上面两种日志格式的优缺点               |                                                              |

##### 3. 读写分离

MySQL 的读写分离架构就是：**主服务器处理写操作**以及**实时性要求比较高的读**操作，而**从服务器处理读**操作。读写分离是基于上述的**主从复制**架构的。

读写分离能提高性能的**原因**在于：

- 主从服务器**负责各自的读和写**，极大程度**缓解了锁的争用**。
- **从服务器**可以**使用 MyISAM**，提升**查询性能**以及节约系统开销。
- 增加冗余，提高**可用性**。

读写分离常用**代理方式**来实现，**代理服务器**接收应用层传来的**读写请求**，然后决定转发到哪个服务器，如下图所示。

<img src="assets/1563519716630.png" alt="1563519716630" style="zoom:90%;" />

##### 4. 主从复制的问题

主从复制可能出现两个问题：

**数据不一致问题**：就是如果**主库突然宕机**，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失，造成数据不一致问题。

**同步时延问题**：就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行 SQL 的特点，在高并发场景下，从库的数据一定会比主库慢一些，是**有延时**的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。

##### 5. 复制方式

MySQL 有两个机制复制来解决上述问题，一个是**半同步复制**，用来解决主库数据丢失问题。一个是**并行复制**，用来解决主从同步延时问题。

**异步复制**：主库写入一个**事务** commit 提交并执行完之后，将日志记录到 **binlog**，将结果反馈给**客户端**，最后**将日志传输到从库**。该复制经常遇到的问题是：因为 binlog 日志是**推送**的，所有主库和从库之间存在一定的**延迟**。 这样就会造成很多问题，比如主库因为磁盘损坏等故障突然崩掉，导致 binlog 日志不存在，同时因为延迟 binlog 还没有推送到从库，从库也就会丢失很多被主库提交的事物，从而造成**主从不一致问题**。 

**半同步复制**：主库写入一个**事务** commit 提交并执行完之后，并**不直接将请求反馈给前端应用用户**，而是等待从**库也接收到** binlog 日志并成功写入中继日志后，主库才返回 commit 操作成功给客户端。半同步复制保障了事务执行后，至少有**两份日志记录**，一份在**主库**的 binlog 上 ，另一份至少在**从库**的中继日志 Relaylog 上，这样就极大的**保证了数据的一致性**。 

**并行复制**：指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后**并行重放不同库的日志**，这是**库级别的并行**。

##### 6. 主从延迟问题解决

一般来说，如果主从延迟较为严重，有以下解决方案：

* **分库**，将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此时主从延迟可以忽略不计。
* 打开 MySQL 支持的**并行复制**，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了 2000/s，并行复制还是没意义。
* 如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询**设置直连主库**。**不推荐**这种方法。

