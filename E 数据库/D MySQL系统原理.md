[TOC]

### MySQL系统原理

#### MySQL架构

##### 1. 架构概述

下图是 MySQL 的一个简要架构图。

- **连接器**：身份认证和权限相关(登录 MySQL 的时候)。
- **查询缓存**：执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。
- **分析器**：没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。
- **优化器**：按照 MySQL 认为最优的方案去执行。
- **执行器**：执行语句，然后从存储引擎返回数据。

<img src="assets/image-20200527094934603.png" alt="image-20200527094934603" style="zoom:80%;" />

简单来说 MySQL 主要分为 **Server 层和存储引擎层**：

- **Server 层**：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。
- **存储引擎**： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。**现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。**



#### MySQL存储引擎

##### 1. 概述

**查看 MySQL 提供的所有存储引擎**。

```sql
mysql> show engines;
```

如下图所示：

![查看MySQL提供的所有存储引擎](assets/mysql-engines.png)

从上图我们可以查看出 MySQL 当前**默认的存储引擎是 InnoDB**，并且在 5.7 版本所有的存储引擎中**只有 InnoDB 是事务**性存储引擎，也就是说只有 InnoDB 支持事务。

也可以通过下面的命令查看默认的存储引擎。

```sql
mysql> show variables like '%storage_engine%';
```

**查看某张表的存储引擎**：

```sql
show table status like "table_name" ;
```

![image-20200531201235503](assets/image-20200531201235503.png)

MySQL 中的数据用各种不同的**技术存储在文件（或者内存）**中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，能够获得额外的速度或者功能，从而改善你的应用的整体功能。存储引擎说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。

MySQL5.5 以前的默认存储引擎是 **MyISAM**，MySQL 5.5 之后的**默认存储引擎是 InnoDB**。不同存储引起都有各自的特点，为适应不同的需求，需要选择不同的存储引擎，所以首先考虑这些存储引擎各自的功能和兼容。

##### 2. MyISAM

MySQL 5.5 版本之前的默认存储引擎，在 5.0 以前最大表存储空间最大 4G，5.0 以后最大 256TB。

**不支持事务**。**不支持行级锁，只能对整张表加锁**，读取时会对需要读到的**所有表加共享锁**，写入时则对表加**排它锁**。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为**并发插入**（CONCURRENT INSERT）。

可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。

如果指定了 **DELAY_KEY_WRITE** 选项，在每次**修改**执行完成时，**不会立即**将修改的索引数据写入磁盘，而是会写到内存中的**键缓冲区**，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会**造成索引损坏**，需要执行**修复操作**。

MyISAM 在**读写分离**架构中可以用于**读服务器**上，提高读的效率。

MyISAM 存储引擎下的表由 **.myd（数据）**和 **.myi（索引文件）组成**，.**frm 文件存储表结构**。

**应用场景**：如果设计简单，数据以**紧密格式**存储。对于**只读数据**，或者**表比较小**、可以**容忍修复操作**，则依然可以使用它。

- 没有事务。
- 只读类应用（插入不频繁，查询非常频繁）。
- 空间类应用（唯一支持空间函数的引擎）。
- 做很多 count 的计算。

##### 3. InnoDB

MySQL 5.5 及之后版本的**默认存储引擎**，是**事务型**存储引擎，只有在需要它**不支持**的特性时，才考虑使用其它存储引擎。它内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。

**备份**：支持真正的在线**热备份**。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

**事务**：实现了四个标准的隔离级别，默认级别是**可重复读（REPEATABLE READ）**。在可重复读隔离级别下，通过==**多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）**防止**幻影读**==。**Redo log** （实现事务的持久性） 和 **Undo log**（为了实现事务的原子性，存储未完成事务 log，用于回滚）。InnoDB 支持**行级锁与表级锁**。

**索引**：主索引是**聚簇索引**，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。

**应用场景**：

- 可靠性要求比较高，或者要求事务。其实，**能用就用**。
- 表更新和查询都相当的频繁，并且行锁定的机会比较大的情况。

##### 3. 比较InnoDB与MyISAM

- **事务**：InnoDB 是==**事务型**==的，可以使用 **Commit 和 Rollback** 语句，MyISAM 不支持事务。
- **锁的粒度**：MyISAM 只支持表锁，InnoDB 支持表锁与行锁。而且 InnoDB 在应对高并发事务上使用 MVCC 比单纯的加锁更高效。
- **并发**：**MyISAM** 只支持**表级锁**，而 **InnoDB 还支持行级锁**。
- **外键**：MyISAM 不支持外键而 InnoDB 支持**外键**。
- **备份**：InnoDB 支持**在线热备份**。
- **崩溃恢复**：MyISAM **崩溃**后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢，InnoDB 崩溃之后恢复更加容易。
- **其它特性**：MyISAM 支持压缩表和空间数据索引。

《MySQL 高性能》：不要轻易相信“MyISAM 比 InnoDB 快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB 的速度都可以让 MyISAM 望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。所以**一般情况下选择 InnoDB 都是没有问题**的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择 MyISAM 也是一个不错的选择。但是一般情况下都是需要考虑到这些问题的。

##### 4. CSV

**CSV 存储引擎特点**：以 **CSV 格式**进行数据存储，所有列必须都是不能为 NULL，不支持索引，可以对**数据文件直接编辑**（其他引擎是二进制存储，不可编辑）。

**对应文件系统存储特点**：数据以文本方式存储在文件中，`.csv`文件存储表内容，`.csm`文件存储表的元数据，如表状态和数据量，`.frm`存储表的结构。

**引用场景**：作为数据交换的**中间表**。

##### 5. Archive

**特性**：以 zlib 对表数据进行压缩，磁盘 I/O 更少，数据存储在ARZ为后缀的文件中（表文件为 a.arz，a.frm），只支持 insert 和 select 操作（不可以 delete 和 update，会提示没有这个功能），只允许在自增 ID 列上加索引。

**应用场景**：日志和数据采集类应用。

##### 6. Memory

**特性**：也称为 HEAP 存储引擎，所以数据保存在内存中（数据库重启后会导致数据丢失），支持 HASH 索引（等值查找应选择 HASH）和 BTree 索引（范围查找应选择），所有字段都为固定长度，varchar(10) == char(10)，不支持 BLOG 和 TEXT 等大字段，Memory 存储使用表级锁（性能可能不如 innodb） ，Memory存储引擎默认表大小只有 16M，可以通过调整 max_heap_table_size 参数。

**应用场景**：用于查找或是映射表，例如右边和地区的对应表，用于保存数据分析中产生的中间表，用于缓存周期性聚合数据的结果表等。

**注意：** Memory 数据易丢失，所以要求数据可再生。

##### 7. Federated

**特性**：提供了访问远程 MySQL 服务器上表的方法，本地不存储数据，数据全部放在**远程服务器**上。

**使用 Federated**默认是禁止的。如果需要启用，需要在启动时增加 Federated 参数。

##### 8. 面试题

###### (1) 如何选择存储引擎?

**根据具体的应用场景选择：** 综合考虑是否需要事务、是否可以热备份、崩溃恢复、存储引擎的特有特性等。

**重要一点：** 不要混合使用存储引擎。一般而言，**使用 InnoDB** 就行了。

###### (2) 为什么不建议InnoDB使用亿级大表

百万数据 和 亿级数据可能 B+tree 都需要三层 tree， 但因为百万千万数据的**索引空间少**，可以更多的放到**内存中**，速度也就相应快。  亿级表只能放很小的一部分，万一不中缓存，那么就要走更多的磁盘 IO。 说白了主要就是 **innodb_buffer_pool 缓存**不够。

参考：[为什么不建议innodb使用亿级大表 | 峰云就她了](http://xiaorui.cc/2016/12/08/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AEinnodb%E4%BD%BF%E7%94%A8%E4%BA%BF%E7%BA%A7%E5%A4%A7%E8%A1%A8/)



#### 数据库连接池

数据库连接本质就是一个 **socket** 的连接。数据库服务端还要维护一些缓存和用户权限信息之类的 所以占用了一些内存。可以把数据库连接池是看做是**维护的数据库连接的缓存**，以便将来需要对数据库的请求时可以重用这些连接。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序的请求，既昂贵又浪费资源。**在连接池中，创建连接后，将其放置在池中，并再次使用它，因此不必建立新的连接。如果使用了所有连接，则会建立一个新连接并将其添加到池中**。 连接池还减少了用户必须等待建立与数据库的连接的时间。



#### SQL语句执行流程

SQL 语句大致可以分为两种，一种是**查询**，一种是**更新**（增加，更新，删除）。

###### (1) 查询语句

先分析下查询语句，语句如下：

```mysql
SELECT * FROM tb_student  A WHERE A.age='18' AND A.name=' 张三 ';
```

结合上面的说明，我们分析下这个语句的执行流程：

- 先检查该语句是**否有权限**，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 SQL 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。
- 通过**分析器进行词法分析并分析是否有语法错误**，提取 SQL 语句的**关键元素**，比如提取上面这个语句是查询 SELECT，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id='1'。然后判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。
- 接下来就是**优化器确定执行方案**，上面的 SQL 语句，可以有两种执行方案：(1) 先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。(2) 先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。那么优化器根据**自己的优化算法**进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。

###### (2) 更新语句

接下来看看更新语句如何执行，SQL 语句如下：

```mysql
UPDATE tb_student A SET A.age='19' WHERE A.name=' 张三 ';
```

来给张三修改下年龄。其实条语句也基本上会沿着上一个**查询的流程**走，只不过执行**更新需要进行日志记录**，这就会引入日志模块了，MySQL 自带的日志模块式 **binlog（归档日志）** ，所有的存储引擎都可以使用，**常用的 InnoDB 引擎**还自带了一个日志模块 **redo log（重做日志）**，这里就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：

- 先查询到张三这一条数据，如果**有缓存**，也是会用到缓存。
- 然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把**数据保存在内存中**，同时**记录 redo log**，此时 redo log **进入 prepare 状态**，然后告诉执行器，执行完成了，随时可以**提交**。
- 执行器**收到通知后记录 binlog**，然后调用引擎接口，**提交 redo log 并且状态改为提交状态**。
- 更新完成。

> **为什么要用两个日志模块，用一个日志模块不行吗?**

这是因为最开始 MySQL 自带的引擎是 MyISAM，但是 **redo log 是 InnoDB 引擎特有的**，其他存储引擎都没有，这就导致会**没有 crash-safe 的能力**(crash-safe 的能力即使数据库发生**异常重启**，之前提交的记录都不会丢失)，**binlog 日志只能用来归档**。

并不是说只用一个日志模块不可以，**只是 InnoDB 引擎就是通过 redo log 来支持事务的**。那么用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里用**反证法**来说明下为什么要这么做？

- **先写 redo log 直接提交，然后写 binlog**，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会**丢失**这一条数据。
- **先写 binlog，然后写 redo log**，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会**产生数据不一致**的情况。

如果**采用 redo log 两阶段提交**的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的**处理机制**了，MySQL 的处理过程如下：

- **判断 redo log 是否完整，如果判断是完整的，就立即提交。**
- **如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log，不完整就回滚事务。**

这样就解决了**数据一致性**的问题。





#### 参考资料

- [MySQL-InnoDB-MVCC多版本并发控制](https://segmentfault.com/a/1190000012650596)