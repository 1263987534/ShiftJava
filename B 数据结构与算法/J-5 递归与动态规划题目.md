[TOC]

### 递归与动态规划题目

递归和动态规划都是将原问题**拆成多个子问题然后求解**，他们之间最本质的区别是，**动态规划保存了子问题的解**，避免重复计算。



### 斐波那契数列类题目

#### 斐波那契数列【简单】

##### 1. 题目

求斐波那契数列的**第 n 项**，n <= 39。

<img src="assets/1563521870748-1594445002958.png" alt="1563521870748" style="zoom:56%;" />

##### 2. 解题

如果使用**递归**求解，会**重复计算**一些子问题。例如，计算 f(4) 需要计算 f(3) 和 f(2)，计算 f(3) 需要计算 f(2) 和 f(1)，可以看到 f(2) 被**重复计算**了。

<img src="assets/1563521902486-1594445004941.png" alt="1563521902486" style="zoom:50%;" />

递归是将一个问题划分成**多个子问题**求解，动态规划也是如此，但是**动态规划**会把子问题的**解缓存**起来，从而避免重复求解子问题。

```java
public int Fibonacci(int n) {
    // Base case
    if (n <= 1)
        return n;
    int[] fib = new int[n + 1];
    // 初始化
    fib[1] = 1;
    // 自底向上计算即可
    for (int i = 2; i <= n; i++)
        fib[i] = fib[i - 1] + fib[i - 2];
    return fib[n];
}
```

考虑到第 i 项只与第 **i - 1** 和第 **i - 2** 项有关，因此**只需要存储前两项**的值就能求解第 i 项，从而将**空间复杂度**由 O(N) 降低为 O(1)。

```java
public int Fibonacci(int n) {
    if (n <= 1) {
        return n;
    }
    // 两个指针，一个前一个后
    int back = 0, front = 1;
    // 存放最终结果
    int fibAns = 0;
    for (int i = 2; i <= n; i++) {
        fibAns = back + front;
        back = front;
        front = fibAns;
    }
    return fibAns;
}
```

由于待求解的 n 小于 40，因此可以将前 40 项的结果**先进行计算**，之后就能以 **O(1)** 时间复杂度得到第 n 项的值。

```java
public class Solution {

    private int[] fib = new int[40];
	// 预先计算并缓存
    public Solution() {
        fib[1] = 1;
        for (int i = 2; i < fib.length; i++)
            fib[i] = fib[i - 1] + fib[i - 2];
    }

    public int Fibonacci(int n) {
        return fib[n];
    }
}
```

#### 跳台阶/爬楼梯【简单】

##### 1. 题目

一只青蛙一次可以跳上 **1 级台阶**，也可以跳上 **2 级**。求该青蛙跳上一个 **n 级的台阶总共有多少种跳法**。

<img src="assets/1563521990341-1594445009253.png" alt="1563521990341" style="zoom:50%;" />

连接：https://leetcode-cn.com/problems/climbing-stairs/

##### 2. 解题

当 **n = 1** 时，只有**一种**跳法：

<img src="assets/1563522011148-1594445010789.png" alt="1563522011148" style="zoom:50%;" />

当 **n = 2** 时，有**两种**跳法：

<img src="assets/1563522031061-1594445013540.png" alt="1563522031061" style="zoom:50%;" />

跳 n 阶台阶，可以**先跳 1 阶台阶**，**再跳 n-1** 阶台阶；或者**先跳 2 阶**台阶，再跳 **n-2 阶**台阶。而 n-1 和 n-2 阶台阶的跳法可以看成**子问题**，该问题的递推公式为：

<img src="assets/1563522045805-1594445016452.png" alt="1563522045805" style="zoom:50%;" />

也可也看成是**裴波那契**类型的题目。

```java
public int JumpFloor(int n) {
    if (n <= 2) {
        return n;
    }
    int back = 1, front = 2;
    int result = 1;
    // 滚动计算
    for (int i = 2; i < n; i++) {
        result = back + front;
        back = front;
        front = result;
    }
    return result;
}
```

----

#### 变态跳台阶【简单】

##### 1. 题目

一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级... 它也**可以跳上 n 级**。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

<img src="assets/1563522070330-1594445018755.png" alt="1563522070330" style="zoom:50%;" />

##### 2. 解题

###### (1) 动态规划

每个位置都是之前位置的结果的**和**。

```java
public int JumpFloorII(int target) {
    int[] dp = new int[target];
    Arrays.fill(dp, 1);
    for (int i = 1; i < target; i++) {
        for (int j = 0; j < i; j++) {
            dp[i] += dp[j];
        }
    }
    return dp[target - 1];
}
```

###### (2) 数学推导

跳上 n-1 级台阶，可以从 n-2 级跳 1 级上去，也可以从 **n-3 级**跳 2 级上去...，那么

```java
f(n-1) = f(n-2) + f(n-3) + ... + f(0)
```

同样，跳上 n 级台阶，可以从 n-1 级跳 1 级上去，也可以从 n-2 级跳 2 级上去... ，那么

```java
f(n) = f(n-1) + f(n-2) + ... + f(0)
```

综上可得

```java
f(n) - f(n-1) = f(n-1)
```

即：

```java
f(n) = 2*f(n-1)
```

所以 f(n) 是一个等比数列

```java
public int JumpFloorII(int target) {
    return (int) Math.pow(2, target - 1);
}
```

#### 母牛生产问题

题目描述：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。

第 i 年成熟的牛的数量为：

<img src="assets/1563524629986.png" alt="1563524629986" style="zoom:67%;" />



### 路径类题目

#### 矩阵中的不同路径【中等】

##### 1. 题目

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问**总共有多少条不同的路径**？

![image-20200707161628832](assets/image-20200707161628832.png)

链接：https://leetcode-cn.com/problems/unique-paths

##### 2. 题解

###### (1) 动态规划法

令 dp\[i][j] 是到达 i, j 位置的路径数。由于**某个位置只能从上方或者左方**到来，所以**路线数量就是上方和左方路线数量的和。**状态方程：

```java
dp[i][j] = dp[i-1][j] + dp[i][j-1]
```

初始化：对于第一行 dp\[0][j]，或者第一列 dp\[i][0]，由于都是在边界，所以**只能为 1**。

时间复杂度：O(m * n)，空间复杂度：O(m * n)

```java
public int uniquePaths(int m, int n) {
    int[][] dp = new int[m][n];
    // 初始化第一行和第一列
    for (int i = 0; i < n; i++) dp[0][i] = 1;
    for (int i = 0; i < m; i++) dp[i][0] = 1;
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
}
```

**优化**：因为每次只需要 dp\[i-1][j], dp\[i][j-1]。所以可以只记录这两个数。

```java
public int uniquePaths2(int m, int n) {
    int[] pre = new int[n];
    int[] cur = new int[n];
    Arrays.fill(pre, 1);
    Arrays.fill(cur, 1);
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            cur[j] = cur[j - 1] + pre[j];
        }
        pre = cur.clone();
    }
    return pre[n - 1];
}
```

###### (2) 数学推导法

也可以直接用数学公式求解，这是一个组合问题。机器人总共移动的次数 S=m+n-2，向下移动的次数 D=m-1，那么问题可以看成从 S 中取出 D 个位置的组合数量，这个问题的解为 C(S, D)。

```java
public int uniquePaths3(int m, int n) {
    // 总共的移动次数
    int totalMove = m + n - 2;
    // 向下的移动次数
    int downMove = m - 1;
    long res = 1;
    for (int i = 1; i <= downMove; i++) {
        res = res * (totalMove - downMove + i) / i;
    }
    return (int) res;
}
```

#### 最小路径和【中等】

##### 1. 题目

给定一个包含非负整数的 m x n 网格，请找出一条从**左上角到右下角**的路径，使得路径上的**数字总和为最小**。

说明：每次只能向下或者向右移动一步。示例：

````java
输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
````

链接：https://leetcode-cn.com/problems/minimum-path-sum

也可以求**最大**路径和，差不多的。

##### 2. 题解

类似上一题！只不过这里 dp 数组表示的是到达  m, n 坐标时的最小的和。

这里状态方程为：

```java
dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
```

```java
public int minPathSum(int[][] grid) {
    int row = grid.length;
    int col = grid[0].length;
    if (row == 0 || col == 0) return 0;

    int[][] dp = new int[row][col];
    // 初始化第一行第一列
    dp[0][0] = grid[0][0];
    for (int i = 1; i < row; i++) {
        dp[i][0] = dp[i - 1][0] + grid[i][0];
    }
    for (int j = 1; j < col; j++) {
        dp[0][j] = dp[0][j - 1] + grid[0][j];
    }

    for (int i = 1; i < row; i++) {
        for (int j = 1; j < col; j++) {
            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
        }
    }
    return dp[row - 1][col - 1];
}
```

可以用一个一维数组来代替二维数组优化空间。

```java
public int minPathSum2(int[][] grid) {
    // Base case
    if (grid.length == 0 || grid[0].length == 0) return 0;
    int m = grid.length, n = grid[0].length;
    int[] dp = new int[n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            // 只能从上侧走到该位置
            if (j == 0) {
                dp[j] = dp[j];
            } else if (i == 0) {
                // 只能从左侧走到该位置
                dp[j] = dp[j - 1];
            } else {
                dp[j] = Math.min(dp[j - 1], dp[j]);
            }
            dp[j] += grid[i][j];
        }
    }
    return dp[n - 1];
}
```



### 数组区间问题

#### 数组区间和【简单】

##### 1. 题目

给定一个整数数组  nums，**求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和**，包含 i,  j 两点。

示例：

```java
给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()
sumRange(0, 2) -> 1
sumRange(2, 5) -> -1
sumRange(0, 5) -> -3
```

说明：你可以假设数组不可变。会多次调用 sumRange 方法。

链接：https://leetcode-cn.com/problems/range-sum-query-immutable

##### 2. 题解

求区间 i \~ j 的和，可以**转换为 sum[j + 1] - sum[i]**，其中 **sum[i] 为 0 \~ i - 1** 的和。因此先**滚动计算**出各个位置之前的和就行了。

```java
// 存放计算好的和
private int[] sums;

public NumArray(int[] nums) {
    sums = new int[nums.length + 1];
    for (int i = 1; i <= nums.length; i++) {
        // 滚动计算数组和
        sums[i] = sums[i - 1] + nums[i - 1];
    }
}

public int sumRange(int i, int j) {
    return sums[j + 1] - sums[i];
}
```



### 字符串与序列类题目

#### 数组最大子序列和【简单】

##### 1. 题目

给定一个整数数组 nums ，找到一个具有**最大和的连续子数组**（子数组最少包含一个元素），返回其**最大和**。

示例：

```java
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

进阶：如果你已经实现**复杂度为 O(n) 的解法**，尝试使用更为精妙的分治法求解。

链接：https://leetcode-cn.com/problems/maximum-subarray

##### 2. 题解

###### (1) 动态规划

动态规划的是首先对数组进行遍历，当前最大连续子序列**和为 sum**，结果为 ans。

- 如果 **sum > 0**，则说明 sum **对结果有增益效果**，则 sum 保留并加上当前遍历数字。
- 如果 **sum <= 0**，则说明 sum 对结果**无增益效果**，需要**舍弃**，则 sum 直接**更新为当前遍历数字**。
- 每次**比较 sum 和 ans 的大小**，将最大值置为 ans，遍历结束返回结果。

```java
public int maxSubArray(int[] nums) {
    // 数组长度
    int len = nums.length;
    if (len == 0) return 0;
    // 构造dp数组 dp数组存放的是以当前索引位置结束的子数组中的最大子序列和
    int[] dp = new int[len];
    // 初始化
    dp[0] = nums[0];
    // 遍历nums数组
    for (int i = 1; i < len; i++) {
        // 说明之前是正增益
        if (dp[i - 1] >= 0) {
            dp[i] = dp[i - 1] + nums[i];
        } else {
            // 直接取值
            dp[i] = nums[i];
        }
    }
    // 最后不要忘记遍历dp数组找到子序列和最大值
    int res = dp[0];
    for (int i = 1; i < len; i++) {
        res = Math.max(res, dp[i]);
    }
    return res;
}
```

可以进一步**压缩空间**。**状态压缩** , 只需要一个变量 subMax 保存前面子组合的**最大值**，另外一个 max 保存**全局最大值**。其实代码结构差不多。

```java
public int maxSubArray2(int[] nums) {
    if (nums == null) return 0;
    // 全局最大值
    int maxSum = nums[0];
    // 前一个子组合的最大值,状态压缩
    int subMax = nums[0];
    for (int i = 1; i < nums.length; i++) {
        if (subMax > 0) {
            // 前一个子组合最大值大于0，正增益
            subMax = subMax + nums[i];
        } else {
            // 前一个子组合最大值小于0，抛弃前面的结果
            subMax = nums[i];
        }
        // 计算全局最大值 滚动更新即可
        maxSum = Math.max(maxSum, subMax);
    }
    return maxSum;
}
```

###### (2) 分治法

分治法是将整个**数组切分成几个小组**，然后每个小组再切分成几个**更小的小组**，一直到不能继续切分也就是**只剩一个数字**为止。每个小组会**计算出最优值**，汇报给上一级的小组，一级一级汇报，上级拿到下级的汇报找到最大值，得到最终的结果。和**归并排序**的算法类似，先切分，再合并结果。

这个问题中的关键就是**如何切分**这些组合才能使每个小组之间**不会有重复的组合**（有重复的组合意味着有重复的计算量）。

首先是切分分组方法，就这个案例中的例子来，我们有一个数组 [-2, 1, -3, 4, -1, 2, 1, -5, 4] ，一共有 9 个元素，我们 center = (start + end) / 2 这个原则，得到中间元素的索引为 4 ，也就是 -1，拆分成**三个组合**：

- [-2, 1, -3, 4, -1] 以及它的子序列（在 -1 左边的并且包含它的为一组）。
- [2, 1, -5, 4] 以及它的子序列（在 -1 右边不包含它的为一组）。
- 任何包含 -1 以及它右边元素 2 的序列为一组（换言之就是包含左边序列的最右边元素以及右边序列最左边元素的序列，比如 [4, -1, 2, 1]，这样就保证这个组合里面的任何序列都不会和上面两个重复）。

以上的三个组合内的序列没有任何的重复的部分，而且一起构成所有子序列的全集，计算出这个三个子集合的最大值，然后取其中的最大值，就是这个问题的答案了。

然而前两个子组合可以用递归来解决，一个函数就搞定，第三个跨中心的组合应该怎么计算最大值呢？

答案就是先计算左边序列里面的包含最右边元素的子序列的最大值，也就是从左边序列的最右边元素向左一个一个累加起来，找出累加过程中每次累加的最大值，就是左边序列的最大值。

同理找出右边序列的最大值，就得到了右边子序列的最大值。左右两边的最大值相加，就是包含这两个元素的子序列的最大值。

在计算过程中，累加和比较的过程是关键操作，一个长度为 n 的数组在递归的每一层都会进行 n 次操作，分治法的递归层级在 logNlogN 级别，所以整体的时间复杂度是 O(nlogn)O(nlogn)，在时间效率上不如动态规划的 O(n)O(n) 复杂度。

分治法的思路是这样的，其实也是分类讨论。

连续子序列的最大和主要由这三部分子区间里元素的最大和得到：

- 第 1 部分：子区间 [left, mid]；
- 第 2 部分：子区间 [mid + 1, right]；
- 第 3 部分：包含子区间[mid , mid + 1]的子区间，即 nums[mid] 与nums[mid + 1]一定会被选取。

对它们三者求最大值即可。

<img src="assets/image-20200518184713364.png" alt="image-20200518184713364" style="zoom:47%;" />

```java
public int maxSubArray(int[] nums) {
    return maxSubArrayDivideWithBorder(nums, 0, nums.length - 1);
}

private int maxSubArrayDivideWithBorder(int[] nums, int start, int end) {
    if (start == end) {
        // 只有一个元素，也就是递归的结束情况
        return nums[start];
    }

    // 计算中间值
    int center = (start + end) / 2;
    int leftMax = maxSubArrayDivideWithBorder(nums, start, center); // 计算左侧子序列最大值
    int rightMax = maxSubArrayDivideWithBorder(nums, center + 1, end); // 计算右侧子序列最大值

    // 下面计算横跨两个子序列的最大值

    // 计算包含左侧子序列最后一个元素的子序列最大值
    int leftCrossMax = Integer.MIN_VALUE; // 初始化一个值
    int leftCrossSum = 0;
    for (int i = center ; i >= start ; i --) {
        leftCrossSum += nums[i];
        leftCrossMax = Math.max(leftCrossSum, leftCrossMax);
    }

    // 计算包含右侧子序列最后一个元素的子序列最大值
    int rightCrossMax = nums[center+1];
    int rightCrossSum = 0;
    for (int i = center + 1; i <= end ; i ++) {
        rightCrossSum += nums[i];
        rightCrossMax = Math.max(rightCrossSum, rightCrossMax);
    }

    // 计算跨中心的子序列的最大值
    int crossMax = leftCrossMax + rightCrossMax;

    // 比较三者，返回最大值
    return Math.max(crossMax, Math.max(leftMax, rightMax));
}
```

#### 判断是否是字符串子序列【简单】

##### 1. 题目

给定字符串 sub 和 origin ，**判断 sub  是否为 origin 的子序列**。你可以认为 sub  和 origin 中仅包含英文小写字母。字符串 origin 可能会很长（长度 ~= 500,000），而 sub  是个短字符串（长度 <=100）。

字符串的一个子序列是原始字符串**删除一些（也可以不删除）字符而不改变剩余字符相对位置**形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

```java
示例 1:
s = "abc", t = "ahbgdc"
返回 true.

示例 2:
s = "axc", t = "ahbgdc"
返回 false.
```

后续挑战：如果有大量输入的 Sub ，称作S1, S2, ... , Sk 其中 k >= 10 亿，你需要依次检查它们是否为 Origin 的子序列。在这种情况下，你会怎样改变代码？

链接：https://leetcode-cn.com/problems/is-subsequence

##### 2. 题解

如果是匹配一个较短字符串 **sub** ，对于 **sub** 中每一个`char` 都**优先匹配最开始**遇到的，直接扫描一遍 **origin** 即可。

```java
public boolean isSubsequence(String sub, String origin) {
    int index = 0;
    for (char ch : sub.toCharArray()) {
        while (index < origin.length() && origin.charAt(index) != ch) {
            index++;
        }
        index++;
    }
    return index <= origin.length();
}
```

一种**双百**的解法复杂度为 O(N)，记住**这种解法**。

从 sub 中**依次取出一个字符**，到 origin 中去**查找**，记录第一次出现的位置；sub 中取出下一个字符，**从上次出现位置的下一个**开始查找，直到 sub 中的字符**全部扫描**完成。

```java
public boolean isSubsequence2(String sub, String origin) {
    // Base case
    if (sub == null || origin == null) return true;
    int alreadyUseIndex = 0, location = 0;
    for (int i = 0; i < sub.length(); i++) {
        // 找到当前字符在origin字符串中第一次出现的索引
        location = origin.indexOf(sub.charAt(i), alreadyUseIndex);
        // 说明没找到直接返回
        if (location < 0) {
            return false;
        }
        // 更新已经找过的索引
        alreadyUseIndex = location + 1;
    }
    return true;
}
```

后序挑战，如果 Sub 数量极大。

```java
public boolean isSubsequence3(String sub, String origin) {
    // 预处理,开头加一个空字符作为匹配入口
    origin = " " + origin;
    int len = origin.length();
    // 记录每个位置的下一个ch的位置
    int[][] dp = new int[len][26];
    for (char ch = 0; ch < 26; ch++) {
        int position = -1;
        // 从后往前记录dp
        for (int i = len - 1; i >= 0; i--) {
            dp[i][ch] = position;
            if (origin.charAt(i) == ch + 'a') {
                position = i;
            }
        }
    }
    // 匹配
    int i = 0;
    // 跳跃遍历
    for (char ch : sub.toCharArray()) {
        i = dp[i][ch - 'a'];
        if (i == -1) return false;
    }
    return true;
}
```



#### 回文子串数量【中等】

##### 1. 题目

给定一个字符串，你的任务是**计算这个字符串中有多少个回文子串**。具有不同开始位置或结束位置的子串，即使是由**相同的字符组成**，也会被计为是**不同的子串**。

```java
示例 1:
输入: "abc"
输出: 3
解释: 三个回文子串: "a", "b", "c".

示例 2:
输入: "aaa"
输出: 6
说明: 6个回文子串: "a", "a", "a", "aa", "aa", "aaa".
```

输入的字符串长度不会超过 1000。

链接：https://leetcode-cn.com/problems/palindromic-substrings

##### 2. 题解

###### (1) 中心扩展法

在长度为 N 的字符串中，可能的**回文串中心位置**有 **2N-1** 个：**单个字母或两个字母中间（此时中间没有字母）**。

**从每一个回文串中心**开始统计回文串数量。**回文区间 [a, b]** 表示 S[a], S[a+1], ..., S[b] 是**回文串**，根据回文串定义可知 [a+1, b-1] 也是回文区间。

对于**每个可能**的回文串中心位置，尽**可能扩大它的回文区间** [left, right]。当 **left >= 0 and right < N and S[left] == S[right] 时，扩大区间**。此时回文区间表示的回文串为 S[left], S[left+1], ..., S[right]。

```java
public int countSubstrings(String str) {
    int len = str.length(), res = 0;
	// 从左到右变量
    for (int center = 0; center <= 2 * len - 1; ++center) {
        // 计算左边界
        int left = center / 2;
        // 计算右边界
        int right = left + center % 2;
        // 从中心向两边扩散：保证索引不越界且字母相等
        while (left >= 0 && right < len && str.charAt(left) == str.charAt(right)) {
            res++;
            left--;
            right++;
        }
    }
    return res;
}
```

###### (2) 马拉车算法

马拉车算法可以在线性时间内**找出以任何位置为中心的最大回文串**。

###### (3) 动态规划

状态：dp\[i][j] 表示字符串 s 在 [i, j] 区间的子串是否是一个回文串。

状态转移方程：当 s[i] == s[j] && (j - i < 2 || dp\[i + 1][j - 1]) 时，dp\[i][j]=true，否则为 false。

- 当只有一个字符时，比如 a 自然是一个回文串。
- 当有两个字符时，如果是相等的，比如 aa，也是一个回文串。
- 当有三个及以上字符时，比如 ababa 这个字符记作串 1，把两边的 a 去掉，也就是 bab 记作串 2，可以看出只要串 2 是一个回文串，那么左右各多了一个 a 的串 1 必定也是回文串。所以**当 s[i]==s[j] 时**，自然要看 dp\[i+1][j-1] 是不是一个回文串。

```java
public int countSubstrings2(String str) {
    // 动态规划法
    boolean[][] dp = new boolean[str.length()][str.length()];
    int ans = 0;
    for (int j = 0; j < str.length(); j++) {
        for (int i = 0; i <= j; i++) {
            if (str.charAt(i) == str.charAt(j) && (j - i < 2 || dp[i + 1][j - 1])) {
                dp[i][j] = true;
                ans++;
            }
        }
    }
    return ans;
}
```

---

#### 字符串的最长回文子序列

##### 1. 题目

给定一个字符串 s，找到其中最长的回文子序列。可以假设 s 的最大长度为1000。**最长回文子序列和上一题最长回文子串的区别是，子串是字符串中连续的一个序列，而子序列是字符串中保持相对位置的字符序列，例如，"bbbb"可以是字符串"bbbab"的子序列但不是子串。**给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。

示例 1：

```
输入:
"bbbab"
输出:
4
```

一个可能的最长回文子序列为 "bbbb"。

示例 2：

```
输入:
"cbbd"
输出:
2
```

一个可能的最长回文子序列为 "bb"。

链接：https://leetcode-cn.com/problems/longest-palindromic-subsequence/

##### 2. 题解

###### (1) 动态规划法

**dp\[i][j] 表示 s 的第 i 个字符到第 j 个字符组成的子串中，最长的回文序列长度是多少。**

如果 s 的第 i 个字符和第 j 个字符相同的话

```java
f[i][j] = f[i + 1][j - 1] + 2
```

如果 s 的第 i 个字符和第 j 个字符不同的话

````java
f[i][j] = max(f[i + 1][j], f[i][j - 1])
````

然后注意遍历顺序，i 从最后一个字符开始往前遍历，j 从 i + 1 开始往后遍历，这样可以保证每个子问题都已经算好了。

**初始化**：f\[i][i] = 1 单个字符的最长回文序列是 1。

**结果**：f\[0][n - 1]。

计算方向如下所示。

<img src="assets/image-20200708204345225.png" alt="image-20200708204345225" style="zoom:30%;" />

```java
public int longestPalindromeSubseq(String str) {
    int len = str.length();
    int[][] dp = new int[len][len];
    // 从后往前dp
    for (int i = len - 1; i >= 0; i--) {
        // 初始化
        dp[i][i] = 1;
        for (int j = i + 1; j < len; j++) {
            // 状态转移方程
            if (str.charAt(i) == str.charAt(j)) {
                dp[i][j] = dp[i + 1][j - 1] + 2;
            } else {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }
    // 整个s的最长回文子串长度
    return dp[0][len - 1];
}
```



#### 背包问题

先得到该问题的局部解然后扩展到全局问题解。

我们可以假设一个B(k,C) 方法，第k件物品，当前背包所剩下的容量C（初始则C=W）情况下，能够偷的最大价值量。

B( i , c ) = max{ F( i - 1 , C ) ,  v(i) + F( i - 1, C - w[i] ) };

##### （1）记忆化搜索

```java
/**
 * 记忆化搜索
 * 时间复杂度: O(n * C) 其中n为物品个数; C为背包容积
 * 空间复杂度: O(n * C)
 */
public class Solution01 {
    private static int count = 0;
    private static int[][] memo;

    public int knapsack(int[] w, int[] v, int C) {
        int n = w.length;
        memo = new int[n][C + 1];
        for(int i = 0;i<n;i++)
            Arrays.fill(memo[i],-1);

        return bestValue(w, v, n - 1, C);
    }

    // 用 [0...index]的物品,填充容积为c的背包的最大价值
    private int bestValue(int[] w, int[] v, int i, int C) {
        count++;
        if (i < 0 || C <= 0)
            return 0;

        if (memo[i][C] != -1) // 记忆化搜索
            return memo[i][C];

        int res = 0;
        res = bestValue(w, v, i - 1, C);
        if (C >= w[i])
            res = max(res, v[i] + bestValue(w, v, i - 1, C - w[i]));

        return memo[i][C] = res;
    }

    private int max(int a, int b) {
        return a > b ? a : b;
    }

    public static void main(String[] args) {
        int[] w = {5,4,6,3};
        int[] v = {10,40,30,50};
        System.out.println(new Solution01().knapsack(w, v, 10));
        System.out.println("count of bestValue() exec：" + count);
        PrintHelper.print2DArray(memo);
    }
}
```

##### （2）动态规划

<img src="assets/image-20200602212425200.png" alt="image-20200602212425200" style="zoom: 62%;" />



```java
/**
 * 动态规划
 * 时间复杂度: O(n * C) 其中n为物品个数; C为背包容积
 * 空间复杂度: O(n * C)
 */
public class Solution02 {
    public int knapsack(int[] w, int[] v, int C) {
        int n = w.length;
        int[][] memo = new int[n][C + 1];

        if (n == 0 || C == 0)
            return 0;

        for (int j = 0; j <= C; j++)
            memo[0][j] = (j >= w[0] ? v[0] : 0);

        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= C; j++) {
                memo[i][j] = memo[i - 1][j];
                if (j >= w[i]) {
                    memo[i][j] = max(memo[i][j], v[i] + memo[i - 1][j - w[i]]);
                }
            }
        }

        return memo[n - 1][C];
    }

    private int max(int a, int b) {
        return a > b ? a : b;
    }


    public static void main(String[] args) {
        int[] w = {1, 2, 3};
        int[] v = {6, 10, 12};
        int C = 5;
        System.out.println(new Solution02().knapsack(w, v, C));
    }
}

```

##### （3）动态规划优化思路1

优化思路：第i行元素只依赖于第i-1行元素，理论上，只需要保持两行元素即可

<img src="assets/image-20200602212523028.png" alt="image-20200602212523028" style="zoom: 33%;" />

```java
/// 动态规划改进: 滚动数组
/// 时间复杂度: O(n * C) 其中n为物品个数; C为背包容积
/// 空间复杂度: O(C), 实际使用了2*C的额外空间
public class Solution1 {

    public int knapsack01(int[] w, int[] v, int C){

        if(w == null || v == null || w.length != v.length)
            throw new IllegalArgumentException("Invalid w or v");

        if(C < 0)
            throw new IllegalArgumentException("C must be greater or equal to zero.");

        int n = w.length;
        if(n == 0 || C == 0)
            return 0;

        int[][] memo = new int[2][C + 1];

        for(int j = 0 ; j <= C ; j ++)
            memo[0][j] = (j >= w[0] ? v[0] : 0);

        for(int i = 1 ; i < n ; i ++)
            for(int j = 0 ; j <= C ; j ++){
                memo[i % 2][j] = memo[(i-1) % 2][j];
                if(j >= w[i])
                    memo[i % 2][j] = Math.max(memo[i % 2][j], v[i] + memo[(i-1) % 2][j - w[i]]);
            }

        return memo[(n-1) % 2][C];
    }
}
```

##### （4）动态规划优化思路2

<img src="assets/image-20200602212544715.png" alt="image-20200602212544715" style="zoom:50%;" />

```java
/// 动态规划改进
/// 时间复杂度: O(n * C) 其中n为物品个数; C为背包容积
/// 空间复杂度: O(C), 只使用了C的额外空间
public class Solution2 {

    public int knapsack01(int[] w, int[] v, int C){

        if(w == null || v == null || w.length != v.length)
            throw new IllegalArgumentException("Invalid w or v");

        if(C < 0)
            throw new IllegalArgumentException("C must be greater or equal to zero.");

        int n = w.length;
        if(n == 0 || C == 0)
            return 0;

        int[] memo = new int[C+1];

        for(int j = 0 ; j <= C ; j ++)
            memo[j] = (j >= w[0] ? v[0] : 0);

        for(int i = 1 ; i < n ; i ++)
            for(int j = C ; j >= w[i] ; j --)
                memo[j] = Math.max(memo[j], v[i] + memo[j - w[i]]);

        return memo[C];
    }
}
```

##### （5）背包问题更多变种

- **多重背包问题**：每个物品不不⽌1个，有 num(i) 个
- **完全背包问题**：每个物品可以⽆无限使⽤用
- **多维费用背包问题**：要考虑物品的体积和重量量两个维度？
- **物品间加入更更多约束**：物品间可以互相排斥；也可以互相依赖



#### 最长上升子序列

##### 1. 题目

**Longest Increasing Subsequence (LIS)**

**【Leetcode 300】最长上升子序列** 

给定一个无序的整数数组，找到其中最长上升子序列的长度。

**示例:**

```
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```

**说明:**

- 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
- 你算法的时间复杂度应该为 O(*n2*) 。

**进阶:** 你能将算法的时间复杂度降低到 **O(*n* log *n*)** 吗?

##### 2. 题解

LIS( i ) 表示以**第 i 个数字为结尾**的最长上升子序列的长度。

LIS( i ) 表示 [0...i] 的范围内，选择数字 nums[i] 可以获得的最长上升子序列的长度。

LIS ( i )  =   max<sub>j<i</sub>( 1 + LIS( j ) if nums[i] > nums[j] )。

```java
public class Solution {

    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        }

        int res = 1;
        int[] memo = new int[n];
        // 全部填充为1
        Arrays.fill(memo, 1);

        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i])
                    memo[i] = max(memo[i] , memo[j] + 1);
            }
        }

        for(int i = 0; i < n; i++){
            res = max(memo[i], res);
        }
        return res;
    }

    private int max(int a, int b) {
        return a > b ? a : b;
    }

    public static void main(String[] args) {
        int[] arr = {10, 9, 2, 5, 3, 7, 101, 18};
        System.out.println(new Solution().lengthOfLIS(arr));
    }
}
```

这里思考一个问题：在上面的代码中只求**解出了上升子序列的长度**，那么如何求出具体的上升子序列呢？

```java
public class Solution2 {
    // 记录一下有几个上升子序列
    private static List<Integer> LISindex = new ArrayList<>(); 

    public List<List<Integer>> lengthOfLIS(int[] nums) {
        List<List<Integer>> resList = new ArrayList<>();
        int n = nums.length;
        if (n == 0) {
            return null;
        }

        int res = 1;
        int[] memo = new int[n];

        Arrays.fill(memo, 1);

        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i])
                    memo[i] = max(memo[i], memo[j] + 1);
            }
        }

        for (int i = 0; i < n; i++) {
            res = max(memo[i], res);
        }

        for (int i = 0; i < n; i++) {
            if (memo[i] == res)
                // 遍历一下最长子序列最后一位是谁，统计一共有多少个子序列
                LISindex.add(i); 
        }

        for (int lastIndex : LISindex) {
            ArrayList<Integer> list = new ArrayList<>();
            int nowMemoCount = memo[lastIndex];

            for (int i = lastIndex; i >= 0; i--) {
                if (nowMemoCount - memo[i] == 1 || nowMemoCount - memo[i] == 0) {
                    list.add(nums[i]);
                    nowMemoCount--;
                }
            }
            resList.add(reverseList(list));
        }

        return resList;
    }

    private int max(int a, int b) {
        return a > b ? a : b;
    }

    private List<Integer> reverseList(ArrayList<Integer> list) {
        List<Integer> newList = new ArrayList<>();
        for (int i = list.size() - 1; i >= 0; i--) {
            newList.add(list.get(i));
        }
        return newList;
    }

    public static void main(String[] args) {
        int[] arr = {10, 9, 2, 5, 3, 7, 101, 18};
        System.out.println(new Solution2().lengthOfLIS(arr));
    }
}
```



#### 最长公共子序列

##### 1. 题目

**Longest Common Sequence (LCS)**：给出两个字符串 S1 和 S2，求这两个字符串的最长公共子序列的长度。

LCS( m , n ) S1[0…m] 和 S2[0…n] 的最长公共子序列的长度。

**S1[m] == S2[n] :**  

LCS(m,n) = 1 + LCS(m-1,n-1) 

**S1[m] != S2[n] :**   

LCS(m,n) = max( LCS(m-1,n) , LCS(m,n-1) )

<img src="assets/image-20200602213301308.png" alt="image-20200602213301308" style="zoom:57%;" />

```java
/**
 * 最长公共子序列
 */
public class Solution3 {

    public int LCS(String s1, String s2) {
        return bestLength(s1, s2, s1.length() - 1, s2.length() - 1);
    }

    public int bestLength(String s1, String s2, int m, int n) {
        if (m < 0 || n < 0)
            return 0;
        int lcs = 0;
        if (s1.charAt(m) == s2.charAt(n)) {
            lcs = 1 + bestLength(s1, s2, m - 1, n - 1);
        } else {
            lcs = max(bestLength(s1, s2, m - 1, n), bestLength(s1, s2, m, n - 1));
        }
        return lcs;
    }

    private int max(int a, int b) {
        return a > b ? a : b;
    }

    public static void main(String[] args) {
        System.out.println(new Solution3().LCS("ABCDEE", "ABDCEE"));
    }
}
```



#### 打家劫舍【简单】

##### 1. 题目

你是一个专业的小偷，计划偷窃**沿街**的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果**两间相邻的房屋在同一晚上被小偷闯入**，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，**一夜之内能够偷窃到的最高金额**。

```java
示例 1：

输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 2：

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```


链接：https://leetcode-cn.com/problems/house-robber

##### 2. 题解

定义 **dp 数组**用来存储**最大的抢劫量**，其中 dp[i] 表示抢到**第 i 个住户时**的最大抢劫量。

由于不能抢劫邻近住户，如果抢劫了第 i -1 个住户，那么就不能再抢劫第 i 个住户，所以

<img src="assets/1563524592350.png" alt="1563524592350" style="zoom:67%;" />

```java
public int rob(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    if (nums.length == 1) {
        return nums[0];
    }
    int[] dp = new int[nums.length];
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]);

    for(int i = 2; i < nums.length; i++) {
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
    }
    return dp[dp.length - 1];
}
```

由于是可以进行滚动计算的，所以不需要 dp 这么大的空间，类似斐波那契数列，可以优化如下。

```java
public int rob2(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int length = nums.length;
    if (length == 1) {
        return nums[0];
    }
    int slow = nums[0], fast = Math.max(nums[0], nums[1]);
    for (int i = 2; i < length; i++) {
        int temp = fast;
        fast = Math.max(slow + nums[i], fast);
        slow = temp;
    }
    return fast;
}
```

#### 打家劫舍II【中等】

##### 1. 题目

题目跟上题一样，只不过条件改成**所有的房屋都围成一圈**。

```java
示例 1:
输入: [2,3,2]
输出: 3
解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
    
示例 2:
输入: [1,2,3,1]
输出: 4
解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

链接：https://leetcode-cn.com/problems/house-robber-ii

##### 2. 题解

**环状排列**意味着**第一个房子和最后一个房子**中只能**选择一个**偷窃，因此可以把此环状排列房间问题**约化为两个单排排列房间子问题**：

- 在**不偷窃第一个房子**的情况下（即 nums[1:]），最大金额是 P1；
- 在**不偷窃最后一个房子**的情况下（即 nums[:n-1]），最大金额是 P2。
- 综合偷窃最大金额： 为以上两种情况的较大值，即 **max(p1, p2)**。

```java
public int rob(int[] nums) {
    // Base case
    if (nums == null || nums.length == 0) return 0;
    int len = nums.length;
    if (len == 1) return nums[0];
    // 不偷窃第一个房子和不偷窃最后一个房子取较大值
    return Math.max(normalRob(nums, 0, len - 2), normalRob(nums, 1, len - 1));
}


// 指定范围的打家劫舍
private int normalRob(int[] nums, int firstRob, int lastRob) {
    int pre2 = 0, pre1 = 0;
    for (int i = firstRob; i <= lastRob; i++) {
        int cur = Math.max(pre1, pre2 + nums[i]);
        pre2 = pre1;
        pre1 = cur;
    }
    return pre1;
}
```

#### 除数博弈【简单】

##### 1. 题目

爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。最初，黑板上有一个**数字 N** 。在每个玩家的回合，玩家需要执行以下操作：

- 选出任一 x，满足 0 < x < N 且 **N % x == 0** 。
- 用 **N - x 替换**黑板上的数字 N 。

如果玩家无法执行这些操作，就会输掉游戏。只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以**最佳状态**参与游戏。

```java
示例 1：
输入：2
输出：true
解释：爱丽丝选择 1，鲍勃无法进行操作。
    
示例 2：
输入：3
输出：false
解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。
```


链接：https://leetcode-cn.com/problems/divisor-game

##### 2. 题解

###### (1) 归纳法

观察：谁先从 2 的基础减去 1 谁胜。统计**能取模的次数**，**次数为奇数则 Alice 赢，返回 true**。

- 最终结果应该是占到 2 的赢，占到 1 的输；
- 若当前为奇数，奇数的约数只能是奇数或者 1，因此下一个一定是偶数；
- 若当前为偶数， 偶数的约数可以是奇数可以是偶数也可以是 1，因此直接减 1，则下一个是奇数；
- 因此，奇则输，偶则赢。

直接写出：

```java
public boolean divisorGame(int N) {
    return N % 2 == 0;
}
```

###### (2) 动态规划法

基本思路：

将所有的**小于等于 N 的解**都找出来，基于前面的，递推后面的。

状态转移: 如果 **i 的约数**里面有存在为 False 的（即输掉的情况），则当前 i 应为 True；如果没有，则为 False。

求出**所有 3-N** 的因子，比较大小：

- 若得 0（即**可以给别人一个 0**），说明拿到该值**必胜**，将该值转化为 1；

- 若得 1（即**必须给别人一个 1**），说明拿到该值**必输**，将该值转化为 0；

补充：为了让dp[i] 的 i 与 N 对应，给不会出现的 dp[0] 和 dp[1] 一个极大值；

```java
public boolean divisorGame(int N) {
    if (N == 1) return false;
    if (N == 2) return true;
    boolean[] dp = new boolean[N + 1];
    dp[1] = false;
    dp[2] = true;
    for (int i = 3; i <= N; i++) {
        for (int j = 1; j < i; j++) {
            if (i % j == 0 && !dp[i - j]) {
                dp[i] = true;
                break;
            }
        }
    }
    return dp[N];
}
```

#### 买卖股票的最佳时机【简单】

##### 1. 题目

给定一个**数组**，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多**只允许完成一笔交易**（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。注意：你不能在买入股票前卖出股票。

```java
示例 1:
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
    
示例 2:
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock

##### 2. 题解

使用贪心策略，假设第 i 轮进行卖出操作，买入操作价格应该在 i **之前并且价格最低**。

<img src="assets/image-20200707171814356.png" alt="image-20200707171814356" style="zoom:67%;" />

```java
public int maxProfit(int prices[]) {
    // 最小价格
    int minPrice = Integer.MAX_VALUE;
    // 记录最大利润
    int maxProfit = 0;
    // 遍历更新这个值
    for (int i = 0; i < prices.length; i++) {
        // 更新最小价格
        if (prices[i] < minPrice) {
            minPrice = prices[i];
        } else if (prices[i] - minPrice > maxProfit) {
            // 更新最大利润
            maxProfit = prices[i] - minPrice;
        }
    }
    return maxProfit;
}

```



#### 使用最小花费爬楼梯【简单】

##### 1. 题目

数组的每个索引作为一个阶梯，**第 i 个阶梯**对应着一个非负数的体力花费值 **cost\[i]** (索引从 0 开始)。每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。您需要找到达到楼层**顶部**的最低花费。在开始时，你可以选择从**索引为 0 或 1 的元素**作为**初始阶梯**。

```java
示例 1:
输入: cost = [10, 15, 20]
输出: 15
解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。
示例 2:
输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出: 6
解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。
```

链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs

##### 2. 题解

###### (1) 动态规划法

dp[i] 意为爬到第 i 级需要的**最小**花费。

题意中的**第 0 级和第 1 级**是不需要花费体力即可到达的（见题目示例 1，可直接从 cost[1] 开始，即到达第 1 级**不需要**花费）。即 **dp[0] = 0; dp[1] = 0**。
对于爬到第i级需要的最小体力，可以选择从第 i - 1 级往上爬一步到达，也可以选择从第 i - 2 级往上爬两步到达。前者需要的体力等于爬到第 i - 1 级需要的最小体力 dp[i - 1] 再加上从第 i - 1 级往上爬要耗费的体力 cost[i - 1]，同理我们也可以得到后者需要的体力，这两者的较小者就是爬到第 i 级需要的最小体力。因此可得状态转移方程：

```java
dp[i] = Math.min(dp[i-2] + cost[i-2], dp[i-1] + cost[i-1]);
```

```java
public int minCostClimbingStairs(int[] cost) {
    // dp[0] dp[1] 默认为0
    int[] dp = new int[cost.length + 1];
    for(int i = 2; i < dp.length; i++) {
        // 选择一步到达或者两步到达的较小值
        dp[i] = Math.min(dp[i - 2] + cost[i - 2], dp[i - 1] + cost[i - 1]);
    }
    return dp[dp.length - 1];
}
```

这里也可以优化空间。

```java
public int minCostClimbingStairs2(int[] cost) {
    int f1 = 0, f2 = 0;
    for (int i = 0; i < cost.length; i++) {
        int minCost = cost[i] + Math.min(f1, f2);
        f1 = f2;
        f2 = minCost;
    }
    return Math.min(f1, f2);
}
```



