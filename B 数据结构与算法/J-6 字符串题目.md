[TOC]

### 字符串题目

#### 最长回文子串【中等】

##### 1. 题目

给定一个**字符串 s**，找到 s 中最长的**回文子串**。你可以假设 s 的最大长度为 1000。

**示例 1：**

```java
输入: "babad"
输出: "bab"
```

注意: "aba" 也是一个有效答案。
**示例 2：**

```java
输入: "cbbd"
输出: "bb"
```


链接：https://leetcode-cn.com/problems/longest-palindromic-substring

##### 2. 题解

###### (1) 中心扩展算法

**面试**记住这个是好理解的。回文串一定是**对称**的，所以可以**每次循环选择一个中心**，进行左右扩展，判断**左右字符是否相等**即可。

<img src="assets/image-20200518162857470.png" alt="image-20200518162857470" style="zoom:50%;" />

每个位置向两边扩散都会出现一个窗口大小（len）。如果 len>maxLen(用来表示最长回文串的长度）。则更新 maxLen 的值。因为最后要返回的是具体子串，而不是长度，因此，还需要记录一下 maxLen 时的起始位置（maxStart），即此时还要 maxStart=len。

```java
public String longestPalindrome1(String str) {

    if (str == null || str.length() == 0) return "";
    int strLen = str.length();
    int left = 0;
    int right = 0;
    int len = 1;
    int maxStart = 0;
    int maxLen = 0;

    // 从左到右以每个元素为中心判断
    for (int center = 0; center < strLen; center++) {
        left = center - 1;
        right = center + 1;
        // 首先是以当前位置及其左边或者右边同时为中心进行扩散
        while (left >= 0 && str.charAt(left) == str.charAt(center)) {
            len++;
            left--;
        }
        while (right < strLen && str.charAt(right) == str.charAt(center)) {
            len++;
            right++;
        }
        // 以当前center为中心扩散
        while (left >= 0 && right < strLen && str.charAt(right) == str.charAt(left)) {
            // 长度+2
            len = len + 2;
            left--;
            right++;
        }
        // 如果发现最大长度就更新
        if (len > maxLen) {
            maxLen = len;
            maxStart = left;
        }
        // 重置最大长度
        len = 1;
    }
    return str.substring(maxStart + 1, maxStart + maxLen + 1);
}
```

优化：中心扩散的方法，其实做了很多**重复计算**。动态规划就是为了**减少重复计算**的问题。动态规划听起来很高大上。其实说白了就是空间换时间，将计算结果暂存起来，避免重复计算。

用一个 boolean **dp\[l][r] 表示字符串从 i 到 j 这段是否为回文**。试想如果 **dp\[l][r]=true**，要判断 dp\[l-1][r+1] 是否为回文。只需要判断字符串在(l-1)和（r+1)两个位置是否为相同的字符，就减少了很多重复计算。
进入正题，动态规划关键是找到初始状态和状态转移方程。

- **初始状态**，l = r 时，此时 **dp\[l][r]=true**。
- **状态转移方程**，dp\[l][r]=true 并且 (l-1) 和（r+1) 两个位置为相同的字符，此时 **dp\[l-1][r+1]=true**。

```java
public String longestPalindrome3(String str) {
    if (str == null || str.length() < 2) return str;
    // 字符串长度
    int strLen = str.length();
    int maxStart = 0;  // 最长回文串的起点
    int maxEnd = 0;    // 最长回文串的终点
    int maxLen = 1;    // 最长回文串的长度
    // dp数组
    boolean[][] dp = new boolean[strLen][strLen];

    for (int right = 1; right < strLen; right++) {
        for (int left = 0; left < right; left++) {
            // 状态转移方程
            if (str.charAt(left) == str.charAt(right) && (right - left <= 2 || dp[left + 1][right - 1])) {
                dp[left][right] = true;
                // 更新结果
                if (right - left + 1 > maxLen) {
                    maxLen = right - left + 1;
                    maxStart = left;
                    maxEnd = right;
                }
            }
        }
    }
    // 根据索引找到最长回文字符串
    return str.substring(maxStart, maxEnd + 1);
}
```

###### (2) 动态规划

首先定义：字符串 s 从**下标 i 到下标 j 的字串为 P(i, j)**，若 s 从下标 i 到下标 j 的字串为**回文串**，则 P(i, j) = **true**，否则 P(i, j) = **false**。如下图所示：

<img src="assets/image-20200518161941687.png" alt="image-20200518161941687" style="zoom:70%;" />

则 **P(i, j) = (P(i + 1, j - 1) && s[i] == s[j])**。如下图所示。

所以如果想知道 **P（i, j）**的情况，不需要调用判断回文串的函数了，只需要**知道 P（i+1，j−1）的情况**就可以了，这样时间复杂度就少了 O(n)。因此可以用动态规划的方法，空间换时间，把已经**求出的 P（i，j）存储**起来。

<img src="assets/image-20200518162014027.png" alt="image-20200518162014027" style="zoom:80%;" />

如果 **s[i+1, j-1] 是回文串，那么只要 s[i] == s[j]，就可以确定 s[i, j] 也是回文串了。**

注意：求长度为 1 和长度为 2 的 P(i, j) 时**不能**用上边的公式，因为代入公式后会遇到 P\[i][j] 中 i > j 的情况，比如求P\[1][2] 的话，需要知道 P\[1+1][2-1]=P\[2][1] ，而 P\[2][1] 代表着 S[2, 1] 是不是回文串，这显然是不对的，所以需要单独判断。

所以先初始化长度是 **1** 的回文串的 P [i , j]，这样利用上边提出的公式 P(i, j) = (P(i + 1, j - 1) && S[i] == S[j])，然后两边向外**各扩充一个字符**，长度为 3 的，为 5 的，所有**奇数长度**的就都求出来了。同理，**初始化长度是 2** 的回文串 P[i,i+1]，利用公式，长度为 4 的，6 的所有**偶数长度**的就都求出来了。

```java
public static String longestPalindrome(String s) {
    int sLen = s.length();
    int maxLen = 0;
    String ans = "";
    boolean[][] P = new boolean[sLen][sLen];
    // 遍历所有长度
    for (int len = 1; len <= sLen; len++) {
        for (int start = 0; start < sLen; start++) {
            int end = start + len - 1;
            // 下标越界，结束循环
            if (end >= sLen) {
                break;
            }
            P[start][end] = (len == 1 || len == 2 || P[start + 1][end - 1]) && s.charAt(start) == s.charAt(end);
            if (P[start][end] && len > maxLen) {
                maxLen = len;
                ans = s.substring(start, end + 1);
            }
        }
    }
    return ans;
}
```

时间复杂度：两层循环 O(n²）。

空间复杂度：用二维数组 P 保存每个子串的情况 O(n²)。

下面分析空间使用情况：（以”babad“为例）

<img src="assets/image-20200518162131938.png" alt="image-20200518162131938" style="zoom:60%;" />

当我们求长度为 5  的子串的情况时，其实只用到了 4 长度的情况，而长度为 1 和 2  和 3 的子串情况其实已经不需要了。

但是由于我们并不是用 P 数组的下标进行的循环，暂时没有想到优化的方法。

那么我们换种思路，公式不变：

其实从递推公式中我们可以看到，我们首先知道了 i +1 才会知道 i ，所以我们只需要倒着遍历就行了。

###### (3) Manacher 算法

这个以后补充。