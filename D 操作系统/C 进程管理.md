[TOC]

### 进程管理

#### 进程与线程

##### 1. 进程

进程是==**资源分配**==的基本单位。下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。

<img src="assets/1563375046921.png" alt="1563375046921" style="zoom:60%;" />

##### 2. 线程

线程是==**独立调度**==的基本单位。一个进程中可以有多个线程，它们**共享**进程资源。 如 QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。

线程可以分为**用户级线程和内核线程**。

<img src="assets/1563375068949.png" alt="1563375068949" style="zoom:69%;" />

##### 3. 进程与线程区别

在 Linux 系统中，进程和线程几乎没有区别。

###### (1) 资源与调度

**进程是==资源分配==的基本单位**，但是线程**不拥有**资源，线程可以访问隶属进程的资源。

**线程是==独立调度==的基本单位**，在**同一进程**中，线程的切换**不会引起进程切换**，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

**进程有自己独立的地址空间**，每启动一个进程，系统都会为其分配地址空间，建立数据表来维护代码段、堆栈段和数据段；**线程没有独立的地址空间**，它使用相同的地址空间共享数据。

###### (2) 系统开销

**进程在创建、撤销、切换时的开销远大于线程。**

由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销**远大于**创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而**线程切换**时只需保存和设置少量**寄存器**内容，**开销很小**。

###### (3) 通信方面

线程间可以通过**直接读写同一进程**中的**数据**进行通信，但是**进程通信需要借助 IPC**（Inter-Process Communication，进程间通信）。

###### (4) 其他

每个**线程**都有一个**程序计数器**（记录要执行的下一条指令）、一组寄存器（保存当前线程的工作变量）、堆栈（记录执行历史）。

##### 4. 协程

协程（Coroutines）是一种**比线程更加轻量级的存在**，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。

协程不是被操作系统内核所管理的，而是完全由程序所控制，也就是在用户态执行。这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。

协程不是进程也不是线程，而是一个特殊的函数，这个函数可以在某个地方挂起，并且可以重新在挂起处外继续运行。所以说，协程与进程、线程相比并不是一个维度的概念。

上下文切换：协程的切换者是用户（编程者或应用程序），切换时机是用户自己的程序所决定的。协程的切换内容是硬件上下文，切换内存保存在用户自己的变量（用户栈或堆）中。协程的切换过程只有用户态，即没有陷入内核态，因此切换效率高。

##### 5. Linux中的进程与线程

Linux 中线程和进程**基本没有区别**，因为Linux 内核并没有把线程和进程区别对待。

系统调用 **fork()** 可以新建一个**子进程**，函数 **pthread()** 可以**新建一个线程**。但无论线程还是进程，都是用 **task_struct 结构**表示的，**唯一的区别就是共享的数据区域不同**。线程看起来跟进程没有区别，只是**线程的某些数据区域和其父进程是共享的，而子进程是拷贝副本，而不是共享**。就比如说 **mm 结构和 files 结构**在线程中都是共享的。

**进程与子进程**：

<img src="assets/7.jpg" style="zoom:33%;" />

**进程与线程**：

<img src="assets/8.jpg" style="zoom:33%;" />

所以**多线程**程序要利用锁机制，避免多个线程同时往同一区域写入数据，否则可能造成数据错乱。

注意：只有 Linux 系统将线程看做共享数据的进程，不对其做特殊看待，其他的很多操作系统是对线程和进程区别对待的，线程有其特有的数据结构。

对于新建进程时**内存区域拷贝**的问题，Linux 采用了 **copy-on-write 的策略优化**，也就是并不真正复制父进程的内存空间，而是等到**需要写操作时才去复制**。**所以 Linux 中新建进程和新建线程都是很迅速的**。

#### 进程描述符

##### 1. 进程控制块

**进程控制块** (Process Control Block, PCB) 描述进程的**基本信息和运行状态**，所谓的创建进程和撤销进程，都是指对 PCB 的操作。一个简化版本的进程控制块如下。

<img src="assets/image-20191229205629521.png" alt="image-20191229205629521" style="zoom:50%;" />

##### 2. 进程描述符

用户编译好的那个可执行程序只是一个**文件**，不是进程，**可执行文件必须要载入内存**，包装成一个进程才能真正跑起来。**进程是要依靠操作系统创建的，每个进程都有它的固有属性，比如进程号（PID）、进程状态、打开的文件等等，进程创建好之后**，读入程序之后才被系统执行。

那么，操作系统是如何创建进程的？**对于操作系统，进程就是一个数据结构**，Linux 的部分源码如下：

```cpp
struct task_struct {
    // 进程状态
    long state;
    // 虚拟内存结构体
    struct mm_struct *mm;
    // 进程号
    pid_t pid;
    // 指向父进程的指针
    struct task_struct __rcu *parent;
    // 子进程列表
    struct list_head children;
    // 存放文件系统信息的指针
    struct fs_struct *fs;
    // 一个数组，包含该进程打开的文件指针
    struct files_struct *files;
    //....
};
```

**task_struct** 就是 Linux 内核对于一个进程的描述，也可以称为「**进程描述符**」。其中比较有意思的是 **mm 指针和 files 指针**。mm 指向的是进程的**虚拟内存**，也就是**载入资源和可执行文件**的地方； files 指针指向一个**数组**，这个数组里装着**所有该进程打开的文件的指针**。

##### 3. 文件描述符

前面的 files 是一个**文件指针数组**。一般来说一个进程会**从 files[0] 读取输入**，将**输出写入 files[1]**，将**错误信息写入 files[2]**。

举个例子，C 语言的 **printf** 函数是向命令行打印字符，但是从进程的角度来看，就是向 **files[1] 写入数据**；同理 scanf 函数就是进程试图从 files[0] 这个文件中读取数据。

每个进程被创建时，**files 指针数组的前三位被填入默认值，分别指向标准输入流、标准输出流、标准错误流**。常说的「**文件描述符**」就是**指这个文件指针数组的索引**，所以程序的文件描述符默认情况下 0 是输入，1 是输出，2 是错误。见下图（来自 labuladong）。

<img src="assets/2.jpg" style="zoom:43%;" />

Linux 中**一切都被抽象成文件**，设备也是文件，可以进行读和写。一般计算机中输入流是**键盘**，输出流是**显示器**，错误流也是**显示器**，所以现在这个进程和内核连了三根线。因为硬件都是由内核管理的，进程需要通过「**系统调用**」让内核进程访问硬件资源。

如果写的程序需要其他资源，比如**打开一个文件进行读写**，这也很简单，**进行系统调用，让内核把文件打开**，这个文件就**会被放到 files 指针数组的第 4 个位置**：

<img src="assets/3.jpg" style="zoom:40%;" />

到这里**输入重定向**就很好理解了，程序想读取数据的时候就会去 **files[0]** 读取，所以只要把 **files[0] 指向一个文件**，那么程序就会从这个文件中读取数据，而不是从键盘。

<img src="assets/5.jpg" style="zoom:39%;" />

同理**输出重定向**就是把 files[1] 指向**一个文件**，那么程序的输出就不会写入到显示器，而是写入到这个文件中。

<img src="assets/4.jpg" style="zoom:39%;" />

**管道符**其实也是异曲同工，把一个进程的输出流和另一个进程的输入流接起一条「管道」，数据就在其中传递。

<img src="assets/6.jpg" style="zoom:39%;" />

不管是设备、另一个进程、socket 套接字还是真正的文件，全部都可以读写，**统一装进一个简单的 files 数组**，进程通过简单的**文件描述符访问相应资源**，具体细节交于操作系统，有效解耦，优美高效。







#### 进程状态

##### 1. 五状态模型

<img src="assets/image-20191229210529060.png" alt="image-20191229210529060" style="zoom:60%;" />

- **就绪状态**（ready）：等待被调度
- **运行状态**（running）
- 阻塞状态（waiting）：等待资源

应该注意以下内容：

- 只有**就绪态和运行态**可以**相互转换**，其它的都是**单向转换**。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。

##### 2. 进程创建

当一个新进程被创建时，操作系统需要在**进程列表**中为它创建一个与其他进程格式相同的**数据结构**用于记录和管理它的状态。通常有四种事件会导致进程的创建：

|               事件               |                             说明                             |
| :------------------------------: | :----------------------------------------------------------: |
|        **新的批处理**作业        | 通常位于磁带或者磁盘中的批处理作业控制流程被提供给操作系统。当操作系统准备接纳新工作时，它将读取下一个作业控制命令 |
|           **交互登陆**           |                      终端用户登录到系统                      |
| 操作系统因为提供一项服务而被创建 | 操作系统可以创建一个进程，代表用户程序执行的一个功能，使用户无需等待(如控制打印机的进程) |
|       由现有的进程**派生**       | 基于模块化的考虑，或者为了开发并行性，用户程序可以指示创建多个进程 |

当操作系统为另一个进程显式的请求创建一个新进程时，这个动作被称为**进程派生**。当一个进程派生另一个进程的时候，前一个称作**父进程**，被派生的叫做**子进程**。在大多数情况下，父子进程间需要进行通信和合作。

##### 3. 进程结束

**进程结束**的典型原因如下。

![image-20191229210049464](assets/image-20191229210049464.png)



#### 进程调度算法

**不同操作系统**的调度算法**目标不同**，因此需要针对**不同系统环境**来讨论调度算法。

##### 1. 批处理系统

**批处理系统**没有太多的用户操作，在该系统中，调度算法目标是**保证吞吐量和周转时间**（从提交到终止的时间）。

###### (1) 先来先服务first-come first-serverd（FCFS）

按照**请求的顺序**进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，可能造成**短作业等待时间过长**。

###### (2) 短作业优先shortest job first（SJF）

按估计运行时间**最短**的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

###### (3) 最短剩余时间优先shortest remaining time next（SRTN）

按估计**剩余时间最短**的顺序进行调度。

##### 2. 交互式系统

交互式系统有**大量的用户交互操作**，在该系统中调度算法的目标是**快速地进行响应**。

###### (1) 时间片轮转算法

将所有就绪进程按 **FCFS** (**先来先服务**)的原则排成一个**队列**，每次调度时，把 CPU 时间分配给**队首进程**，该进程可以执行一个**时间片**。当时间片用完时，由计时器发出时钟**中断**，调度程序便**停止**该进程的执行，并将它送往**就绪队列的末尾**，同时继续把 CPU 时间分配给**队首**的进程。

时间片轮转算法的效率和**时间片的大小**有很大关系：

- 因为**进程切换**都要**保存进程的信息**并且载入新进程的信息，如果时间片太小，会导致**进程切换得太频繁**，在进程切换上就会花过多时间。
- 而如果**时间片过长**，那么**实时性**就不能得到保证。

<img src="assets/1563375145745.png" alt="1563375145745" style="zoom:80%;" />

###### (2) 优先级调度算法

为**每个进程**分配一个**优先级**，按优先级进行调度。为了防止低优先级的进程**永远等不到调度**，可以随着**时间的推移增加等待进程的优先级**。

###### (3) 多级反馈队列算法

一个进程需要执行 **100** 个时间片，如果采用**时间片轮转调度**算法，那么需要**交换 100 次**。

**多级队列**是为这种需要**连续执行多个时间片**的进程考虑，它设置了**多个队列**，**每个队列时间片大小都不同**，例如 **1, 2, 4, 8** ,..。进程在**第一个队列没执行完**，就会被移到**下一个队列**。这种方式下，之前的进程只需要交换 7 次。

**新就绪**的进程总是进入**最高优先级队列的队尾**，并按 FCFS 原则等待调度；当轮到该进程执行时，若它能在规定的时间片内**完成**，便可准备撤离系统，否则将其转入**第二级队列末尾**，再同样按 FCFS 原则等待调度；如果它在第二级队列上运行一个时间片后**仍未完成**，再依次将它转入第**三级队列**，……，如此下去，当一个长作业从第一级队列降到最后一级队列时，便在该队列中**采取 RR 算法**运行。

每个**队列优先权**也不同，最**上面的优先权最高**。因此只有**上一个队列没有进程在排队**，才能调度**当前队列**上的进程。

可以将这种调度算法看成是**时间片轮转调度算法和优先级调度算法**的**==结合==**。

<img src="assets/1563375163679.png" alt="1563375163679" style="zoom:80%;" />

**UNIX** 操作系统采取的便是这种调度算法。

##### 3. 实时操作系统

实时系统要求一个请求在一个确定时间内得到响应。比如 **UCOSII**。分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。



#### 进程同步

进程同步即控制**多个进程**按一定**顺序**执行。

##### 1. 临界区

对**临界资源**进行访问的那段代码称为**临界区**。为了**互斥访问临界资源**，每个进程在进入临界区之前，需要先进行**检查**。

```html
// entry section
// critical section;
// exit section
```

##### 2. 同步与互斥

- **同步**：多个进程按一定**顺序**执行。
- **互斥**：多个进程在同一时刻只有**一个进程**能进入临界区。

##### 3. 信号量

**信号量**（Semaphore）是一个**整型变量**，可以对其执行 **down 和 up** 操作，也就是常见的 **P 和 V** 操作。

-  **down**  : 如果信号量**大于 0** ，执行 -1 操作；如果信号量**等于 0**，进程**睡眠**，等待信号量大于 0；
-  **up** ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。

down 和 up 操作需要被设计成**原语**，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。

如果信号量的取值**只能为 0 或者 1**，那么就成为了 **互斥量（Mutex）** ，**0 表示临界区已经加锁，1 表示临界区解锁**。

```c
typedef int semaphore;
semaphore mutex = 1;
void P1() {
    down(&mutex);
    // 临界区
    up(&mutex);
}

void P2() {
    down(&mutex);
    // 临界区
    up(&mutex);
}
```

**使用==信号量==实现生产者-消费者问题**

问题描述：使用一个**缓冲区**来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。

因为缓冲区属于**临界资源**，因此需要使用一个**互斥量 mutex** 来控制对缓冲区的互斥访问。为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。**数量可以使用信号量**来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。

注意，**不能先对缓冲区进行加锁，再测试信号量**。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会**永远等待**下去。

```c
#define N 100
typedef int semaphore;	// semaphore 信号量
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer() {
    while(TRUE) {
        int item = produce_item();
        down(&empty);
        down(&mutex);
        insert_item(item);
        up(&mutex);
        up(&full);
    }
}

void consumer() {
    while(TRUE) {
        down(&full);
        down(&mutex);
        int item = remove_item();
        consume_item(item);
        up(&mutex);
        up(&empty);
    }
}
```

##### 4. 管程

使用**信号量**机制实现的**生产者消费者**问题需要客户端代码做很多控制，而**管程把控制的代码独立出来**，不仅不容易出错，也使得客户端代码调用更容易。

**c 语言不支持管程**，下面的示例代码使用了类 **Pascal** 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。

```pascal
monitor ProducerConsumer
    integer i;
    condition c;

    procedure insert();
    begin
        // ...
    end;

    procedure remove();
    begin
        // ...
    end;
end monitor;
```

管程有一个重要特性：**在一个时刻只能有一个进程使用管程**。进程在无法继续执行的时候**不能一直占用管程**，否则其它进程永远不能使用管程。

管程引入了 **条件变量** 以及相关的操作：**wait()** 和 **signal()** 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。

**使用==管程==实现生产者-消费者问题：**

```pascal
// 管程
monitor ProducerConsumer
    condition full, empty;
    integer count := 0;
    condition c;

    procedure insert(item: integer);
    begin
        if count = N then wait(full);
        insert_item(item);
        count := count + 1;
        if count = 1 then signal(empty);
    end;

    function remove: integer;
    begin
        if count = 0 then wait(empty);
        remove = remove_item;
        count := count - 1;
        if count = N -1 then signal(full);
    end;
end monitor;

// 生产者客户端
procedure producer
begin
    while true do
    begin
        item = produce_item;
        ProducerConsumer.insert(item);
    end
end;

// 消费者客户端
procedure consumer
begin
    while true do
    begin
        item = ProducerConsumer.remove;
        consume_item(item);
    end
end;
```

##### 5. 经典同步问题

###### (1) 读者-写者问题

允许多个进程**同时**对数据进行**读操作**，但是**不允许读和写以及写和写操作同时发生**。

一个整型变量 **count** 记录在对**数据进行读操作的进程数量**，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。

```c
typedef int semaphore;
semaphore count_mutex = 1;
semaphore data_mutex = 1;
int count = 0;

void reader() {
    while(TRUE) {
        down(&count_mutex);
        count++;
        if(count == 1) down(&data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
        up(&count_mutex);
        read();
        down(&count_mutex);
        count--;
        if(count == 0) up(&data_mutex);
        up(&count_mutex);
    }
}

void writer() {
    while(TRUE) {
        down(&data_mutex);
        write();
        up(&data_mutex);
    }
}
```

###### (2) 哲学家进餐问题

<img src="assets/1563375277553.png" alt="1563375277553" style="zoom:50%;" />

五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且**一次只能拿起一根筷子**。

下面是一种错误的解法，考虑到如果所有哲学家同时拿起左手边的筷子，那么就无法拿起右手边的筷子，造成**死锁**。

```c
#define N 5

void philosopher(int i) {
    while(TRUE) {
        think();
        take(i);       // 拿起左边的筷子
        take((i+1)%N); // 拿起右边的筷子
        eat();
        put(i);
        put((i+1)%N);
    }
}
```

为了防止死锁的发生，可以设置**两个条件**：

- 必须**同时拿起左右两根**筷子；
- 只有在**两个邻居都没有进餐**的情况下才允许进餐。

```c
#define N 5
#define LEFT (i + N - 1) % N // 左邻居
#define RIGHT (i + 1) % N    // 右邻居
#define THINKING 0
#define HUNGRY   1
#define EATING   2
typedef int semaphore;
int state[N];                // 跟踪每个哲学家的状态
semaphore mutex = 1;         // 临界区的互斥
semaphore s[N];              // 每个哲学家一个信号量

void philosopher(int i) {
    while(TRUE) {
        think();
        take_two(i);
        eat();
        put_two(i);
    }
}

void take_two(int i) {
    down(&mutex);
    state[i] = HUNGRY;
    test(i);
    up(&mutex);
    down(&s[i]);
}

void put_two(i) {
    down(&mutex);
    state[i] = THINKING;
    test(LEFT);
    test(RIGHT);
    up(&mutex);
}

void test(i) {         // 尝试拿起两把筷子
    if(state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] !=EATING) {
        state[i] = EATING;
        up(&s[i]);
    }
}
```



#### 线程同步

**线程同步**是两个或多个共享关键资源的**线程的并发执行**。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：

1. **信号量(Semphares)** ：它允许同一时刻**多个线程**访问**同一资源**，但是需要控制同一时刻**访问此资源的最大线程数量**。就像 JDK 中的 Semphare 类。
2. **互斥量(Mutex)**：采用**互斥对象机制**，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 **synchronized** 关键词和各种 **Lock** 都是这种机制。互斥量是信号量的一种**特殊形式**。
3. **事件(Event)** : **Wait/Notify 机制**，通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。



#### 进程间通信

IPC 即进程间通信。进程同步与进程通信很容易混淆，它们的区别在于：

- **进程同步**：**控制多个进程按一定顺序执行**。
- **进程通信**：**进程间传输信息**。

进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

##### 1. 普通管道

管道是通过调用 ==**pipe**== 函数创建的，**fd[0] 用于读，fd[1] 用于写**。

```c
#include <unistd.h>
int pipe(int fd[2]);
```

**管道**可用于**具有亲缘关系进程间**的通信，允许一个进程和另一个与它有**共同祖先的进程**之间进行通信。它具有以下限制：

- 只支持**半双工**通信（单向交替传输）。
- **只能**在**父子进程**中使用。

<img src="assets/1563375313528.png" alt="1563375313528" style="zoom: 80%;" />

##### 2. 命名管道

也称为**命名管道**，**没有了管道只能在父子进程**中使用的限制。命名管道克服了管道**没有名字**的限制，因此除具有管道所具有的功能外，它还允许**无亲缘关系进程间**的通信。命名管道在文件系统中有对应的**文件名**。命名管道通过命令 **mkfifo** 或系统调用 **mkfifo** 来创建。

```c
#include <sys/stat.h>
int mkfifo(const char *path, mode_t mode);
int mkfifoat(int fd, const char *path, mode_t mode);
```

FIFO 常用于**客户-服务器**应用程序中，FIFO 用作**汇聚点**，在客户进程和服务器进程之间传递数据。

<img src="assets/1563375327590.png" alt="1563375327590" style="zoom:70%;" />

##### 3. 消息队列

**消息队列**是消息的**链表**，具有特定的格式，存放在内存中并由**消息队列标识符**标识。管道和消息队列的通信数据都是先进先出的原则。与管道（**无名管道**：只存在于内存中的文件；**命名管道**：存在于实际的磁盘介质或者文件系统）不同的是**消息队列存放在内核**中，只有在**内核重启**(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。比 FIFO 更有优势。**消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。**

相比于 FIFO，消息队列具有以下优点：

- 消息队列可以**独立于**读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难。
- 避免了 FIFO 的**同步阻塞**问题，不需要进程自己提供同步方法。
- 读进程可以根据消息类型有**选择地接收**消息，而不像 FIFO 那样只能默认地接收。

##### 4. 信号量

它是一个**计数器**，用于为**多个进程**提供对**共享数据对象**的访问。信号量的意图在于**进程间同步**。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。主要作为进程间以及同一进程不同线程之间的同步手段。

##### 5. 共享内存

**允许多个进程共享**一个给定的**存储区**，不同进程可以及时看到对方进程中对**共享内存中数据的更新**。因为数据**不需要**在进程之间**复制**，所以这是**最快**的一种 IPC。这种方式需要依靠某种同步操作，如**互斥锁和信号量**等。

需要使用**信号量**用来**同步对共享存储的访问**。

多个进程可以将同一个文件映射到它们的**地址空间从而实现共享内存**。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。

##### 6. 套接字

套接字可用于**不同主机**之间的**进程通信**。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。



#### 死锁

##### 1. 必要条件

<img src="assets/1563375370357.png" alt="1563375370357" style="zoom: 62%;" />

发生死锁的四个必要条件：

- **互斥条件**：一个资源只能被**一个进程使用**。
- **不可抢占条件**：已经分配给一个进程的资源**不能强制性地被抢占**，只有**线程自己把资源释放**了。
- **占有和等待条件**：已经得到了某个资源的**进程**可以**再请求新**的资源。
- **环路等待条件**：有两个或者两个以上的**进程组成一条环路**，该环路中的每个进程都在**等待**下一个进程所占有的资源。

##### 2. 死锁处理方法

**处理死锁**主要有以下几种方法：

- **死锁预防**

- **鸵鸟策略**
- **死锁检测**
- **死锁恢复**
- **死锁避免**

##### 3. 死锁预防

在程序运行之前**预防发生死锁**。就是破坏死锁发生的四个**必要环节**就行。

###### (1) 破坏互斥条件

例如脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。

###### (2) 破坏占有和等待条件

一种实现方式是规定所有进程在**开始执行前请求所需要的全部资源**。

###### (3) 破坏不可抢占条件

###### (4) 破坏环路等待

给资源**统一编号**，进程只能**按编号顺序**来请求资源。

##### 4. 鸵鸟策略

把头埋在沙子里，**假装根本没发生问题**。因为解决死锁问题的代价很高，因此鸵鸟策略这种**不采取任务措施**的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是**忽略它**。

##### 5. 死锁检测

不试图阻止死锁，而是当**检测到死锁发生时**，采取措施进行**恢复**。

###### (1) 每种类型一个资源的死锁检测

<img src="assets/1563375435171.png" alt="1563375435171" style="zoom:70%;" />

上图为资源分配图，其中方框表示**资源**，圆圈表示**进程**。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。图 a 可以抽取出环，如图 b，它满足了**环路等待**条件，因此会发生死锁。

每种类型一个资源的死锁检测算法是通过==**检测有向图是否存在环**==来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。

###### (2) 每种类型多个资源的死锁检测

<img src="assets/1563375453688.png" alt="1563375453688" style="zoom: 67%;" />

上图中，有**三个进程四个资源**，每个数据代表的含义如下：

- E 向量：资源总量。
- A 向量：资源剩余量。
- C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量。
- R 矩阵：每个进程请求的资源数量。

进程 P<sub>1</sub> 和 P<sub>2</sub> 所请求的资源都得不到满足，只有进程 P<sub>3</sub> 可以，让 P<sub>3</sub> 执行，之后释放 P<sub>3</sub> 拥有的资源，此时 A = (2 2 2 0)。P<sub>2</sub> 可以执行，执行后释放 P<sub>2</sub> 拥有的资源，A = (4 2 2 1) 。P<sub>1</sub> 也可以执行。所有进程都可以顺利执行，没有死锁。

算法总结如下：每个进程**最开始时都不被标记**，执行过程有可能被标记。当算法结束时，**任何没有被标记的进程都是死锁进程**。

1. 寻找一个没有标记的进程 P<sub>i</sub>，它所请求的资源小于等于 A。
2. 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。
3. 如果没有这样一个进程，算法终止。

##### 6. 死锁恢复

- 利用**抢占**恢复。
- 利用**回滚**恢复。
- 通过**杀死进程**恢复。

##### 7. 死锁避免

在程序**运行时**避免发生死锁。

###### (1) 安全状态

<img src="assets/1563375488859.png" alt="1563375488859" style="zoom:90%;" />

图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使所有进程都能成功运行，因此可以称图 a 所示的状态是安全的。

定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。

安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。

###### (2) 单个资源的银行家算法

一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。

<img src="assets/1563375577700.png" alt="1563375577700" style="zoom:90%;" />

上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。

###### (3) 多个资源的银行家算法

<img src="assets/1563375616191.png" alt="1563375616191" style="zoom:90%;" />

上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。

检查一个状态是否安全的算法如下：

- 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。
- 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。
- 重复以上两步，直到所有进程都标记为终止，则状态时安全的。

如果一个状态不是安全的，需要拒绝进入这个状态。





#### 参考资料

- 协程：jianshu.com/p/6dde7f92951e
- labuladong文章：Linux的进程、线程、文件描述符是什么









